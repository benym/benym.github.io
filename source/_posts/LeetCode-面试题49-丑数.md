---
title: LeetCode-面试题49-丑数
date: 2020/5/8 17:10:42
description: 丑数
categories: 剑指Offer
tags:
- DP
- Java
- Medium
- 剑指Offer
keywords: DP,Java,Medium,剑指Offer
---

## LeetCode-面试题49-丑数 

我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。

 <!--more-->

**示例1：**

```
输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
```

**说明：**

1. `1` 是丑数。
2. `n` **不超过**1690。

### 解题思路

这个题暴力破解的解法很耗时，就是循环判断一个数是否能被2，3，5整除，如果都能，则最后的因子是1，就说明这是丑数，外层还需要一个n的循环，非常耗时。更好的解法如下

**三指针：**

问题分析：一个丑数只有2，3，5这3个因子，1也是丑数，那么基本的3个丑数就可以由`1*2、1*3、1*5`得到，而其他的丑数也可以由2、3、5的乘积得到，这样问题就转化为了一个类似DP的问题，最小的问题是2、3、5，大一点的问题是乘以2、3、5得到的丑数。

由于需要从小到大的顺序排列n个丑数，所以怎么去保持丑数的顺序很重要

在每次计算出基于2、3、5的3个丑数时，始终把最小的丑数添加进dp[i]中

之后谁的结果最小，就移动那个指针

如果第i个丑数==2xp2，也就是说前面0-p2个丑数*2不可能产生比第i个丑数更大的丑数了，所以p2++

p3，p5同理

一个更好理解的例子源于https://leetcode-cn.com/u/sunrise-9/

```
丑数的排列肯定是1,2,3,4,5,6,8,10.... 然后有一个特点是，任意一个丑数都是由小于它的某一个丑数*2，*3或者*5得到的，那么如何得到所有丑数呢？ 现在假设有3个数组，分别是： A：{1*2，2*2，3*2，4*2，5*2，6*2，8*2，10*2......}

B：{1*3，2*3，3*3，4*3，5*3，6*3，8*3，10*3......}

C：{1*5，2*5，3*5，4*5，5*5，6*5，8*5，10*5......}

那么所有丑数的排列，必定就是上面ABC3个数组的合并结果然后去重得到的，那么这不就转换成了三个有序数组的无重复元素合并的问题了吗？而这三个数组就刚好是{1,2,3,4,5,6,8,10....}乘以2,3,5得到的。

合并有序数组的一个比较好的方法，就是每个数组都对应一个指针，然后比较这些指针所指的数中哪个最小，就将这个数放到结果数组中，然后该指针向后挪一位。

回到本题，要求丑数ugly数组中的第n项，而目前只知道ugly[0]=1，所以此时三个有序链表分别就只有一个元素：

A ： {1*2......}

B ： {1*3......}

C ：{1*5......}

假设三个数组的指针分别是i,j,k，此时均是指向第一个元素，然后比较A[i]，B[j]和C[k]，得到的最小的数A[i]，就是ugly[1]，此时ugly就变成{1,2}了，对应的ABC数组就分别变成了：

A ： {1*2，2*2......}

B ： {1*3, 2*3......}

C ：{1*5,2*5......}

此时根据合并有序数组的原理，A数组指针i就指向了下一个元素，即'2*2'，而j和k依然分别指向B[0]和C[0]，然后进行下一轮合并，就是A[1]和B[0]和C[0]比较，最小值作为ugly[2].....如此循环n次，就可以得到ugly[n]了。

此外，注意到ABC三个数组实际上就是ugly[]*2，ugly[]*3和ugly[]*5的结果，所以每次只需要比较A[i]=ugly[i]*2，B[j]=ugly[j]*3和C[k]=ugly[k]*5的大小即可。然后谁最小，就把对应的指针往后移动一个，为了去重，如果多个元素都是最小，那么这多个指针都要往后移动一个。
```

### Java代码

```java
class Solution {
    public int nthUglyNumber(int n) {
        int p2=0,p3=0,p5=0; // 想象初始化3个有序链表的第一个元素，分别为2、3、5为基数乘的数组
        int[] dp = new int[n];
        dp[0] = 1;
        for(int i=1;i<n;i++){
            // 返回的下一个丑数应该是*2,*3,*5之后的最小丑数
            dp[i] = Math.min(dp[p2]*2,Math.min(dp[p3]*3,dp[p5]*5));
            if(dp[i]==dp[p2]*2) p2++;
            if(dp[i]==dp[p3]*3) p3++;
            if(dp[i]==dp[p5]*5) p5++;
        }
        return dp[n-1];
    }
}
```
