<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ming.Y</title>
  
  <subtitle>Chances are for people who are prepared</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://benym.cn/"/>
  <updated>2020-05-19T11:42:59.448Z</updated>
  <id>http://benym.cn/</id>
  
  <author>
    <name>BenY</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode-面试题59-2-队列的最大值</title>
    <link href="http://benym.cn/2020/05/19/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9859-2-%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>http://benym.cn/2020/05/19/LeetCode-面试题59-2-队列的最大值/</id>
    <published>2020-05-19T08:39:45.000Z</published>
    <updated>2020-05-19T11:42:59.448Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-面试题59-2-队列的最大值"><a href="#LeetCode-面试题59-2-队列的最大值" class="headerlink" title="LeetCode-面试题59-2-队列的最大值"></a>LeetCode-面试题59-2-队列的最大值</h2><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p><p>若队列为空，pop_front 和 max_value 需要返回 -1</p> <a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[&quot;MaxQueue&quot;,&quot;push_back&quot;,&quot;push_back&quot;,&quot;max_value&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]</span><br><span class="line">[[],[1],[2],[],[],[]]</span><br><span class="line">输出: [null,null,null,2,1,2]</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[&quot;MaxQueue&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]</span><br><span class="line">[[],[],[]]</span><br><span class="line">输出: [null,-1,-1]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000</code></li><li><code>1 &lt;= value &lt;= 10^5</code></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>双队列：</p><p>利用一个队列Queue存储原本的数据，一个双端队列Deque存储最大值</p><p>两个队列联合实现一个MaxQueue</p><ul><li>当新的值大于deque的尾部的值时，小的值都应该从deque尾部删去，添加大的值到尾部；同时queue实现常规的数值添加。这样保证了deque首位始终存储的是当前队列最大值</li><li>当需要取得队列中的最大值时，如果deque为空，根据题意返回-1，如果不为空则取得最大值(不从双端队列中删除)</li><li>当需要弹出队列首位时，需要判断原本的队列是否为空，为空则返回-1，不为空则需要判断出队的元素是否是当前最大值，如果是最大值，则原本的队列最大值出队了，deque中的最大值自然也不存在了，需要弹出首位。此时返回原本队列的首位即可</li></ul><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> </span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; deque;</span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(deque.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> deque.getFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保证deque里面放的是最大值</span></span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.getLast()&lt;value)</span><br><span class="line">            deque.removeLast();</span><br><span class="line">        deque.addLast(value);</span><br><span class="line">        queue.offer(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(queue.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果出队的元素是当前最大值，则deque也要出队</span></span><br><span class="line">        <span class="keyword">int</span> temp = queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(deque.getFirst()==temp)</span><br><span class="line">            deque.removeFirst();</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MaxQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MaxQueue obj = new MaxQueue();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.max_value();</span></span><br><span class="line"><span class="comment"> * obj.push_back(value);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.pop_front();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      队列的最大值
    
    </summary>
    
      <category term="剑指Offer" scheme="http://benym.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="剑指Offer" scheme="http://benym.cn/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="队列" scheme="http://benym.cn/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-面试题59-1-滑动窗口的最大值</title>
    <link href="http://benym.cn/2020/05/19/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9859-1-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>http://benym.cn/2020/05/19/LeetCode-面试题59-1-滑动窗口的最大值/</id>
    <published>2020-05-19T07:13:10.000Z</published>
    <updated>2020-05-19T09:02:45.530Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-面试题59-1-滑动窗口的最大值"><a href="#LeetCode-面试题59-1-滑动窗口的最大值" class="headerlink" title="LeetCode-面试题59-1-滑动窗口的最大值"></a>LeetCode-面试题59-1-滑动窗口的最大值</h2><p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p> <a id="more"></a><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3</span><br><span class="line">输出: [3,3,5,5,6,7] </span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>你可以假设 <em>k</em> 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>常规的想法是滑动一次窗口遍历一次窗口值，返回最大值，但这样的时间复杂度是O(nk)</p><p>双端队列：</p><p>把有可能成为滑动窗口最大值的数字存入双端队列中，最大值始终放在队列头部</p><p>对于前k个数值，当队列不为空的情况下，如果当前遍历的元素要&gt;=队列尾部元素，则说明队列尾部的值不可能是最大值，弹出队列尾部，添加当前值</p><p>对于[k,nums.length]区间的数值，需要判断队列中的值是否仍然在滑动窗口内部，如果不在内部需要弹出队列头部。如果当前遍历的元素要&gt;=队列尾部元素，则说明队列尾部的值不可能是最大值，弹出队列尾部。遍历时恒添加当前元素到末尾。</p><p>为了便于判断队列头部是否还在滑动窗口内部，队列存储的并非是真正的元素，而是元素在数组中的下标</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums.length &gt;= k &amp;&amp; k &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            Deque&lt;Integer&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="comment">// 前k个</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">                <span class="comment">// 队列不为空，且当前元素&gt;=队列尾部，则尾部不可能是最大值，弹出</span></span><br><span class="line">                <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.getLast()])</span><br><span class="line">                    deque.removeLast();</span><br><span class="line">                deque.addLast(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// k到末尾个</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; nums.length; i++) &#123;</span><br><span class="line">                <span class="comment">// 添加最大值</span></span><br><span class="line">                res.add(nums[deque.getFirst()]);</span><br><span class="line">                <span class="comment">// 队列不为空，且当前元素&gt;=队列尾部，则尾部不可能是最大值，弹出</span></span><br><span class="line">                <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.getLast()])</span><br><span class="line">                    deque.removeLast();</span><br><span class="line">                <span class="comment">// 判断队列头部是否还在滑动窗口内，如果当前处理元素的下标i减去窗口大小k&gt;=队列头部下标</span></span><br><span class="line">                <span class="comment">// 说明头部不在滑动窗口内，需要弹出</span></span><br><span class="line">                <span class="keyword">if</span> (!deque.isEmpty() &amp;&amp; deque.getFirst() &lt;= (i - k))</span><br><span class="line">                    deque.removeFirst();</span><br><span class="line">                deque.addLast(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 添加最后一个滑动窗口的最大值</span></span><br><span class="line">            res.add(nums[deque.getFirst()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.stream().mapToInt(Integer::intValue).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> k == <span class="number">0</span>: <span class="keyword">return</span> []</span><br><span class="line">        deque = collections.deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="keyword">while</span> deque <span class="keyword">and</span> deque[<span class="number">-1</span>] &lt; nums[i]: deque.pop()</span><br><span class="line">            deque.append(nums[i])</span><br><span class="line">        res = [deque[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k, len(nums)):</span><br><span class="line">            <span class="keyword">if</span> deque[<span class="number">0</span>] == nums[i - k]: deque.popleft()</span><br><span class="line">            <span class="keyword">while</span> deque <span class="keyword">and</span> deque[<span class="number">-1</span>] &lt; nums[i]: deque.pop()</span><br><span class="line">            deque.append(nums[i])</span><br><span class="line">            res.append(deque[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      滑动窗口的最大值
    
    </summary>
    
      <category term="剑指Offer" scheme="http://benym.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Hard" scheme="http://benym.cn/tags/Hard/"/>
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="剑指Offer" scheme="http://benym.cn/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-面试题58-2-左旋转字符串</title>
    <link href="http://benym.cn/2020/05/19/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9858-2-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://benym.cn/2020/05/19/LeetCode-面试题58-2-左旋转字符串/</id>
    <published>2020-05-19T06:47:01.000Z</published>
    <updated>2020-05-19T07:08:19.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-面试题58-2-左旋转字符串"><a href="#LeetCode-面试题58-2-左旋转字符串" class="headerlink" title="LeetCode-面试题58-2-左旋转字符串"></a>LeetCode-面试题58-2-左旋转字符串</h2><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p> <a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;lrloseumgh&quot;, k = 6</span><br><span class="line">输出: &quot;umghlrlose&quot;</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>1 &lt;= k &lt; s.length &lt;= 10000</code></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>线性遍历：</p><p>n已经给出来了，第一部分字符串就是从n到字符末尾，第二部分字符串是从字符开始到n，用StringBuilder添加进去最后转化为String即可</p><p>切片：</p><p>s[n:]+s[:n]搞定</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseLeftWords</span><span class="params">(String s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>||s.length()&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span>(s!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;s.length();i++)&#123;</span><br><span class="line">                res.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                res.append(s.charAt(j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseLeftWords</span><span class="params">(self, s: str, n: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        <span class="keyword">if</span> s:</span><br><span class="line">            <span class="keyword">return</span> s[n:]+s[:n]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      左旋转字符串
    
    </summary>
    
      <category term="剑指Offer" scheme="http://benym.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="字符串" scheme="http://benym.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="Python" scheme="http://benym.cn/tags/Python/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="剑指Offer" scheme="http://benym.cn/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-面试题58-1-翻转单词顺序</title>
    <link href="http://benym.cn/2020/05/19/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9858-1-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/"/>
    <id>http://benym.cn/2020/05/19/LeetCode-面试题58-1-翻转单词顺序/</id>
    <published>2020-05-19T03:09:40.000Z</published>
    <updated>2020-05-19T06:42:30.504Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-面试题58-1-翻转单词顺序"><a href="#LeetCode-面试题58-1-翻转单词顺序" class="headerlink" title="LeetCode-面试题58-1-翻转单词顺序"></a>LeetCode-面试题58-1-翻转单词顺序</h2><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p> <a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;the sky is blue&quot;</span><br><span class="line">输出: &quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;  hello world!  &quot;</span><br><span class="line">输出: &quot;world! hello&quot;</span><br><span class="line">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;a good   example&quot;</span><br><span class="line">输出: &quot;example good a&quot;</span><br><span class="line">解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>无空格字符构成一个单词。</li><li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li><li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>双指针切割交换(Python)：</p><p>多余的空格直接用split()函数就能够处理，切分之后，利用双指针不断首尾交换，就能够固定单词，翻转单词位置，之后返回字符串即可，这种方法比较偷懒</p><p>双指针记录位置(Java)：</p><p>初始化两个指针从数组的末尾开始</p><ul><li>当遇到的字符不是空格时，移动start指针，找到单词的开头，然后利用substring方法截取单词</li><li>当遇到的字符是空格时，继续移动start指针，找到下一个单词的末尾，将end指针移动到start位置，重复以上步骤即可</li></ul><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        s = s.trim();</span><br><span class="line">        <span class="keyword">int</span> start =  s.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> end = start;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(start&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(start&gt;=<span class="number">0</span>&amp;&amp;s.charAt(start)!=<span class="string">' '</span>)</span><br><span class="line">                start--;</span><br><span class="line">            res.append(s.substring(start+<span class="number">1</span>,end+<span class="number">1</span>)+<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">while</span>(start&gt;=<span class="number">0</span>&amp;&amp;s.charAt(start)==<span class="string">' '</span>)</span><br><span class="line">                start--;</span><br><span class="line">            end=start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString().trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        arr = s.split()</span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = len(arr)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> start&lt;end:</span><br><span class="line">            temp = arr[start]</span><br><span class="line">            arr[start] = arr[end]</span><br><span class="line">            arr[end] = temp</span><br><span class="line">            start+=<span class="number">1</span></span><br><span class="line">            end-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">" "</span>.join(arr)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      翻转单词顺序
    
    </summary>
    
      <category term="剑指Offer" scheme="http://benym.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="字符串" scheme="http://benym.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="Python" scheme="http://benym.cn/tags/Python/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="剑指Offer" scheme="http://benym.cn/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-面试题57-2-和为s的连续正数序列</title>
    <link href="http://benym.cn/2020/05/19/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9857-2-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/"/>
    <id>http://benym.cn/2020/05/19/LeetCode-面试题57-2-和为s的连续正数序列/</id>
    <published>2020-05-19T02:00:38.000Z</published>
    <updated>2020-05-19T03:10:12.002Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-面试题57-2-和为s的连续正数序列"><a href="#LeetCode-面试题57-2-和为s的连续正数序列" class="headerlink" title="LeetCode-面试题57-2-和为s的连续正数序列"></a>LeetCode-面试题57-2-和为s的连续正数序列</h2><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p> <a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 9</span><br><span class="line">输出：[[2,3,4],[4,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 15</span><br><span class="line">输出：[[1,2,3,4,5],[4,5,6],[7,8]]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>1 &lt;= target &lt;= 10^5</code></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>滑动窗口：</p><p>序列至少包含2个数，窗口从1(small)，2(big)开始，且small指针不会超过中值，简单例子，比如15=8+small，small是不可能比8大的，当small都已经跨过中值，big肯定也比small大，两个的组合不可能得到target，所以small&lt;mid即可</p><p>接下来分为3种情况讨论：</p><ul><li>当序列和curSum&lt;target时，说明需要扩大窗口，这里恒向右扩大，指针右移big++，当前序列值也需要加上big，curSum+=big</li><li>当序列和curSum&gt;target时，说明需要缩小窗口，从最小的值开始缩小，curSum-=small，之后指针左移small—</li><li>当序列和curSum==target时，说明序列和满足要求，由于要求二维数组存储，这里新开辟一个big-small+1大小的数组，存储[small,big]范围内的数字，之后添加进res中。之后使big指针右移，curSum+=big，继续下一轮的窗口计算</li></ul><p>实际上序列和可以由公式<code>(left+right)*(right-left+1)//2</code>得到，Python代码返回更加轻松</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] findContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> small = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> big = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (target+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> curSum = small+big;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(small&lt;mid)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curSum==target)&#123;</span><br><span class="line">                <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[big-small+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=small;k&lt;=big;k++)&#123;</span><br><span class="line">                    nums[i] = k;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                res.add(nums);</span><br><span class="line">                big++;</span><br><span class="line">                curSum+=big;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(curSum&lt;target)&#123;</span><br><span class="line">                big++;</span><br><span class="line">                curSum+=big;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curSum-=small;</span><br><span class="line">                small++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[res.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findContinuousSequence</span><span class="params">(self, target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        left,right = <span class="number">1</span>,<span class="number">2</span></span><br><span class="line">        mid = (target+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> left&lt;mid:</span><br><span class="line">            sum = (left+right)*(right-left+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">            tlist = []</span><br><span class="line">            <span class="keyword">if</span> sum&lt;target:</span><br><span class="line">                right+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> sum&gt;target:</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(left,right+<span class="number">1</span>):</span><br><span class="line">                    tlist.append(i)</span><br><span class="line">                res.append(tlist)</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">                right+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      和为s的两个数字
    
    </summary>
    
      <category term="剑指Offer" scheme="http://benym.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Python" scheme="http://benym.cn/tags/Python/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="剑指Offer" scheme="http://benym.cn/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-面试题57-和为s的两个数字</title>
    <link href="http://benym.cn/2020/05/19/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9857-1-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/"/>
    <id>http://benym.cn/2020/05/19/LeetCode-面试题57-1-和为s的两个数字/</id>
    <published>2020-05-19T01:15:38.000Z</published>
    <updated>2020-05-19T01:24:53.791Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-面试题57-和为s的两个数字"><a href="#LeetCode-面试题57-和为s的两个数字" class="headerlink" title="LeetCode-面试题57-和为s的两个数字"></a>LeetCode-面试题57-和为s的两个数字</h2><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p> <a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[2,7] 或者 [7,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,26,30,31,47,60], target = 40</span><br><span class="line">输出：[10,30] 或者 [30,10]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>1 &lt;= nums[i] &lt;= 10^6</code></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>查找思想：</p><p>一个头指针一个尾指针，在递增排序的数组中，</p><p>如果对应位置之和大于target，说明需要取小一点，左移尾指针让数值变小</p><p>如果对应位置之和小于target，说明需要取大一点，右移头指针，让数值变大</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[start]+nums[end]&lt;target)</span><br><span class="line">                start+=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[start]+nums[end]&gt;target)</span><br><span class="line">                end-=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums[start],nums[end]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        start,end = <span class="number">0</span>,len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> start&lt;end:</span><br><span class="line">            <span class="keyword">if</span> nums[start]+nums[end]&gt;target:</span><br><span class="line">                end-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[start]+nums[end]&lt;target:</span><br><span class="line">                start+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">return</span> nums[start],nums[end]</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      和为s的两个数字
    
    </summary>
    
      <category term="剑指Offer" scheme="http://benym.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Python" scheme="http://benym.cn/tags/Python/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="剑指Offer" scheme="http://benym.cn/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-面试题56-2-数组中数字出现的次数2</title>
    <link href="http://benym.cn/2020/05/18/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9856-2-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B02/"/>
    <id>http://benym.cn/2020/05/18/LeetCode-面试题56-2-数组中数字出现的次数2/</id>
    <published>2020-05-18T09:13:05.000Z</published>
    <updated>2020-05-19T01:16:22.144Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-面试题56-2-数组中数字出现的次数2"><a href="#LeetCode-面试题56-2-数组中数字出现的次数2" class="headerlink" title="LeetCode-面试题56-2-数组中数字出现的次数2"></a>LeetCode-面试题56-2-数组中数字出现的次数2</h2><p>在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p> <a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,4,3,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [9,1,7,9,7,9,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><ul><li><p><strong>限制：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10000</code></li><li><code>1 &lt;= nums[i] &lt; 2^31</code></li></ul></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>方法1、异或运算(单1为1，其余0)：</p><p>先对所有数字的各个位求和，求和之后的数字，能够被3整除的，则该位为0，不能够被整除的，则该位为1，之后就能够通过2进制求出对应的数字</p><p>方法2、字典：</p><p>遇到没在字典的加入，在字典就+1，最后取value为1的key即可</p><p>方法3、数组：</p><p>先给数组排序，排序之后判断当前位和后面2位是否相等，如果相等则跳过这3位，i+3</p><p>如果不相等，则说明当前为就是要找的数字</p><p>如果前面都没有找到，则最后一位必定是要找的数字</p><h3 id="Java代码1"><a href="#Java代码1" class="headerlink" title="Java代码1"></a>Java代码1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] bitSum = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>]; <span class="comment">// 最高2^31次方数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> bitMask = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 累加各个位置的二进制表示</span></span><br><span class="line">            <span class="comment">// 这里从数组末尾开始，对应二进制最小位</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">31</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">int</span> bit = nums[i]&amp;bitMask;</span><br><span class="line">                <span class="keyword">if</span>(bit!=<span class="number">0</span>)</span><br><span class="line">                    bitSum[j]+=<span class="number">1</span>;</span><br><span class="line">                    bitMask&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 从数组0位开始，对应于数字的高位，当遍历到余数为1时，res仅为1，比如数字8的二进制为0100</span></span><br><span class="line">        <span class="comment">// 从左到右遍历，当遍历到数字1时</span></span><br><span class="line">        <span class="comment">// 此时res为1，想要从1变成8，需要向左移动2位，而for循环剩下的次数就是需要&lt;&lt;左移的次数，最后得到res才是正确的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">            result = result&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            result+=bitSum[i]%<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">                dic[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[i] +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> dic:</span><br><span class="line">            <span class="keyword">if</span> dic[i]==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="Java代码2"><a href="#Java代码2" class="headerlink" title="Java代码2"></a>Java代码2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length-<span class="number">3</span>;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==nums[i+<span class="number">1</span>]&amp;&amp;nums[i+<span class="number">1</span>]==nums[i+<span class="number">2</span>])</span><br><span class="line">                i+=<span class="number">3</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      数组中数字出现的次数2
    
    </summary>
    
      <category term="剑指Offer" scheme="http://benym.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="Python" scheme="http://benym.cn/tags/Python/"/>
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="剑指Offer" scheme="http://benym.cn/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-面试题56-1-数组中数字出现的次数</title>
    <link href="http://benym.cn/2020/05/18/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9856-1-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B01/"/>
    <id>http://benym.cn/2020/05/18/LeetCode-面试题56-1-数组中数字出现的次数1/</id>
    <published>2020-05-18T08:06:08.000Z</published>
    <updated>2020-05-18T08:57:05.341Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-面试题56-1-数组中数字出现的次数"><a href="#LeetCode-面试题56-1-数组中数字出现的次数" class="headerlink" title="LeetCode-面试题56-1-数组中数字出现的次数"></a>LeetCode-面试题56-1-数组中数字出现的次数</h2><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p> <a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,10,4,1,4,3,3]</span><br><span class="line">输出：[2,10] 或 [10,2]</span><br></pre></td></tr></table></figure><ul><li><p><strong>限制：</strong></p><p><code>2 &lt;= nums.length &lt;= 10000</code></p></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>异或运算(单1为1，其余0)：</p><p>根据异或运算的特点，相同的数字会在异或的时候抵消了，不相同的数字，其不相同的位会被保留</p><p>如果数组中有2个数字是不相同的，所以对数组整体异或之后，剩下的数字肯定至少有一位为1</p><p>如果能够找到第一个为1的那一位，那么就能够通过判断这一位是否为1，而划分数组为2个子数组</p><p>这样问题就分解成了，分别寻找2个子数组中，只出现一次的数字</p><p>由于判断位的条件具有二分性，当判断出一个不相同的数字位为1时，另一个数字该位则不为1，于是划分的子数组中自然一个数组会包含一个不相同数字</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 数组整体异或</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)</span><br><span class="line">            temp^=i;</span><br><span class="line">        <span class="comment">// 初始化mask=1</span></span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 通过mask，判断第一次出现1的位数</span></span><br><span class="line">        <span class="keyword">while</span>((temp&amp;mask)==<span class="number">0</span>)&#123;</span><br><span class="line">            mask&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j:nums)&#123;</span><br><span class="line">            <span class="comment">// 通过判断1出现的位置和数组元素与运算结果是否为0，来二分数组</span></span><br><span class="line">            <span class="keyword">if</span>((j&amp;mask)==<span class="number">0</span>)&#123; <span class="comment">// 相同的数字会分在一起，但不同的数字会因此隔开</span></span><br><span class="line">                num1^=j;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                num2^=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;num1,num2&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      数组中数字出现的次数
    
    </summary>
    
      <category term="剑指Offer" scheme="http://benym.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="剑指Offer" scheme="http://benym.cn/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-面试题55-2-平衡二叉树</title>
    <link href="http://benym.cn/2020/05/18/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9855-2-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://benym.cn/2020/05/18/LeetCode-面试题55-2-平衡二叉树/</id>
    <published>2020-05-18T04:58:06.000Z</published>
    <updated>2020-05-18T08:08:01.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-面试题55-2-平衡二叉树"><a href="#LeetCode-面试题55-2-平衡二叉树" class="headerlink" title="LeetCode-面试题55-2-平衡二叉树"></a>LeetCode-面试题55-2-平衡二叉树</h2><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中<strong>任意节点</strong>的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p> <a id="more"></a><p><strong>示例1：</strong></p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回<code>true</code> 。</p><p><strong>示例 2:</strong></p><p>给定二叉树 <code>[1,2,2,3,3,null,null,4,4]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      1</span><br><span class="line">     / \</span><br><span class="line">    2   2</span><br><span class="line">   / \</span><br><span class="line">  3   3</span><br><span class="line"> / \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure><p>返回 <code>false</code> 。</p><ul><li><strong>限制：</strong><ol><li><code>1 &lt;= 树的结点个数 &lt;= 10000</code></li></ol></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>方法1、DFS分别求深度：</p><p>这种方法就是上一个题的延续了，但是由于需要对每一个节点求对应的左右子树的深度，会造成很多重复计算。这是一个简单的解法但是不是好的解法</p><p>方法2、后序遍历+剪枝：</p><p>这是一个从底至顶的解法，当节点的左右子树的深度差&lt;=1时，就返回当前子树的深度</p><p>当前子树的深度由max(left,right)+1计算得到，如果不满足深度差条件，则说明子树不平衡，直接返回-1</p><p>递归的终止条件是，当root为空，说明越过叶子节点，返回深度0</p><p>当左右子树的深度不平衡时，即left==-1||right==-1时，提前终止递归进行剪枝，返回-1</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> nleft = DFS(root.left);</span><br><span class="line">        <span class="keyword">int</span> nright = DFS(root.right);</span><br><span class="line">        <span class="keyword">int</span> n = Math.abs(nleft-nright);</span><br><span class="line">        <span class="keyword">if</span>(n&gt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isBalanced(root.left)&amp;&amp;isBalanced(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">DFS</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nleft = DFS(root.left);</span><br><span class="line">        <span class="keyword">int</span> nright = DFS(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(nleft,nright)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(root)!=<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self,root:TreeNode)</span>-&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.helper(root.left)</span><br><span class="line">        <span class="keyword">if</span> left==<span class="number">-1</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        right = self.helper(root.right)</span><br><span class="line">        <span class="keyword">if</span> right==<span class="number">-1</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> max(left,right)+<span class="number">1</span> <span class="keyword">if</span> abs(left-right)&lt;=<span class="number">1</span> <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      平衡二叉树
    
    </summary>
    
      <category term="剑指Offer" scheme="http://benym.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="树" scheme="http://benym.cn/tags/%E6%A0%91/"/>
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Python" scheme="http://benym.cn/tags/Python/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="DFS" scheme="http://benym.cn/tags/DFS/"/>
    
      <category term="剑指Offer" scheme="http://benym.cn/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-面试题55-1-二叉树的深度</title>
    <link href="http://benym.cn/2020/05/14/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9855-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/"/>
    <id>http://benym.cn/2020/05/14/LeetCode-面试题55-1-二叉树的深度/</id>
    <published>2020-05-14T10:54:51.000Z</published>
    <updated>2020-05-18T03:02:07.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-面试题55-1-二叉树的深度"><a href="#LeetCode-面试题55-1-二叉树的深度" class="headerlink" title="LeetCode-面试题55-1-二叉树的深度"></a>LeetCode-面试题55-1-二叉树的深度</h2><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p> <a id="more"></a><p><strong>示例1：</strong></p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p><ul><li><strong>提示：</strong><ol><li><code>节点总数 &lt;= 10000</code></li></ol></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>方法1、DFS：</p><p>既然要求树的深度自然少不了深度优先遍历，通过比较左子树的深度和右子树的深度判断最大深度，之后加上根节点</p><p>方法2、BFS：</p><p>层序遍历一般也就是广度优先遍历，在原本队列的实现基础上，对一个层进行循环约束即可，每遍历完一层，深度就+1</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nleft = maxDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> nright = maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(nleft,nright)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue , depth = [] , <span class="number">0</span></span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                temp = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> temp.left:</span><br><span class="line">                    queue.append(temp.left)</span><br><span class="line">                <span class="keyword">if</span> temp.right:</span><br><span class="line">                    queue.append(temp.right)</span><br><span class="line">            depth+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      二叉树的深度
    
    </summary>
    
      <category term="剑指Offer" scheme="http://benym.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="树" scheme="http://benym.cn/tags/%E6%A0%91/"/>
    
      <category term="BFS" scheme="http://benym.cn/tags/BFS/"/>
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Python" scheme="http://benym.cn/tags/Python/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="DFS" scheme="http://benym.cn/tags/DFS/"/>
    
      <category term="剑指Offer" scheme="http://benym.cn/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-145-二叉树的后序遍历</title>
    <link href="http://benym.cn/2020/05/13/LeetCode-145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://benym.cn/2020/05/13/LeetCode-145-二叉树的后序遍历/</id>
    <published>2020-05-13T07:05:04.000Z</published>
    <updated>2020-05-18T03:02:07.022Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-145-二叉树的后序遍历"><a href="#LeetCode-145-二叉树的后序遍历" class="headerlink" title="LeetCode-145-二叉树的后序遍历"></a>LeetCode-145-二叉树的后序遍历</h2><p>给定一个二叉树，返回它的 <em>后序</em> 遍历。</p><p>相关链接：</p><ol><li><a href="/2020/05/13/LeetCode-94-二叉树的中序遍历/" title="LeetCode-94-二叉树的中序遍历">LeetCode-94-二叉树的中序遍历</a></li><li><a href="/2020/05/13/LeetCode-144-二叉树的前序遍历/" title="LeetCode-144-二叉树的前序遍历">LeetCode-144-二叉树的前序遍历</a></li></ol><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [3,2,1]</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>二叉树的遍历问题都有2种解法，一种是递归，一种是迭代</p><p>递归：开启左子树递归，开启右子树递归，添加根节点</p><p>迭代：后序遍历的方式是左右根，前序遍历是根左右，如果用Stack来实现根左右，那么左边先加入就会后出，右边后加入会先出，于是看似是add(left)之后add(right)，实际上会先访问到right再访问left，从而实现前序遍历得到根右左，即后序遍历的倒序，之后将列表倒序就是后序遍历的结果</p><p>迭代模拟：严格按照后序遍历的左右根访问，代码整体与中序遍历很相似，但需要注意其中两个点。</p><p>思想来源于<a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/di-gui-die-dai-qu-qiao-san-chong-fang-fa-quan-jie-/" target="_blank" rel="noopener">这里</a></p><p>第一，stack.peek()只是取出栈顶元素，要和stack.pop()弹出栈顶元素区分开来；</p><p>第二，变量last用于保存当前栈顶所弹出的元素，判断 curr.right == last 是为了避免重复访问同一个元素而陷入死循环当中</p><h3 id="Java代码-递归"><a href="#Java代码-递归" class="headerlink" title="Java代码(递归)"></a>Java代码(递归)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        helper(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        helper(root.left);</span><br><span class="line">        helper(root.right);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java代码-迭代Stack"><a href="#Java代码-迭代Stack" class="headerlink" title="Java代码(迭代Stack)"></a>Java代码(迭代Stack)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;(); <span class="comment">// Stack实现根右左</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        stack.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode temp = stack.pop();</span><br><span class="line">            res.addFirst(temp.val); <span class="comment">// 添加到头部，实现倒序</span></span><br><span class="line">            <span class="keyword">if</span>(temp.left!=<span class="keyword">null</span>)</span><br><span class="line">                stack.add(temp.left);</span><br><span class="line">            <span class="keyword">if</span>(temp.right!=<span class="keyword">null</span>)</span><br><span class="line">                stack.add(temp.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java代码-迭代模拟"><a href="#Java代码-迭代模拟" class="headerlink" title="Java代码(迭代模拟)"></a>Java代码(迭代模拟)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode curr = root;</span><br><span class="line">        TreeNode last = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(curr);</span><br><span class="line">                curr = curr.left;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = stack.peek();</span><br><span class="line">            <span class="keyword">if</span> (curr.right == <span class="keyword">null</span> || curr.right == last) &#123;</span><br><span class="line">                res.add(curr.val);</span><br><span class="line">                stack.pop();</span><br><span class="line">                last = curr;</span><br><span class="line">                curr = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr = curr.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      二叉树的后序遍历
    
    </summary>
    
      <category term="树" scheme="http://benym.cn/categories/%E6%A0%91/"/>
    
    
      <category term="树" scheme="http://benym.cn/tags/%E6%A0%91/"/>
    
      <category term="BFS" scheme="http://benym.cn/tags/BFS/"/>
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Hard" scheme="http://benym.cn/tags/Hard/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-144-二叉树的前序遍历</title>
    <link href="http://benym.cn/2020/05/13/LeetCode-144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://benym.cn/2020/05/13/LeetCode-144-二叉树的前序遍历/</id>
    <published>2020-05-13T05:01:06.000Z</published>
    <updated>2020-05-18T03:02:07.022Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-144-二叉树的前序遍历"><a href="#LeetCode-144-二叉树的前序遍历" class="headerlink" title="LeetCode-144-二叉树的前序遍历"></a>LeetCode-144-二叉树的前序遍历</h2><p>给定一个二叉树，返回它的 <em>前序</em> 遍历。</p><p>相关链接：</p><ol><li><a href="/2020/05/13/LeetCode-94-二叉树的中序遍历/" title="LeetCode-94-二叉树的中序遍历">LeetCode-94-二叉树的中序遍历</a></li><li><a href="/2020/05/13/LeetCode-145-二叉树的后序遍历/" title="LeetCode-145-二叉树的后序遍历">LeetCode-145-二叉树的后序遍历</a></li></ol><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">输出: [1,2,3]</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>二叉树的遍历问题都有2种解法，一种是递归，一种是迭代</p><p>递归：添加根节点，开启左子树递归，开启右子树递归</p><p>迭代：前序遍历一般等同于BFS，一般用Queue来实现，先进先出，层序遍历即可。</p><p>不过奇怪的是这个题跑不过测试用例…….只能换成栈来做，也就是调整一下加入顺序，需要先添加右子树，再添加左子树，由于pop是后进先出，所以弹出的顺序变为了先弹出左子树，再是右子树，变成了Queue的先进先出的样子</p><h3 id="Java代码-递归"><a href="#Java代码-递归" class="headerlink" title="Java代码(递归)"></a>Java代码(递归)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        BFS(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            BFS(root.left);</span><br><span class="line">            BFS(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java代码-迭代Queue"><a href="#Java代码-迭代Queue" class="headerlink" title="Java代码(迭代Queue)"></a>Java代码(迭代Queue)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode temp = queue.poll();</span><br><span class="line">            res.add(temp.val);</span><br><span class="line">            <span class="keyword">if</span>(temp.left!=<span class="keyword">null</span>)</span><br><span class="line">                queue.add(temp.left);</span><br><span class="line">            <span class="keyword">if</span>(temp.right!=<span class="keyword">null</span>)</span><br><span class="line">                queue.add(temp.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java代码-迭代Stack"><a href="#Java代码-迭代Stack" class="headerlink" title="Java代码(迭代Stack)"></a>Java代码(迭代Stack)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode temp = stack.pop();</span><br><span class="line">            res.add(temp.val);</span><br><span class="line">            <span class="keyword">if</span>(temp.right!=<span class="keyword">null</span>)</span><br><span class="line">                stack.add(temp.right);</span><br><span class="line">            <span class="keyword">if</span>(temp.left!=<span class="keyword">null</span>)</span><br><span class="line">                stack.add(temp.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      二叉树的前序遍历
    
    </summary>
    
      <category term="树" scheme="http://benym.cn/categories/%E6%A0%91/"/>
    
    
      <category term="树" scheme="http://benym.cn/tags/%E6%A0%91/"/>
    
      <category term="BFS" scheme="http://benym.cn/tags/BFS/"/>
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-94-二叉树的中序遍历</title>
    <link href="http://benym.cn/2020/05/13/LeetCode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://benym.cn/2020/05/13/LeetCode-94-二叉树的中序遍历/</id>
    <published>2020-05-13T03:01:06.000Z</published>
    <updated>2020-05-18T03:02:07.030Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-94-二叉树的中序遍历"><a href="#LeetCode-94-二叉树的中序遍历" class="headerlink" title="LeetCode-94-二叉树的中序遍历"></a>LeetCode-94-二叉树的中序遍历</h2><p>给定一个二叉树，返回它的<em>中序</em> 遍历。</p><p>相关链接：</p><ol><li><a href="/2020/05/13/LeetCode-144-二叉树的前序遍历/" title="LeetCode-144-二叉树的前序遍历">LeetCode-144-二叉树的前序遍历</a></li><li><a href="/2020/05/13/LeetCode-145-二叉树的后序遍历/" title="LeetCode-145-二叉树的后序遍历">LeetCode-145-二叉树的后序遍历</a></li></ol><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">输出: [1,3,2]</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>二叉树的遍历问题都有2种解法，一种是递归，一种是迭代</p><p>递归：开启左子树递归，添加根节点，开启右子树递归</p><p>迭代：中序遍历一般等同于DFS，用Stack来实现，后进先出。迭代是先把左子树全部添加进Stack中，然后弹出一个尾部，获得对应的val之后遍历右子树，在添加左子树的时候同时也添加了根节点，所以pop弹出时再添加val实际上会对左子树和左子树的根节点进行操作</p><h3 id="Java代码-递归"><a href="#Java代码-递归" class="headerlink" title="Java代码(递归)"></a>Java代码(递归)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        DFS(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        DFS(root.left);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        DFS(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java代码-迭代"><a href="#Java代码-迭代" class="headerlink" title="Java代码(迭代)"></a>Java代码(迭代)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span>||!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            res.add(node.val);</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      二叉树的中序遍历
    
    </summary>
    
      <category term="树" scheme="http://benym.cn/categories/%E6%A0%91/"/>
    
    
      <category term="树" scheme="http://benym.cn/tags/%E6%A0%91/"/>
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="DFS" scheme="http://benym.cn/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-面试题54-二叉搜索树的第k大节点</title>
    <link href="http://benym.cn/2020/05/12/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9854-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/"/>
    <id>http://benym.cn/2020/05/12/LeetCode-面试题54-二叉搜索树的第k大节点/</id>
    <published>2020-05-12T08:34:23.000Z</published>
    <updated>2020-05-18T03:02:07.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-面试题54-二叉搜索树的第k大节点"><a href="#LeetCode-面试题54-二叉搜索树的第k大节点" class="headerlink" title="LeetCode-面试题54-二叉搜索树的第k大节点"></a>LeetCode-面试题54-二叉搜索树的第k大节点</h2><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p> <a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,1,4,null,2], k = 1</span><br><span class="line">   3</span><br><span class="line">  / \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [5,3,6,2,4,null,null,1], k = 3</span><br><span class="line">       5</span><br><span class="line">      / \</span><br><span class="line">     3   6</span><br><span class="line">    / \</span><br><span class="line">   2   4</span><br><span class="line">  /</span><br><span class="line"> 1</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><ul><li><p><strong>限制：</strong></p><p><code>1 ≤ k ≤ 二叉搜索树元素个数</code></p></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>方法1、中序遍历的倒序：</p><p>对于二叉搜索树，左节点总是比根节点小，右节点总是比根节点大</p><p>观察可以得知，中序遍历后得到的序列是递增的，求第K个大的节点可以转化为求中序遍历的倒序的第k个节点</p><p>中序遍历序列一般可以用DFS得到</p><p>对此可以先遍历右子节点，每遍历一个右子节点，计数器加1，之后遍历左子节点</p><p>当计数器等于k时，返回对应节点的值</p><p>方法2、栈式迭代：</p><p>对于DFS和BFS问题，都可以利用一个栈来进行迭代计算，这里依旧采用倒序，先把所有的右子节点加入到stack中</p><p>之后弹出栈顶元素，如果k==n，则返回当前节点值，否则，node=node.left，按照右中左的顺序遍历</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>||k==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        DFS(root,k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(TreeNode root,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        DFS(root.right,k);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count==k)&#123;</span><br><span class="line">            res = root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        DFS(root.left,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthLargest</span><span class="params">(self, root: TreeNode, k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        stack = []</span><br><span class="line">        node = root</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> node:</span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                stack.append(node)</span><br><span class="line">                node = node.right</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> node.val</span><br><span class="line">            node = node.left</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      二叉搜索树的第k大节点
    
    </summary>
    
      <category term="剑指Offer" scheme="http://benym.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="树" scheme="http://benym.cn/tags/%E6%A0%91/"/>
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Python" scheme="http://benym.cn/tags/Python/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="DFS" scheme="http://benym.cn/tags/DFS/"/>
    
      <category term="剑指Offer" scheme="http://benym.cn/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-面试题53-2-0到n-1中缺失的数字</title>
    <link href="http://benym.cn/2020/05/12/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9853-2-0%E5%88%B0n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://benym.cn/2020/05/12/LeetCode-面试题53-2-0到n-1中缺失的数字/</id>
    <published>2020-05-12T08:10:46.000Z</published>
    <updated>2020-05-18T03:02:07.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-面试题53-2-0到n-1中缺失的数字"><a href="#LeetCode-面试题53-2-0到n-1中缺失的数字" class="headerlink" title="LeetCode-面试题53-2-0到n-1中缺失的数字"></a>LeetCode-面试题53-2-0到n-1中缺失的数字</h2><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p> <a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,3]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,2,3,4,5,6,7,9]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure><ul><li><p><strong>限制：</strong></p><p><code>1 &lt;= 数组长度 &lt;= 10000</code></p></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>二分查找：</p><p>递增且数字范围在0~n-1的数组，数字和它对应的下标一定是相等的，缺失的数子会造成，该数字之后的数组下标在原本相等的情况下+1</p><p>可以利用二分查找，在当前位置数字不等于index的时候，考虑特殊情况2种</p><ul><li>当前位置==0</li><li>当前位置的前一个位置nums[mid-1]==mid-1，即前一个数字不缺失</li></ul><p>这两种情况说明该位置就是缺失数字的位置，直接返回mid</p><p>如果不符合特殊情况，则需要在mid左半边查找，end=mid-1</p><p>如果该位置和下标相等，则表示mid左边不存在缺失，需要在右半边查找，start=mid+1</p><p>如果找完了前面所有的都没有发现缺失的数字，说明缺失数字在数组末尾，此时start=mid+1=nums.length，缺失的数字即是num.length</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;=end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (start+end)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]!=mid)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mid==<span class="number">0</span>||nums[mid-<span class="number">1</span>]==mid-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">                &#125;</span><br><span class="line">                end = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                start = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(start==nums.length)</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        <span class="comment">// 无效输入，比如数组不是排序的</span></span><br><span class="line">        <span class="comment">// 或者有数字不在0-n-1范围内</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      0到n-1中缺失的数字
    
    </summary>
    
      <category term="剑指Offer" scheme="http://benym.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="剑指Offer" scheme="http://benym.cn/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-面试题53-1-在排序数组中查找数字I</title>
    <link href="http://benym.cn/2020/05/12/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9853-1-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97I/"/>
    <id>http://benym.cn/2020/05/12/LeetCode-面试题53-1-在排序数组中查找数字I/</id>
    <published>2020-05-12T06:24:43.000Z</published>
    <updated>2020-05-18T03:02:07.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-面试题53-1-在排序数组中查找数字I"><a href="#LeetCode-面试题53-1-在排序数组中查找数字I" class="headerlink" title="LeetCode-面试题53-1-在排序数组中查找数字I"></a>LeetCode-面试题53-1-在排序数组中查找数字I</h2><p>统计一个数字在排序数组中出现的次数。</p> <a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><ul><li><p><strong>限制：</strong></p><p><code>0 &lt;= 数组长度 &lt;= 50000</code></p></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>在有序的数组中二分查找，确定第一个k出现的位置和最后一个k出现的位置，然后两个位置相减即是出现次数</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums!=<span class="keyword">null</span>&amp;&amp;len&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> first = GetFristK(nums,len,target,<span class="number">0</span>,len-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> last = GetLastK(nums,len,target,<span class="number">0</span>,len-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(first&gt;-<span class="number">1</span>&amp;&amp;last&gt;-<span class="number">1</span>)&#123;</span><br><span class="line">                count = last-first+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetFristK</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> len,<span class="keyword">int</span> target,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;end)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (start+end)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> midData = nums[mid];</span><br><span class="line">        <span class="keyword">if</span>(midData==target)&#123;</span><br><span class="line">            <span class="comment">// 找到第一个k的位置</span></span><br><span class="line">            <span class="keyword">if</span>(mid&gt;<span class="number">0</span>&amp;&amp;nums[mid-<span class="number">1</span>]!=target||mid==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 如果前面还有k，缩小范围继续找</span></span><br><span class="line">                end = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(midData&gt;target)</span><br><span class="line">            end = mid-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            start = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> GetFristK(nums,len,target,start,end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetLastK</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> len,<span class="keyword">int</span> target,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;end)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (start+end)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> midData = nums[mid];</span><br><span class="line">        <span class="keyword">if</span>(midData==target)&#123;</span><br><span class="line">            <span class="comment">// 找到最后一个k的位置</span></span><br><span class="line">            <span class="keyword">if</span>(mid&lt;len-<span class="number">1</span>&amp;&amp;nums[mid+<span class="number">1</span>]!=target||mid==len-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                start = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(midData&lt;target)</span><br><span class="line">            start = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            end = mid-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> GetLastK(nums,len,target,start,end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      在排序数组中查找数字I
    
    </summary>
    
      <category term="剑指Offer" scheme="http://benym.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="剑指Offer" scheme="http://benym.cn/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-面试题52-两个链表的第一个公共节点</title>
    <link href="http://benym.cn/2020/05/12/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9852-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9%20-%20%E5%89%AF%E6%9C%AC/"/>
    <id>http://benym.cn/2020/05/12/LeetCode-面试题52-两个链表的第一个公共节点 - 副本/</id>
    <published>2020-05-12T04:55:26.000Z</published>
    <updated>2020-05-18T03:02:07.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-面试题52-两个链表的第一个公共节点"><a href="#LeetCode-面试题52-两个链表的第一个公共节点" class="headerlink" title="LeetCode-面试题52-两个链表的第一个公共节点"></a>LeetCode-面试题52-两个链表的第一个公共节点</h2><p>输入两个链表，找出它们的第一个公共节点。</p> <a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Reference of the node with value = 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><br><span class="line">输出：Reference of the node with value = 2</span><br><span class="line">输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class="line">输出：null</span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 null。</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>如果两个链表没有交点，返回 null.</li><li>在返回结果后，两个链表仍须保持原有的结构。</li><li>可假定整个链表结构中没有循环。</li><li>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>方法1、双指针+先遍历：</p><p>因为链表一长一短，所以先让长的一方走到和短的一方开始的位置，然后用双指针同时进行遍历，出现第一个相同的节点时就返回对应指针</p><p>方法2、双指针+重置：</p><p>同样是双指针，因为一长一短的关系，有一个指针会先到达末尾，当第一个指针pA先到末尾时，将他重置到链表B的开始位置，当第二个指针pB到达末尾时，将他重置到链表A开始的位置。由于有一个先到达先重置，在等待第二个指针走到末尾的过程中，先达到的指针pA将会走这段A比B多出的长度。这样当第二个指针重置时，两个指针都在一个位置开始，之后遍历到相同的节点返回即可</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lenA = getTreelen(headA);</span><br><span class="line">        <span class="keyword">int</span> lenB = getTreelen(headB);</span><br><span class="line">        <span class="keyword">int</span> firstStep = Math.abs(lenA-lenB);</span><br><span class="line">        ListNode pLong = headA;</span><br><span class="line">        ListNode pShort = headB;</span><br><span class="line">        <span class="keyword">if</span>(lenA&lt;lenB)&#123;</span><br><span class="line">            pLong = headB;</span><br><span class="line">            pShort = headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 长的先走几步</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;firstStep;i++)&#123;</span><br><span class="line">            pLong = pLong.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pLong!=<span class="keyword">null</span>&amp;&amp;pShort!=<span class="keyword">null</span>&amp;&amp;pLong!=pShort)&#123;</span><br><span class="line">            pLong = pLong.next;</span><br><span class="line">            pShort = pShort.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pLong;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTreelen</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lenTree = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            lenTree++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lenTree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA: ListNode, headB: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        node1, node2 = headA, headB</span><br><span class="line">        <span class="keyword">while</span> node1 != node2:</span><br><span class="line">            node1 = node1.next <span class="keyword">if</span> node1 <span class="keyword">else</span> headB</span><br><span class="line">            node2 = node2.next <span class="keyword">if</span> node2 <span class="keyword">else</span> headA</span><br><span class="line">        <span class="keyword">return</span> node1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      两个链表的第一个公共节点
    
    </summary>
    
      <category term="剑指Offer" scheme="http://benym.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Python" scheme="http://benym.cn/tags/Python/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="链表" scheme="http://benym.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="剑指Offer" scheme="http://benym.cn/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-面试题51-数组中的逆序对</title>
    <link href="http://benym.cn/2020/05/09/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9851-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    <id>http://benym.cn/2020/05/09/LeetCode-面试题51-数组中的逆序对/</id>
    <published>2020-05-09T10:33:02.000Z</published>
    <updated>2020-05-18T03:02:07.060Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-面试题51-数组中的逆序对"><a href="#LeetCode-面试题51-数组中的逆序对" class="headerlink" title="LeetCode-面试题51-数组中的逆序对"></a>LeetCode-面试题51-数组中的逆序对</h2><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p> <a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,5,6,4]</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>0 &lt;= 数组长度 &lt;= 50000</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>方法1、暴力破解(超时)：</p><p>两个指针循环判断后面的数是不是小于前面的数，是就+1，但这样超时了。算一个没办法的解法吧</p><p>方法2、归并排序：</p><p>基本上代码就是归并排序的思想，但递归的终止条件有了变化，因为分裂区间需要判断是否有逆序数的关系</p><p>当区间的left==right的时候，说明这个区间只有一个数字了，一个数字不能组成逆序数，因此这个区间的逆序数为0</p><p>在跨区间逆序数计算时，如果左边区间比较小就需要先把左边区间的数放入temp数组中，这个时候代表左边的数比又边的数小，<strong>但此时不是逆序的关系，不需要统计逆序对</strong>；只有当右边区间比左边区间小的时候，需要统计逆序对个数，此时的逆序对个数为，左边区间还剩下的数的个数即<code>mid-left+1</code></p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            copy[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">return</span> MergeSort(copy, <span class="number">0</span>, len - <span class="number">1</span>, temp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当这个区间只剩一个元素时，这个子区间就不存在逆序数，返回0</span></span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// int mid = (left+right)/2;</span></span><br><span class="line">        <span class="comment">// 防止int溢出</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> leftPairs = MergeSort(nums, left, mid, temp);</span><br><span class="line">        <span class="keyword">int</span> rightPairs = MergeSort(nums, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">        <span class="comment">// 如果分出来的数组本身有序，则返回左边+右边</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> leftPairs + rightPairs;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> crossPairs = mergeAndCount(nums, left, mid, right, temp);</span><br><span class="line">        <span class="keyword">return</span> leftPairs + rightPairs + crossPairs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">mergeAndCount</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;=right; i++) &#123;</span><br><span class="line">            temp[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = left; k &lt;= right; k++) &#123;</span><br><span class="line">            <span class="comment">// 如果左边数组遍历完了，就直接把右边拷贝回去</span></span><br><span class="line">            <span class="keyword">if</span> (i == mid + <span class="number">1</span>) &#123;</span><br><span class="line">                nums[k] = temp[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == right + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果右边数组遍历完了，就直接把左边拷贝回去</span></span><br><span class="line">                nums[k] = temp[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp[i] &lt;= temp[j]) &#123;</span><br><span class="line">                nums[k] = temp[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[k] = temp[j];</span><br><span class="line">                j++;</span><br><span class="line">                count += (mid - i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><p>暴力破解失败…..</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePairs</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        i,j,count = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&lt;nums[i]):</span><br><span class="line">                    count+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      数组中的逆序对
    
    </summary>
    
      <category term="剑指Offer" scheme="http://benym.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Python" scheme="http://benym.cn/tags/Python/"/>
    
      <category term="Hard" scheme="http://benym.cn/tags/Hard/"/>
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="剑指Offer" scheme="http://benym.cn/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="分治" scheme="http://benym.cn/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-归并排序</title>
    <link href="http://benym.cn/2020/05/09/LeetCode-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://benym.cn/2020/05/09/LeetCode-归并排序/</id>
    <published>2020-05-09T10:16:01.000Z</published>
    <updated>2020-05-18T03:02:07.030Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-归并排序"><a href="#LeetCode-归并排序" class="headerlink" title="LeetCode-归并排序"></a>LeetCode-归并排序</h2><p>归并排序算法回顾</p> <a id="more"></a><p><strong>示例1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [4,0,1,2,0,5]</span><br><span class="line">输出: [0,0,1,2,4,5]</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>归并排序算法采用分治的思想</p><p>把原本的数组不断进行二分，直到分为数组元素是单个的时候，之后开始排序合并</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">// 创建临时数组避免重复开辟空间</span></span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        MergerSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, temp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : arr)&#123;</span><br><span class="line">            System.out.print(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergerSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            MergerSort(arr, left, mid, temp); <span class="comment">// 左边归并排序，使得左子序列有序</span></span><br><span class="line">            MergerSort(arr, mid + <span class="number">1</span>, right, temp); <span class="comment">// 右边归并排序，使得右子序列有序</span></span><br><span class="line">            Merge(arr, left, mid, right, temp); <span class="comment">// 将两个有序子数组合并</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = left; <span class="comment">// 左序列指针</span></span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>; <span class="comment">// 右序列指针</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>; <span class="comment">// 临时数组指针</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">                temp[t++] = arr[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[t++] = arr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将左边剩余元素填充进temp中</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            temp[t++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将右边剩余元素填充进temp中</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">            temp[t++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 拷贝回原数组</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            arr[left++] = temp[t++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      归并排序
    
    </summary>
    
      <category term="算法" scheme="http://benym.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="排序算法" scheme="http://benym.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-面试题50-第一次只出现一次的字符</title>
    <link href="http://benym.cn/2020/05/08/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9850-%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
    <id>http://benym.cn/2020/05/08/LeetCode-面试题50-第一次只出现一次的字符/</id>
    <published>2020-05-08T11:23:20.000Z</published>
    <updated>2020-05-18T03:02:07.060Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-面试题50-第一次只出现一次的字符"><a href="#LeetCode-面试题50-第一次只出现一次的字符" class="headerlink" title="LeetCode-面试题50-第一次只出现一次的字符"></a>LeetCode-面试题50-第一次只出现一次的字符</h2><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。</p> <a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;abaccdeff&quot;</span><br><span class="line">返回 &quot;b&quot;</span><br><span class="line"></span><br><span class="line">s = &quot;&quot; </span><br><span class="line">返回 &quot; &quot;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>0 &lt;= s 的长度 &lt;= 50000</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>哈希表：</p><p>每出现一次字符就把字符放入hash表中，如果有重复的就把对应位置+1</p><p>遍历的时候由于hash表重新put改变了原本的先后顺序(Java的hashmap不能原地改变，Python的dict可以原地改变)，所以需要按照字符顺序遍历，当第1次value为1的时候，就返回该字符</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">' '</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; maps = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : chars) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!maps.containsKey(c)) &#123;</span><br><span class="line">                maps.put(c, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maps.put(c, maps.get(c) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : chars) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maps.get(c) == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python代码1"><a href="#Python代码1" class="headerlink" title="Python代码1"></a>Python代码1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstUniqChar</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> len(s)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">' '</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                d[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d[i]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> d.items():</span><br><span class="line">            <span class="keyword">if</span> v==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> k</span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      第一次只出现一次的字符
    
    </summary>
    
      <category term="剑指Offer" scheme="http://benym.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Python" scheme="http://benym.cn/tags/Python/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="剑指Offer" scheme="http://benym.cn/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
</feed>
