<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ming.Y</title>
  
  <subtitle>Chances are for people who are prepared</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://benym.cn/"/>
  <updated>2020-06-11T12:48:25.499Z</updated>
  <id>http://benym.cn/</id>
  
  <author>
    <name>BenY</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode-107-二叉树的层次遍历2</title>
    <link href="http://benym.cn/2020/06/11/LeetCode-107-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%862/"/>
    <id>http://benym.cn/2020/06/11/LeetCode-107-二叉树的层次遍历2/</id>
    <published>2020-06-11T12:19:38.000Z</published>
    <updated>2020-06-11T12:48:25.499Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-107-二叉树的层次遍历2"><a href="#LeetCode-107-二叉树的层次遍历2" class="headerlink" title="LeetCode-107-二叉树的层次遍历2"></a>LeetCode-107-二叉树的层次遍历2</h2><p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><a id="more"></a><p><strong>示例 1:</strong></p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回其自底向上的层次遍历为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>BFS层序遍历+头插法：</strong></p><p>涉及到要加入数值的，不太好用递归的方法，采用迭代的方法更容易一点</p><p>使用queue队列进行层序遍历，每次弹出一个层的节点就将它加入到layer中，一层遍历完了之后</p><p>再将一层的结果加入到res的头部，最后返回回来的就是按层倒序的结果</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            List&lt;Integer&gt; layer = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                TreeNode temp = queue.poll();</span><br><span class="line">                layer.add(temp.val);</span><br><span class="line">                <span class="keyword">if</span>(temp.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(temp.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(temp.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(<span class="number">0</span>,layer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      二叉树的层次遍历2
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="树" scheme="http://benym.cn/tags/%E6%A0%91/"/>
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="BFS" scheme="http://benym.cn/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-104-二叉树的最大深度</title>
    <link href="http://benym.cn/2020/06/11/LeetCode-104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    <id>http://benym.cn/2020/06/11/LeetCode-104-二叉树的最大深度/</id>
    <published>2020-06-11T11:38:36.000Z</published>
    <updated>2020-06-11T12:18:28.746Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-104-二叉树的最大深度"><a href="#LeetCode-104-二叉树的最大深度" class="headerlink" title="LeetCode-104-二叉树的最大深度"></a>LeetCode-104-二叉树的最大深度</h2><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><a id="more"></a><p><strong>示例 1:</strong></p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>方法1、DFS递归：</strong></p><p>特例：root为空直接返回0</p><p>DFS左子树深度，DFS右子树深度，树的深度=Max(左子树，右子树)+root节点</p><p><strong>方法2、Queue迭代：</strong></p><p>利用层序遍历的思想，一层一层遍历，每过一层深度+1</p><p>利用一个先进先出的Queue队列，先将root节点加入其中，当queue不为空的时候开始遍历</p><p>深度+1，弹出队列头部，判断头部的左右节点是否为空，不为空则加入其中</p><p>对于一层的节点，节点数为queue.size()，对于queue中的每个节点都需要进行左右节点的判断</p><p>当一层遍历完毕时，深度就+1</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = maxDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java代码2-迭代Queue"><a href="#Java代码2-迭代Queue" class="headerlink" title="Java代码2(迭代Queue)"></a>Java代码2(迭代Queue)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">int</span> depth=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                TreeNode temp = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(temp.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(temp.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(temp.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      二叉树的最大深度
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="树" scheme="http://benym.cn/tags/%E6%A0%91/"/>
    
      <category term="DFS" scheme="http://benym.cn/tags/DFS/"/>
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-1367-二叉树中的列表</title>
    <link href="http://benym.cn/2020/06/11/LeetCode-1367-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8/"/>
    <id>http://benym.cn/2020/06/11/LeetCode-1367-二叉树中的列表/</id>
    <published>2020-06-11T08:38:13.000Z</published>
    <updated>2020-06-11T11:35:38.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-1367-二叉树中的列表"><a href="#LeetCode-1367-二叉树中的列表" class="headerlink" title="LeetCode-1367-二叉树中的列表"></a>LeetCode-1367-二叉树中的列表</h2><p>给你一棵以 root 为根的二叉树和一个 head 为第一个节点的链表。</p><p>如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以 head 为首的链表中每个节点的值，那么请你返回 True ，否则返回 False 。</p><p>一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]</span><br><span class="line">输出：true</span><br><span class="line">解释：树中蓝色的节点构成了与链表对应的子路径。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p> <strong>示例3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]</span><br><span class="line">输出：false</span><br><span class="line">解释：二叉树中不存在一一对应链表的路径。</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li>二叉树和链表中的每个节点的值都满足 1 &lt;= node.val &lt;= 100 。</li><li>链表包含的节点数目在 1 到 100 之间。</li><li>二叉树包含的节点数目在 1 到 2500 之间。</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>DFS递归：</strong></p><p>根据题意知道，head的长度&lt;=root</p><p>我们可以设计一个递归函数，如果head==null说明匹配完成，返回true，如果root==null则说明找完了也没有匹配上</p><p>首先开启root节点的递归，判断开始的路径是否和head匹配，如果匹配则进一步看是这个节点的左子树匹配？还是这个节点的右子树匹配。任意一个子树匹配成功则算匹配成功。</p><p>如果root节点匹配失败，那么需要看root节点的左子树或者root节点的右子树是否能够匹配，分别开启DFS遍历，左右子树应该和root节点进行一样的匹配，同样需要看左子节点的左右节点和右子节点的左右节点到底是哪一个匹配的</p><p>当根节点或者左右子树任意一个匹配成功，则说明包含路径，即<code>dfs(head,root)||isSubPath(head,root.left)||isSubPath(head,root.right)</code></p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubPath</span><span class="params">(ListNode head, TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 先判断当前的节点，如果不对，就看看左子树和右子树</span></span><br><span class="line">        <span class="keyword">return</span> dfs(head,root)||isSubPath(head,root.left)||isSubPath(head,root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(ListNode head,TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 如果链表没了，那就说明匹配完了</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 如果链表没完，树走完了，那就是没匹配上</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 如果值不同，那肯定也是没匹配上</span></span><br><span class="line">        <span class="keyword">if</span>(head.val!=root.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 如果值相同，就继续看看左边右边是不是有相同的</span></span><br><span class="line">        <span class="keyword">return</span> dfs(head.next,root.left)||dfs(head.next,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      二叉树中的列表
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="树" scheme="http://benym.cn/tags/%E6%A0%91/"/>
    
      <category term="DFS" scheme="http://benym.cn/tags/DFS/"/>
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-143-重排链表</title>
    <link href="http://benym.cn/2020/06/10/LeetCode-143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/"/>
    <id>http://benym.cn/2020/06/10/LeetCode-143-重排链表/</id>
    <published>2020-06-10T12:33:33.000Z</published>
    <updated>2020-06-11T08:28:34.995Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-143-重排链表"><a href="#LeetCode-143-重排链表" class="headerlink" title="LeetCode-143-重排链表"></a>LeetCode-143-重排链表</h2><p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，<br>将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p> <a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>方法1、存储+双指针：</strong></p><p>用一个线性表存储所有的链表元素，之后用2个指针，分别获得链表的头尾</p><p>按照规律对于1，2，3，4这样的链表例子</p><p>1之后是4，4之后是2，2之后是3</p><p>初始化头尾指针，改变头部指针的指向到尾部，并使i指向下一位</p><p>即<code>list.get(i).next = list.get(j);</code>和<code>i++</code></p><p>改变尾部指针指向到原本头部的下一位，由于上面已经<code>i++</code>，此时线性表的i就是上一次i的下一位</p><p>所以<code>list.get(j).next = list.get(i);</code>，之后<code>j--</code></p><p>直到i==j时跳出循环，此时i仍然与原来的链表相连，将i.next=null完成链表构建</p><p><strong>方法2、拆分+翻转+拼接：</strong></p><p>这个解法复习的内容挺多的，按照题目规律，重排链表可以分为如下3个步骤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6</span><br><span class="line">第一步，将链表平均分成两半</span><br><span class="line">1 -&gt; 2 -&gt; 3</span><br><span class="line">4 -&gt; 5 -&gt; 6</span><br><span class="line">    </span><br><span class="line">第二步，将第二个链表逆序</span><br><span class="line">1 -&gt; 2 -&gt; 3</span><br><span class="line">6 -&gt; 5 -&gt; 4</span><br><span class="line">    </span><br><span class="line">第三步，依次连接两个链表</span><br><span class="line">1 -&gt; 6 -&gt; 2 -&gt; 5 -&gt; 3 -&gt; 4</span><br></pre></td></tr></table></figure><p>如何拆分链表，最重要的是找到拆分的中点</p><p>对于偶数链表，拆分的中点在边界左边，对于奇数链表，中点就是中间的那个</p><p>可以利用<strong>快慢指针</strong>来寻找中点，一个指针走2步，一个指针走1步，当快指针走到链表尾部的时候，慢指针的位置就是拆分的中点，由于奇数和偶数拆分点不一样，所以<code>ListNode newHead = slow.next;</code>和<code>slow.next = null;</code>在找到边界点之后，始终后移1位，这样保证了偶数情况下，拆分点始终是第二个链表的头部</p><p>但是对于奇数情况，则会让第一个链表始终比第二个链表多一个数字，这种情况在合并的时候进行处理。</p><p>链表的逆序思想和<a href="/2020/04/19/LeetCode-面试题24-反转链表/" title="LeetCode-面试题24-反转链表">LeetCode-面试题24-反转链表</a>相同</p><p>链表的合并思想和<a href="/2020/04/19/LeetCode-面试题25-合并两个排序的链表/" title="LeetCode-面试题25-合并两个排序的链表">LeetCode-面试题25-合并两个排序的链表</a>大致相同</p><p>稍微有点区别的地方是这里不是按照值进行合并</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">对于</span><br><span class="line">slow  1 -&gt; 2 -&gt; 3</span><br><span class="line">fast  4 -&gt; 5</span><br><span class="line">而言，应该先存储slow和fast的next节点</span><br><span class="line">之后将slow的next变为fast，即1 -&gt; 4</span><br><span class="line">fast的next = 刚才存储的slow.next，即4 -&gt; 2</span><br><span class="line">接下来移动1位slow和fast指针，即slow = 刚才存储的slow.next，fast = 刚才存储的fast.next</span><br></pre></td></tr></table></figure><p>而此时的第一个链表由于始终比第二个链表长，所以判断空的条件为<code>slow!=null&amp;&amp;fast!=null</code>，当满足此条件时，才会进行V字型拼接</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存到 list 中去</span></span><br><span class="line">        List&lt;ListNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            list.add(head);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//头尾指针依次取元素</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = list.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            list.get(i).next = list.get(j);</span><br><span class="line">            i++;</span><br><span class="line">            <span class="comment">//偶数个节点的情况，会提前相遇</span></span><br><span class="line">            <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            list.get(j).next = list.get(i);</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        list.get(i).next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java代码2"><a href="#Java代码2" class="headerlink" title="Java代码2"></a>Java代码2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>&amp;&amp;fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode newHead = slow.next;</span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line">        fast = reversList(newHead);</span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span>(slow!=<span class="keyword">null</span>&amp;&amp;fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode stemp = slow.next;</span><br><span class="line">            ListNode ftemp = fast.next;</span><br><span class="line">            slow.next = fast;</span><br><span class="line">            fast.next = stemp;</span><br><span class="line">            slow = stemp;</span><br><span class="line">            fast = ftemp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reversList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode temp = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      重排链表
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://benym.cn/tags/LeetCode/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="链表" scheme="http://benym.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-142-环形链表2</title>
    <link href="http://benym.cn/2020/06/10/LeetCode-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A82/"/>
    <id>http://benym.cn/2020/06/10/LeetCode-142-环形链表2/</id>
    <published>2020-06-10T08:43:09.000Z</published>
    <updated>2020-06-10T09:20:03.125Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-142-环形链表2"><a href="#LeetCode-142-环形链表2" class="headerlink" title="LeetCode-142-环形链表2"></a>LeetCode-142-环形链表2</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p>说明：不允许修改给定的链表。</p> <a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：tail connects to node index 1</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：tail connects to node index 0</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：no cycle</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p><strong>进阶：</strong><br>你是否可以不用额外空间解决此题？</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>相关链接：</strong></p><ul><li><a href="/2020/06/10/LeetCode-141-环形链表/" title="LeetCode-141-环形链表">LeetCode-141-环形链表</a></li><li><a href="/2020/06/10/LeetCode-面试题02.02-返回倒数第k个节点/" title="LeetCode-面试题02.02-返回倒数第k个节点">LeetCode-面试题02.02-返回倒数第k个节点</a></li></ul><p><strong>快慢指针+双指针：</strong></p><p>想要在环形链表中找到入环的第一个节点，首先要判断是否有环</p><p>在有环的前提下，如果能够计算出环内的节点有多少个，那么问题就变为同返回倒数第k个节点相似的问题</p><p>让其中一个指针先走n步，之后一个指针第一个指针走完n步之后开始走</p><p>两个指针继续移动1步，当第二个指针指向环的入口节点时，第一个指针已经绕了一圈回来到达了入口节点，此时第二个指针的位置就是入口</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode meetingNode = hasCycle(head);</span><br><span class="line">        <span class="keyword">if</span>(meetingNode==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">        ListNode temp = meetingNode;</span><br><span class="line">        <span class="keyword">while</span>(temp.next!=meetingNode)&#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode start = head;</span><br><span class="line">        temp = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(temp!=start)&#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            start = start.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode slow = head.next;</span><br><span class="line">        <span class="keyword">if</span>(slow==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode fast = slow.next;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>&amp;&amp;slow!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast==slow) <span class="keyword">return</span> fast;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            <span class="keyword">if</span>(fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      环形链表2
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://benym.cn/tags/LeetCode/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="链表" scheme="http://benym.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-141-环形链表</title>
    <link href="http://benym.cn/2020/06/10/LeetCode-141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
    <id>http://benym.cn/2020/06/10/LeetCode-141-环形链表/</id>
    <published>2020-06-10T08:16:00.000Z</published>
    <updated>2020-06-10T08:39:28.579Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-141-环形链表"><a href="#LeetCode-141-环形链表" class="headerlink" title="LeetCode-141-环形链表"></a>LeetCode-141-环形链表</h2><p>给定一个链表，判断链表中是否有环。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p> <a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p><strong>进阶：</strong></p><p>你能用 <em>O(1)</em>（即，常量）内存解决此问题吗？</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>快慢指针：</strong></p><p>要找到一个链表有没有环，可以通过设置快慢指针的方式</p><p>如果快的指针赶上了慢的指针说明链表中有环，如果不存在环那么其中一个指针必定会等于null</p><p>初始化慢指针slow=head.next，如果他等于null说明链表只有一个节点，不存在环，返回false</p><p>初始化快指针fast=slow.next，当快慢指针都不为空的时候，判断是否相等，相等则有环</p><p>如果不相等，则移动慢指针1步，移动快指针2步，但快指针移动一步之后需要判断是否为null，不为null才能移动第二步，否则没有环，跳出循环返回false</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        ListNode slow = head.next;</span><br><span class="line">        <span class="keyword">if</span>(slow==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        ListNode fast = slow.next;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>&amp;&amp;slow!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast==slow) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            <span class="keyword">if</span>(fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      环形链表
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="LeetCode" scheme="http://benym.cn/tags/LeetCode/"/>
    
      <category term="链表" scheme="http://benym.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-面试题02.02-返回倒数第k个节点</title>
    <link href="http://benym.cn/2020/06/10/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9802.02-%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>http://benym.cn/2020/06/10/LeetCode-面试题02.02-返回倒数第k个节点/</id>
    <published>2020-06-10T07:28:54.000Z</published>
    <updated>2020-06-10T07:58:20.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-面试题02-02-返回倒数第k个节点"><a href="#LeetCode-面试题02-02-返回倒数第k个节点" class="headerlink" title="LeetCode-面试题02.02-返回倒数第k个节点"></a>LeetCode-面试题02.02-返回倒数第k个节点</h2><p>实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。</p><p><strong>注意：</strong>本题相对原题稍作改动</p> <a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： 1-&gt;2-&gt;3-&gt;4-&gt;5 和 k = 2</span><br><span class="line">输出： 4</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>给定的 <em>k</em> 保证是有效的。</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>双指针：</strong></p><p>根据链表的性质，要获得倒数第k个节点，就等于求n-(k-1)个节点，</p><p>但这需要知道链表的长度，意味着需要两次遍历链表。</p><p>换一种想法，想要知道倒数第k个节点，那么就让一个指针先走k-1步，另外一个指针始终和第一个指针保持k-1的距离</p><p>当第一个指针到达链表结尾时，第二个指针则正好在n-(k-1)的位置，只需要一次遍历即可完成</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthToLast</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode low = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        low = head;</span><br><span class="line">        <span class="keyword">while</span>(fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            low = low.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      返回倒数第k个节点
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="LeetCode" scheme="http://benym.cn/tags/LeetCode/"/>
    
      <category term="链表" scheme="http://benym.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-328-奇偶链表</title>
    <link href="http://benym.cn/2020/06/10/LeetCode-328-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/"/>
    <id>http://benym.cn/2020/06/10/LeetCode-328-奇偶链表/</id>
    <published>2020-06-10T07:14:20.000Z</published>
    <updated>2020-06-10T07:26:40.630Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-328-奇偶链表"><a href="#LeetCode-328-奇偶链表" class="headerlink" title="LeetCode-328-奇偶链表"></a>LeetCode-328-奇偶链表</h2><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p><p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p> <a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL </span><br><span class="line">输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>应当保持奇数节点和偶数节点的相对顺序。</li><li>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>双指针：</strong></p><p>一个指针指向奇数节点，一个指针指向偶数节点</p><p>间隔遍历，奇数指针只能指向奇数节点，偶数指针只能指向偶数节点</p><p>对于链表长度为奇数时，奇数指针one能够指向之后一个数字，此时偶数指针two==null，作为循环结束条件</p><p>对于链表长度为偶数时，奇数指针one会在之前遍历完毕奇数位置，此时偶数指针two.next==null，作为循环结束条件</p><p>最后进行奇偶链表拼接，one.next=tempTwo</p><p>注意：间隔遍历很重要，如果按照顺序遍历，会出现one和two指针在奇偶长度的指向不一样，即one和two在快到链表末尾时候，可能指向的奇数链表也可能指向的偶数链表，这样就无法进行最后指针拼接的判断了，<strong>间隔遍历保证了指针的奇偶性</strong></p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode one = head;</span><br><span class="line">        ListNode two = head.next;</span><br><span class="line">        ListNode tempTwo = two;</span><br><span class="line">        <span class="keyword">while</span>(two!=<span class="keyword">null</span>&amp;&amp;two.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            one.next = two.next;</span><br><span class="line">            one = one.next;</span><br><span class="line">            two.next = one.next;</span><br><span class="line">            two = two.next;</span><br><span class="line">        &#125;</span><br><span class="line">        one.next = tempTwo;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      奇偶链表
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://benym.cn/tags/LeetCode/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="链表" scheme="http://benym.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-300-最长上升子序列</title>
    <link href="http://benym.cn/2020/06/09/LeetCode-300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://benym.cn/2020/06/09/LeetCode-300-最长上升子序列/</id>
    <published>2020-06-09T12:02:29.000Z</published>
    <updated>2020-06-10T05:35:46.986Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-300-最长上升子序列"><a href="#LeetCode-300-最长上升子序列" class="headerlink" title="LeetCode-300-最长上升子序列"></a>LeetCode-300-最长上升子序列</h2><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p> <a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [10,9,2,5,3,7,101,18]</span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</span><br></pre></td></tr></table></figure><p>说明:</p><p>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。<br>你算法的时间复杂度应该为 O(n2) 。<br>进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>动态规划：</strong></p><p>子序列严格上升，不存在中间数字相等的情况，且不要求序列连续</p><p>状态定义为：第i个数字为结尾的最长上升子序列的长度，自身也需要统计在其中，每个位置的初始化长度为1</p><p>状态转移方程：遍历到索引是i的数字的时候，需要看i前面的i-1个数字是否小于当前的nums[i]的值，如果小于则可以构成一个更长的子序列，但i-1个数字中比nums[i]小的数字有多个，所以dp[i]位置的子序列长度，应该是前面i-1个数字的<strong>最长</strong>的那个加上1，即<code>dp[i] = Math.max(dp[j]+1,dp[i])</code></p><p>外层循环到len，控制dp[i]每个位置的初始化为1</p><p>内层循环到i，查看从数组开头到i-1个数，最长的子序列分别是多少</p><p>最后dp数组中的最大值，就是最长上升子序列的长度</p><p><strong>贪心+二分查找：</strong></p><p>实在是想不到这种解法….<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-2/" target="_blank" rel="noopener">原题题解出处</a></p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len&lt;<span class="number">2</span>) <span class="keyword">return</span> len;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            dp[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 看前面i-1个数字</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&lt;nums[i])&#123; <span class="comment">//可以构成更长的子序列，所以dp[j]+1</span></span><br><span class="line">                    dp[i] = Math.max(dp[j]+<span class="number">1</span>,dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(res&lt;dp[i]) res=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java代码2"><a href="#Java代码2" class="headerlink" title="Java代码2"></a>Java代码2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len&lt;<span class="number">2</span>) <span class="keyword">return</span> len;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> maxL = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> high = maxL;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = low+(high-low)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(dp[mid]&lt;num)&#123;</span><br><span class="line">                    low = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    high = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[low]=num;</span><br><span class="line">            <span class="keyword">if</span>(low==maxL)</span><br><span class="line">                maxL++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      最长上升子序列
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="DP" scheme="http://benym.cn/tags/DP/"/>
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="LeetCode" scheme="http://benym.cn/tags/LeetCode/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-47-全排列2</title>
    <link href="http://benym.cn/2020/06/09/LeetCode-47-%E5%85%A8%E6%8E%92%E5%88%972/"/>
    <id>http://benym.cn/2020/06/09/LeetCode-47-全排列2/</id>
    <published>2020-06-09T10:33:18.000Z</published>
    <updated>2020-06-09T11:32:13.769Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-47-全排列2"><a href="#LeetCode-47-全排列2" class="headerlink" title="LeetCode-47-全排列2"></a>LeetCode-47-全排列2</h2><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p> <a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,1,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,1,2],</span><br><span class="line">  [1,2,1],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>回溯+剪枝：</strong></p><p>基于46题<a href="/2020/06/08/LeetCode-46-全排列/" title="LeetCode-46-全排列">LeetCode-46-全排列</a></p><p>对于刚开始就有重复的数字序列，首先先对数组排序，<strong>保证数据有序</strong></p><p>之后构建递归树，因为返回的结果中不能包含重复的排列，所以在如数组1、1、2的排列过程中</p><p>选择第一个1开头和选择第二个1开头的序列将会重复，所以说需要对第二个1开头的所有序列进行剪枝</p><p>对应条件为nums[i]==num[i-1]，即第二个1等于第一个1时</p><p>同时需要考虑仅在第一个1的排列选择完毕之后回退到空path的时候，才进行第二个1的剪枝。此时判断的依据是上一个nums[i-1]刚刚在回溯的过程中被撤销选择。</p><p>对于其他可能重复的位置，如2，1，1。开头2、1都相同于是后续的排列也是重复的，上述的剪枝方法同样适用</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(nums, len, <span class="number">0</span>, path, visited, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> len,<span class="keyword">int</span> depth,List&lt;Integer&gt; path,<span class="keyword">boolean</span>[] visited,List&lt;List&lt;Integer&gt;&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len==depth)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                <span class="comment">// visited[i-1]是因为nums[i-1]在回退的过程中刚刚被撤销选择</span></span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>]&amp;&amp;visited[i-<span class="number">1</span>]==<span class="keyword">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">                visited[i] = <span class="keyword">true</span>;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                dfs(nums,len,depth+<span class="number">1</span>,path,visited,res);</span><br><span class="line">                visited[i] = <span class="keyword">false</span>;</span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      全排列2
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="LeetCode" scheme="http://benym.cn/tags/LeetCode/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="回溯" scheme="http://benym.cn/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-46-全排列</title>
    <link href="http://benym.cn/2020/06/08/LeetCode-46-%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <id>http://benym.cn/2020/06/08/LeetCode-46-全排列/</id>
    <published>2020-06-08T14:18:43.000Z</published>
    <updated>2020-06-09T10:32:14.803Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-46-全排列"><a href="#LeetCode-46-全排列" class="headerlink" title="LeetCode-46-全排列"></a>LeetCode-46-全排列</h2><p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p> <a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>方法1、回溯：</p><p>回溯问题经常会涉及到一个状态数组</p><p>基本的思路想象成一个树的问题，是从一个数字(外层循环分别固定1，2，3数字)出发，往树的更深处遍历</p><ul><li>如果当前位置没有访问过，就将这个数加入到路径中，之后开启更深一层的遍历</li><li>如果路径的长度等于了初始的数组长度，说明找到了一个可能的排列</li><li>如果走到最后没有找到这样的排列路径，则说明此路不同进行回溯操作，将访问的位置状态还原，并同时移除还原路上已经添加的数字</li></ul><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(nums,len,<span class="number">0</span>,path,visited,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> len, <span class="keyword">int</span> depth,</span></span></span><br><span class="line"><span class="function"><span class="params">                     List&lt;Integer&gt; path, <span class="keyword">boolean</span>[] visited,</span></span></span><br><span class="line"><span class="function"><span class="params">                     List&lt;List&lt;Integer&gt;&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len==depth)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                visited[i] = <span class="keyword">true</span>;</span><br><span class="line">                dfs(nums,len,depth+<span class="number">1</span>,path,visited,res);</span><br><span class="line">                visited[i] = <span class="keyword">false</span>;</span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      全排列
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="LeetCode" scheme="http://benym.cn/tags/LeetCode/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="回溯" scheme="http://benym.cn/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-51-N皇后</title>
    <link href="http://benym.cn/2020/06/08/LeetCode-51-N%E7%9A%87%E5%90%8E/"/>
    <id>http://benym.cn/2020/06/08/LeetCode-51-N皇后/</id>
    <published>2020-06-08T11:55:16.000Z</published>
    <updated>2020-06-08T13:46:46.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-51-N皇后"><a href="#LeetCode-51-N皇后" class="headerlink" title="LeetCode-51-N皇后"></a>LeetCode-51-N皇后</h2><p><em>n</em> 皇后问题研究的是如何将 <em>n</em> 个皇后放置在 <em>n</em>×<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p><p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p> <a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: [</span><br><span class="line"> [&quot;.Q..&quot;,  // 解法 1</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;..Q.&quot;],</span><br><span class="line"></span><br><span class="line"> [&quot;..Q.&quot;,  // 解法 2</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;.Q..&quot;]</span><br><span class="line">]</span><br><span class="line">解释: 4 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>皇后，是国际象棋中的棋子，意味着国王的妻子。皇后只做一件事，那就是“吃子”。当她遇见可以吃的棋子时，就迅速冲上去吃掉棋子。当然，她横、竖、斜都可走一到七步，可进可退。（引用自 百度百科 - 皇后 ）</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>回溯方法引用与<a href="https://leetcode-cn.com/problems/n-queens/solution/nhuang-hou-by-leetcode/" target="_blank" rel="noopener">LeetCode官方</a></p><p><strong>方法1、</strong>回溯：</p><p>在建立算法之前，我们来考虑两个有用的细节。</p><p>一行只可能有一个皇后且一列也只可能有一个皇后。</p><p>这意味着没有必要再棋盘上考虑所有的方格。只需要按列循环即可。</p><p>对于所有的主对角线有 <strong>行号 + 列号 = 常数</strong>，对于所有的次对角线有 <strong>行号 - 列号 = 常数</strong>.</p><p>这可以让我们标记已经在攻击范围下的对角线并且检查一个方格 (行号, 列号) 是否处在攻击位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、一行一个皇后</span><br><span class="line">2、每个皇后的左上方向没有其他皇后，每个皇后的上方没有其他皇后，每个皇后的右上方向没有皇后</span><br></pre></td></tr></table></figure><p>现在已经可以写回溯函数 backtrack(row = 0).</p><ul><li><p>从第一个 row = 0 开始.</p></li><li><p>循环列并且试图在每个 column 中放置皇后.</p><ul><li>如果方格 (row, column) 不在攻击范围内<ul><li>在 (row, column) 方格上放置皇后。</li><li>排除对应行，列和两个对角线的位置。</li><li>If 所有的行被考虑过，row == N<ul><li>意味着我们找到了一个解</li></ul></li><li>Else<ul><li>继续考虑接下来的皇后放置 backtrack(row + 1).</li></ul></li><li>回溯：将在 (row, column) 方格的皇后移除.</li></ul></li></ul></li></ul><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;String&gt;&gt; output = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于标记是否被列方向的皇后攻击</span></span><br><span class="line">    <span class="keyword">int</span>[] rows;</span><br><span class="line">    <span class="comment">// 用于标记是否被主对角线方向的皇后攻击</span></span><br><span class="line">    <span class="keyword">int</span>[] mains;</span><br><span class="line">    <span class="comment">// 用于标记是否被次对角线方向的皇后攻击</span></span><br><span class="line">    <span class="keyword">int</span>[] secondary;</span><br><span class="line">    <span class="comment">// 用于存储皇后放置的位置</span></span><br><span class="line">    <span class="keyword">int</span>[] queens;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        rows = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        mains = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>*n-<span class="number">1</span>];</span><br><span class="line">        secondary = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>*n-<span class="number">1</span>];</span><br><span class="line">        queens = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        <span class="comment">// 从第一行开始回溯求解N皇后</span></span><br><span class="line">        backtrack(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在一行中放置一个皇后</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> row)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row&gt;=n) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 分别尝试在row行中的每一列都放置一个皇后</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>;col&lt;n;col++)&#123;</span><br><span class="line">            <span class="comment">// 判断当前放置的皇后不被其他皇后攻击</span></span><br><span class="line">            <span class="keyword">if</span>(isNotUnderAttack(row,col))&#123;</span><br><span class="line">                <span class="comment">// 选择，在当前的位置上放置皇后</span></span><br><span class="line">                placeQueen(row,col);</span><br><span class="line">                <span class="comment">// 当前行是最后一行，则找到了一个解决方案</span></span><br><span class="line">                <span class="keyword">if</span>(row==n-<span class="number">1</span>) addSolution();</span><br><span class="line">                <span class="comment">// 在下一行中放置皇后</span></span><br><span class="line">                backtrack(row+<span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 回溯，将当前位置的皇后去掉</span></span><br><span class="line">                removeQueen(row,col);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断row行，col列这个位置有没有被其他方向的皇后攻击</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isNotUnderAttack</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 判断的逻辑是：</span></span><br><span class="line">        <span class="comment">//      1. 当前位置的这一列方向没有皇后攻击</span></span><br><span class="line">        <span class="comment">//      2. 当前位置的主对角线方向没有皇后攻击</span></span><br><span class="line">        <span class="comment">//      3. 当前位置的次对角线方向没有皇后攻击</span></span><br><span class="line">        <span class="keyword">int</span> res = rows[col]+mains[row-col+n-<span class="number">1</span>]+secondary[row+col];</span><br><span class="line">        <span class="comment">// 如果三个方向都没有攻击的话，则res=0</span></span><br><span class="line">        <span class="keyword">return</span> res == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在指定的位置上放置皇后</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">placeQueen</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 在row行，col列放置皇后</span></span><br><span class="line">        queens[row] = col;</span><br><span class="line">        <span class="comment">// 当前位置的列方向已经有皇后了</span></span><br><span class="line">        rows[col] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 当前位置的主对角线方向已经有皇后了</span></span><br><span class="line">        mains[row-col+n-<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 当前位置的次对角线方向已经有皇后了</span></span><br><span class="line">        secondary[row+col] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除指定位置上的皇后</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeQueen</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 移除row行上的皇后</span></span><br><span class="line">        queens[row] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 当前位置的列方向没有皇后了</span></span><br><span class="line">        rows[col] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 当前位置的主对角线方向没有皇后了</span></span><br><span class="line">        mains[row-col+n-<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 当前位置的次对角线方向没有皇后了</span></span><br><span class="line">        secondary[row+col] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将满足条件的皇后位置放入output中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addSolution</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; Solution = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> col = queens[i];</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col;j++) sb.append(<span class="string">"."</span>);</span><br><span class="line">            sb.append(<span class="string">"Q"</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n-col-<span class="number">1</span>;j++) sb.append(<span class="string">"."</span>);</span><br><span class="line">            Solution.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        output.add(Solution);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      N皇后
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Hard" scheme="http://benym.cn/tags/Hard/"/>
    
      <category term="回溯" scheme="http://benym.cn/tags/%E5%9B%9E%E6%BA%AF/"/>
    
      <category term="二维数组" scheme="http://benym.cn/tags/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"/>
    
      <category term="矩阵" scheme="http://benym.cn/tags/%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-23-合并K个排序链表</title>
    <link href="http://benym.cn/2020/06/07/LeetCode-23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://benym.cn/2020/06/07/LeetCode-23-合并K个排序链表/</id>
    <published>2020-06-07T12:09:48.000Z</published>
    <updated>2020-06-07T13:39:47.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-23-合并K个排序链表"><a href="#LeetCode-23-合并K个排序链表" class="headerlink" title="LeetCode-23-合并K个排序链表"></a>LeetCode-23-合并K个排序链表</h2><p>合并 <em>k</em> 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>相关链接：</p><ul><li><a href="/2020/06/07/LeetCode-21-合并两个有序链表/" title="LeetCode-21-合并两个有序链表">LeetCode-21-合并两个有序链表</a></li></ul><p>方法1、分治+递归+自底向上：</p><p>利用了归并排序分治的思想，对于一组链表，如果能够将每个链表两两拆分，那么问题就会简化为对两个链表的合并，合并之后的两两链表变为一个链表，再和另外一组已经合并成一个的链表合并，这个是自底向上的过程。</p><p>两个链表的合并过程与LeetCode21一致，所以本题只需要研究如何进行链表划分，并判断返回条件</p><ul><li><p>返回条件：</p><p>当链表长度为空，返回null；</p><p>当链表长度为1，返回list[0];</p><p>当链表长度为2，需要返回两个链表的合并</p></li><li><p>链表划分：</p><p>直接进行二分即可，mid左边的给l1数组，用于存储左边的一组链表；mid右边的给l2数组，用于存储右边的一组链表</p></li><li><p>开启递归：</p><p>拆分左边的多组链表，并进行合并；</p><p>拆分右边的多组链表，并进行合并；</p><p>返回：最后的左右链表的合并</p></li></ul><p>方法2、顺序遍历：</p><p>这种方法就是暴力破解，一个一个遍历链表组中的链表，然后进行合并即可，最终返回的就是顺序排序的合并链表</p><p>方法3、优先队列：</p><p>前提知识：</p><p>优先队列本身由最小堆实现，对于基础类型不需要重写Comparator接口，就可以实现默认加入数据之后队列是从小到大排序。在本题中，需要将链表从小到大的放入优先队列中，链表不是基础类型，所以需要重写Comparator接口将原本的v1.compareTo(v2)比较转化为v1.val和v2.val分别代表链表中的头结点值。这里采用匿名函数的实现方式</p><p>在Comparator接口中，排序的判断依据如下：</p><ul><li>如果v1&gt;v2，return 1</li><li>如果v1&lt;v2，return -1</li><li>如果v1==v2，return 0</li></ul><p>题目思路：</p><p>将所有链表的头结点放进去，由于是最小堆，所以每次就让队列中最小的出队，操作为pq.poll()，之后让出队的节点的下一个节点入队，再出队优先队列中的最小值，直到队列为空</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(lists.length == <span class="number">1</span>) <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(lists.length == <span class="number">2</span>) <span class="keyword">return</span> mergeTwoLists(lists[<span class="number">0</span>],lists[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> mid = lists.length/<span class="number">2</span>;</span><br><span class="line">        ListNode[] l1 = <span class="keyword">new</span> ListNode[mid];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;mid;i++)&#123;</span><br><span class="line">            l1[i] = lists[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode[] l2 = <span class="keyword">new</span> ListNode[lists.length-mid];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=mid,j=<span class="number">0</span>;i&lt;lists.length;i++,j++)&#123;</span><br><span class="line">            l2[j] = lists[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(mergeKLists(l1),mergeKLists(l2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode mergehead = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(l1.val&lt;l2.val)&#123;</span><br><span class="line">            mergehead = l1;</span><br><span class="line">            mergehead.next = mergeTwoLists(l1.next,l2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            mergehead = l2;</span><br><span class="line">            mergehead.next = mergeTwoLists(l1,l2.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mergehead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java代码2"><a href="#Java代码2" class="headerlink" title="Java代码2"></a>Java代码2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        ListNode res = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lists.length;i++)&#123;</span><br><span class="line">            res = mergeTwoLists(res,lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode mergehead = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(l1.val&lt;l2.val)&#123;</span><br><span class="line">            mergehead = l1;</span><br><span class="line">            mergehead.next = mergeTwoLists(l1.next,l2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            mergehead = l2;</span><br><span class="line">            mergehead.next = mergeTwoLists(l1,l2.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mergehead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java代码3"><a href="#Java代码3" class="headerlink" title="Java代码3"></a>Java代码3</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Queue&lt;ListNode&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((v1, v2) -&gt; v1.val - v2.val);</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">for</span>(ListNode list:lists)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list!=<span class="keyword">null</span>)</span><br><span class="line">                pq.offer(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            ListNode minNode = pq.poll();</span><br><span class="line">            cur.next = minNode;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            <span class="keyword">if</span>(minNode.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                pq.offer(minNode.next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      合并K个排序链表
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="链表" scheme="http://benym.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="Hard" scheme="http://benym.cn/tags/Hard/"/>
    
      <category term="分治" scheme="http://benym.cn/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-21-合并两个有序链表</title>
    <link href="http://benym.cn/2020/06/07/LeetCode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://benym.cn/2020/06/07/LeetCode-21-合并两个有序链表/</id>
    <published>2020-06-07T11:00:23.000Z</published>
    <updated>2020-06-07T12:08:01.180Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-21-合并两个有序链表"><a href="#LeetCode-21-合并两个有序链表" class="headerlink" title="LeetCode-21-合并两个有序链表"></a>LeetCode-21-合并两个有序链表</h2><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>方法一、递归：</p><p>首先，两个链表存在长短不一致的情况</p><p>递归终止条件：当链表1为空时，合并的链表为链表2；当链表2为空时，合并的链表为链表1</p><p>之后，链表需要从小到大的有序合并</p><p>新增一个合并后链表的头部指针，判断l1和l2的链表的当前位置值谁更小，小的加入到合并链表中，之后合并链表的next就是剩下的两个链表中的最小值。</p><p>最后返回合并链表头部</p><p>方法二、迭代：</p><p>迭代的思路大致和递归一样，但需要一个新的指针，pre记录当前位置的前一个元素，并不断调整他的next指向构建整个合并链表，phead负责合并链表的头部。</p><p>如果l1.val&lt;l2.val则，把l1接在pre的后面，同时l1指针向后移动1位。否则就对l2做相同操作</p><p>不管将l1和l2中的哪个元素接在了pre后面，pre指针始终需要向后移动1位，因为接了之后next就不为空了，需要移动到下一位继续构建链表</p><p>在循环终止的时候，l1和l2可能出现长短不一的情况，至多会有一个是非空的，由于输入的链表都是有序的，所以不管是哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的元素要大，此时只需要将剩下的链表接在pre.next，之后返回合并链表的头部即可</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode mergehead = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(l1.val&lt;l2.val)&#123;</span><br><span class="line">            mergehead = l1;</span><br><span class="line">            mergehead.next = mergeTwoLists(l1.next,l2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            mergehead = l2;</span><br><span class="line">            mergehead.next = mergeTwoLists(l1,l2.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mergehead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1: <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l2: <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">if</span> l1.val&lt;l2.val:</span><br><span class="line">            mergeHead = l1</span><br><span class="line">            mergeHead.next = self.mergeTwoLists(l1.next,l2)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mergeHead = l2</span><br><span class="line">            mergeHead.next = self.mergeTwoLists(l1,l2.next)</span><br><span class="line">        <span class="keyword">return</span> mergeHead</span><br></pre></td></tr></table></figure><h3 id="Java代码2"><a href="#Java代码2" class="headerlink" title="Java代码2"></a>Java代码2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode phead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode pre = phead;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span>&amp;&amp;l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val&lt;l2.val)&#123;</span><br><span class="line">                pre.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pre.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span>) pre.next = l2;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="keyword">null</span>) pre.next = l1;</span><br><span class="line">        <span class="keyword">return</span> phead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      合并两个有序链表
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="链表" scheme="http://benym.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="Python" scheme="http://benym.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-198-打家劫舍</title>
    <link href="http://benym.cn/2020/06/06/LeetCode-198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"/>
    <id>http://benym.cn/2020/06/06/LeetCode-198-打家劫舍/</id>
    <published>2020-06-06T07:03:23.000Z</published>
    <updated>2020-06-06T08:12:23.205Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-198-打家劫舍"><a href="#LeetCode-198-打家劫舍" class="headerlink" title="LeetCode-198-打家劫舍"></a>LeetCode-198-打家劫舍</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p> <a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span><br><span class="line">     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 400</code></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>动态规划：</p><p>题目和<a href="/2020/06/06/LeetCode-面试题17.16-按摩师/" title="LeetCode-面试题17.16-按摩师">LeetCode-面试题17.16-按摩师</a>是基本上一样的</p><p>dp数组的状态：当前位置前相隔数据的最大值</p><p>初始化：dp[0] = nums[0] ,dp[1] = Math.max(nums[0],nums[1])</p><p>转移方程：索引从2开始，由于dp[i-1]存储前面相隔数据的最大值，所以需要比较，当前位置的num[i]和前面间隔位置的数值最大值dp[i-2]之和，与dp[i-1]之间的大小关系，即<code>dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i])</code></p><p>双指针：</p><p>多加一间房子，这个解法是经过分析之后简化的，原文来源<a href="https://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-dong-tai-gui-hua-jie-gou-hua-si-lu-/" target="_blank" rel="noopener">这里</a></p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||len==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(len&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;len;i++)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        cur , pre = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            cur,pre = max(pre+i,cur),cur</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      打家劫舍
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="DP" scheme="http://benym.cn/tags/DP/"/>
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="LeetCode" scheme="http://benym.cn/tags/LeetCode/"/>
    
      <category term="Python" scheme="http://benym.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-面试题17.16-按摩师</title>
    <link href="http://benym.cn/2020/06/06/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9817.16-%E6%8C%89%E6%91%A9%E5%B8%88/"/>
    <id>http://benym.cn/2020/06/06/LeetCode-面试题17.16-按摩师/</id>
    <published>2020-06-06T05:50:17.000Z</published>
    <updated>2020-06-06T07:01:50.853Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-面试题17-16-按摩师"><a href="#LeetCode-面试题17-16-按摩师" class="headerlink" title="LeetCode-面试题17.16-按摩师"></a>LeetCode-面试题17.16-按摩师</h2><p>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。</p><p>注意：本题相对原题稍作改动</p> <a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： [1,2,3,1]</span><br><span class="line">输出： 4</span><br><span class="line">解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： [2,7,9,3,1]</span><br><span class="line">输出： 12</span><br><span class="line">解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。</span><br></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： [2,1,4,5,3,1,1,3]</span><br><span class="line">输出： 12</span><br><span class="line">解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>动态规划：</p><p>看示例1示例2，以为是奇数位置和偶数位置的动态规划，这样就不需要额外的空间….然后发现示例3不是这样的</p><p>于是还是老老实实拿个dp数组吧</p><p>dp数组的状态：当前位置前相隔数据的最大值</p><p>初始化：dp[0] = nums[0] ,dp[1] = Math.max(nums[0],nums[1])</p><p>转移方程：索引从2开始，由于dp[i-1]存储前面相隔数据的最大值，所以需要比较，当前位置的num[i]和前面间隔位置的数值最大值dp[i-2]之和，与dp[i-1]之间的大小关系，即<code>dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i])</code></p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||len==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(len&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;len;i++)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      按摩师
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="DP" scheme="http://benym.cn/tags/DP/"/>
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="LeetCode" scheme="http://benym.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-121-买卖股票的最佳时机</title>
    <link href="http://benym.cn/2020/06/05/LeetCode-121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
    <id>http://benym.cn/2020/06/05/LeetCode-121-买卖股票的最佳时机/</id>
    <published>2020-06-05T12:28:28.000Z</published>
    <updated>2020-06-05T13:06:32.702Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-121-买卖股票的最佳时机"><a href="#LeetCode-121-买卖股票的最佳时机" class="headerlink" title="LeetCode-121-买卖股票的最佳时机"></a>LeetCode-121-买卖股票的最佳时机</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p><p>注意：你不能在买入股票前卖出股票。</p> <a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>方法一、线性遍历(DP思想)：</p><p>当利润是负数时，最小数应该变化为当前值，当利润为正数时，max最大利润保存，最后返回最大利润即可</p><p>前i天的最大收益= max(前i-1天的最大收益，第i天的价格-前i-1天中的最小价格)</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices==<span class="keyword">null</span>||prices.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> low = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]-low&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                low = prices[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp = Math.max(temp,prices[i]-low);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      买卖股票的最佳时机
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="DP" scheme="http://benym.cn/tags/DP/"/>
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="LeetCode" scheme="http://benym.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-303-区域和检索-数组不可变</title>
    <link href="http://benym.cn/2020/05/31/LeetCode-303-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98/"/>
    <id>http://benym.cn/2020/05/31/LeetCode-303-区域和检索-数组不可变/</id>
    <published>2020-05-31T02:12:38.000Z</published>
    <updated>2020-06-05T13:36:37.830Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-303-区域和检索-数组不可变"><a href="#LeetCode-303-区域和检索-数组不可变" class="headerlink" title="LeetCode-303-区域和检索-数组不可变"></a>LeetCode-303-区域和检索-数组不可变</h2><p>给定一个整数数组  <em>nums</em>，求出数组从索引 <em>i</em> 到 <em>j</em>  (<em>i</em> ≤ <em>j</em>) 范围内元素的总和，包含 <em>i,  j</em> 两点。</p> <a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()</span><br><span class="line"></span><br><span class="line">sumRange(0, 2) -&gt; 1</span><br><span class="line">sumRange(2, 5) -&gt; -1</span><br><span class="line">sumRange(0, 5) -&gt; -3</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ol><li>你可以假设数组不可变。</li><li>会多次调用 <em>sumRange</em> 方法。</li></ol><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>方法1、DP暴力破解：</p><p>显然这个方法可以用一维DP解决</p><p>状态：dp[in]代表从i开始到当前位置的元素和</p><p>状态转移方程：</p><ul><li>当是第一个元素时，直接赋值</li><li>当是元素i，且i！=0时，dp[i]由dp[i-1]个元素和决定</li></ul><p>需要一个dp数组指针in，线性遍历一次数组，dp数组的最后位置就是元素和</p><p>这个方法勉强能通过，但是每次调用都要计算[i,j]范围的和，速度很慢</p><p>方法2、缓存：</p><p>提前计算出所有范围的累和，能不能计算出第i个元素的和</p><p>sum[k]定义为nums[0…k-1]的累和，sum[0]=0</p><p>对于上述示例数组sum数组为[0，-2，-2，1，-4，-2，-3]</p><p>sumrange(i,j)=sum[j+1]-sum[i]，也就是把后面部分的和前去并集部分即可</p><p>这种方法只需要计算一次和，之后仅需要从数组取值相减即可得到结果</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] nums;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nums = nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[j-i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> in = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;=j;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k==i)</span><br><span class="line">                dp[in] = <span class="keyword">this</span>.nums[k];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[in]=dp[in-<span class="number">1</span>]+<span class="keyword">this</span>.nums[k];</span><br><span class="line">            in++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[in-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.sumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="Java代码2"><a href="#Java代码2" class="headerlink" title="Java代码2"></a>Java代码2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] sum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        sum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum[i + <span class="number">1</span>] = sum[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum[j + <span class="number">1</span>] - sum[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.sumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      区域和检索-数组不可变
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="DP" scheme="http://benym.cn/tags/DP/"/>
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="LeetCode" scheme="http://benym.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-392-判断子序列</title>
    <link href="http://benym.cn/2020/05/30/LeetCode-392-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://benym.cn/2020/05/30/LeetCode-392-判断子序列/</id>
    <published>2020-05-30T05:13:39.000Z</published>
    <updated>2020-05-30T06:55:31.255Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-392-判断子序列"><a href="#LeetCode-392-判断子序列" class="headerlink" title="LeetCode-392-判断子序列"></a>LeetCode-392-判断子序列</h2><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p><p>你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。</p><p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p> <a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;abc&quot;, t = &quot;ahbgdc&quot;</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;axc&quot;, t = &quot;ahbgdc&quot;</span><br></pre></td></tr></table></figure><p>后续挑战 :</p><p>如果有大量输入的 S，称作S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>方法1、顺序遍历：</p><p>固定s的第一位找t中有没有这一位，有就移动s指针，并让len++，当len达到slen的时候说明匹配上了</p><p>方法2、DP：</p><p>DP不是很快，主要是为了练手该怎么做，<a href="https://leetcode-cn.com/problems/is-subsequence/solution/java-dp-by-zxy0917-5/" target="_blank" rel="noopener">出处来源于这里</a></p><p>状态<code>dp[i][j]</code>为s从头开始到i的子字符串是否是t从头开始到j的子字符串的子序列</p><p>状态转移公式：</p><ul><li>当<code>char[i]==char[j]</code>时，则字符i一定是j的子序列，如果0~i-1子字符串是0~j-1子字符串的子序列，则<code>dp[i][j]=true</code>，也就是说当前的字符匹配上了，前面的也匹配上了，才是子序列，所以<code>dp[i][j]=dp[i-1][j-1]</code></li><li>当<code>char[i]!=char[j]</code>时，即判断当前0~i子字符串是否是0~j-1的子字符串的子序列，即<code>dp[i][j]=d[i][j-1]</code>。如ab，eabc，虽然s的最后一个字符串和t中的最后一个字符不相等，但是ab是eab的子序列，所以ab也是eabc的子序列</li><li>初始化：空字符串一定是t的子字符串的子序列，所以<code>dp[0][j]=true</code></li></ul><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubsequence</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != <span class="number">0</span> &amp;&amp;t.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.length()==<span class="number">0</span>&amp;&amp;t.length()!=<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.length()==<span class="number">0</span>&amp;&amp;t.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> slen = s.length();</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(index) == (t.charAt(i))) &#123;</span><br><span class="line">                index++;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (len == slen)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java代码2"><a href="#Java代码2" class="headerlink" title="Java代码2"></a>Java代码2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubsequence</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slen = s.length(),tlen = t.length();</span><br><span class="line">        <span class="keyword">if</span>(slen&gt;tlen) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(slen==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[slen+<span class="number">1</span>][tlen+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;tlen;j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;=slen;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">1</span>;j&lt;=tlen;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>)==t.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[slen][tlen];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      判断子序列
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="DP" scheme="http://benym.cn/tags/DP/"/>
    
      <category term="LeetCode" scheme="http://benym.cn/tags/LeetCode/"/>
    
      <category term="字符串" scheme="http://benym.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-53-最大子序和</title>
    <link href="http://benym.cn/2020/05/30/LeetCode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
    <id>http://benym.cn/2020/05/30/LeetCode-53-最大子序和/</id>
    <published>2020-05-30T02:28:18.000Z</published>
    <updated>2020-05-30T03:59:42.520Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-53-最大子序和"><a href="#LeetCode-53-最大子序和" class="headerlink" title="LeetCode-53-最大子序和"></a>LeetCode-53-最大子序和</h2><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p> <a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong></p><p>如果你已经实现复杂度为 O(<em>n</em>) 的解法，尝试使用更为精妙的分治法求解。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>方法1、DP：</p><p>当前元素存储前一个元素和当前元素之和与当前元素之间的最大值，每个位置均可以由此规则计算得出，最后返回数组的最大值即可</p><p>方法2、贪心：</p><p>如果当前元素之前的和小于0，就丢弃之前的数列，即dp[i] = num[i]，如果大于0就累加</p><p>方法3、更清楚的版本：</p><p>实际上是一样的，只是代码看得清楚点</p><p>当前和小于0，就把nums[i]赋值，如果当前值&gt;最大值</p><p>交换最大值</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            dp[i] = Math.max(nums[i],dp[i-<span class="number">1</span>]+nums[i]);</span><br><span class="line">            max = Math.max(max,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> len(nums)==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            nums[i] = nums[i]+max(nums[i<span class="number">-1</span>],<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> max(nums)</span><br></pre></td></tr></table></figure><h3 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span>||nums==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxSum = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curSum&lt;=<span class="number">0</span>)</span><br><span class="line">                curSum = nums[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                curSum+=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(curSum&gt;maxSum)&#123;</span><br><span class="line">                maxSum = curSum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      最大子序和
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="DP" scheme="http://benym.cn/tags/DP/"/>
    
      <category term="LeetCode" scheme="http://benym.cn/tags/LeetCode/"/>
    
      <category term="Python" scheme="http://benym.cn/tags/Python/"/>
    
      <category term="贪心算法" scheme="http://benym.cn/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
