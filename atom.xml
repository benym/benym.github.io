<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ming.Y</title>
  
  <subtitle>Chances are for people who are prepared</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://benym.cn/"/>
  <updated>2020-06-20T13:26:34.479Z</updated>
  <id>http://benym.cn/</id>
  
  <author>
    <name>BenY</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode-70-爬楼梯</title>
    <link href="http://benym.cn/2020/06/20/LeetCode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <id>http://benym.cn/2020/06/20/LeetCode-70-爬楼梯/</id>
    <published>2020-06-20T12:58:35.000Z</published>
    <updated>2020-06-20T13:26:34.479Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-70-爬楼梯"><a href="#LeetCode-70-爬楼梯" class="headerlink" title="LeetCode-70-爬楼梯"></a>LeetCode-70-爬楼梯</h2><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>方法1、动态规划：</strong></p><p>当n等于1的时候，只需要跳一次即可，只有一种跳法，记f(1)=1</p><p>当n等于2的时候，可以先跳一级再跳一级，或者直接跳二级，共有2种跳法，记f(2)=2</p><p>当n等于3的时候，他可以从一级台阶上跳两步上来，也可以从二级台阶上跳一步上来，所以总共有f(3)=f(2)+f(1)；</p><p>所以当等于n(n&gt;2)的时候，总共有f(n)=f(n-1)+f(n-2)种跳法</p><p>此时的状态:   为n的时候，可能的跳法有多少种</p><p>状态转移方程：<code>f(n)=f(n-1)+f(n-2)</code></p><p><strong>方法2、优化的动态规划：</strong></p><p>上一个方法需要开辟一个n的数组，其实可以直接用双指针完成状态的转移，不再需要开辟多余的空间</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java代码2"><a href="#Java代码2" class="headerlink" title="Java代码2"></a>Java代码2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result[n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> f1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> f2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            sum = (f1 + f2);</span><br><span class="line">            f1 = f2;</span><br><span class="line">            f2 = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      爬楼梯
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="DP" scheme="http://benym.cn/tags/DP/"/>
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-11-盛最多水的容器</title>
    <link href="http://benym.cn/2020/06/19/LeetCode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <id>http://benym.cn/2020/06/19/LeetCode-11-盛最多水的容器/</id>
    <published>2020-06-19T06:57:16.000Z</published>
    <updated>2020-06-19T07:30:47.508Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-11-盛最多水的容器"><a href="#LeetCode-11-盛最多水的容器" class="headerlink" title="LeetCode-11-盛最多水的容器"></a>LeetCode-11-盛最多水的容器</h2><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器，且 n 的值至少为 2。</p> <a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>方法1、双指针：</strong></p><p>根据题目的意思，最大面积=左右两个内板较低的一个高度*左右两个内板的间隔</p><p>利用双指针解决，初始化首尾指针，现在的问题是怎么样去移动首尾指针，才能够使得面积最大</p><p>想象一下，无论首尾指针谁大，我们都需要移动一次首尾指针，依次判断面积谁更大，此时无论是移动首还是尾指针，底部长度的变化都是1。于是我们只需要知道，移动哪个指针能让面积增大就行了。经过思考，移动值较小的那个指针，保留值较大的指针，可以使得面积更大的概率更大。所以当其中一个指针的值小于另外一个的时候，移动那个指针即可</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            max = Math.max(max,(right-left)*Math.min(height[left],height[right]));</span><br><span class="line">            <span class="keyword">if</span>(height[left]&lt;height[right]) left++;</span><br><span class="line">            <span class="keyword">else</span> right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      盛最多水的容器
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://benym.cn/tags/LeetCode/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-4-寻找两个正序数组的中位数</title>
    <link href="http://benym.cn/2020/06/19/LeetCode-4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://benym.cn/2020/06/19/LeetCode-4-寻找两个正序数组的中位数/</id>
    <published>2020-06-19T05:52:54.000Z</published>
    <updated>2020-06-19T06:55:19.730Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-4-寻找两个正序数组的中位数"><a href="#LeetCode-4-寻找两个正序数组的中位数" class="headerlink" title="LeetCode-4-寻找两个正序数组的中位数"></a>LeetCode-4-寻找两个正序数组的中位数</h2><p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。</p><p>请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 nums1 和 nums2 不会同时为空。</p> <a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line"></span><br><span class="line">则中位数是 2.0</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line"></span><br><span class="line">则中位数是 (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>方法1、归并排序思想：</strong></p><p>这种方法的复杂度不符合题意，属于备用解法</p><p>对于两个有序的数组，想要找到对应的中位数，最简单的方法就是将两个数组合并为1个，之后找中位数就很简单</p><p>只需要知道中间位置即可，奇数情况是一个数，偶数情况是两个数</p><p><strong>方法2、二分查找思想：</strong></p><p>不会做….答案出自<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/" target="_blank" rel="noopener">官方题解</a></p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] merge = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length + nums2.length];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] &lt;= nums2[j]) &#123;</span><br><span class="line">                merge[m++] = nums1[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                merge[m++] = nums2[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums1.length) &#123;</span><br><span class="line">            merge[m++] = nums1[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; nums2.length) &#123;</span><br><span class="line">            merge[m++] = nums2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (m % <span class="number">2</span> == <span class="number">0</span>) ? ((<span class="keyword">double</span>) merge[m / <span class="number">2</span>] + (<span class="keyword">double</span>) merge[m / <span class="number">2</span> - <span class="number">1</span>]) / <span class="number">2</span> : (<span class="keyword">double</span>) merge[m / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leftLength = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> rightLength = nums2.length;</span><br><span class="line">        <span class="comment">// 为了保证第一个数组比第二个数组小(或者相等)</span></span><br><span class="line">        <span class="keyword">if</span> (leftLength &gt; rightLength) &#123;</span><br><span class="line">            <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分割线左边的所有元素需要满足的个数 m + (n - m + 1) / 2;</span></span><br><span class="line">        <span class="comment">// 两个数组长度之和为偶数时，当在长度之和上+1时，由于整除是向下取整，所以不会改变结果</span></span><br><span class="line">        <span class="comment">// 两个数组长度之和为奇数时，按照分割线的左边比右边多一个元素的要求，此时在长度之和上+1，就会被2整除，会在原来的数</span></span><br><span class="line">        <span class="comment">//的基础上+1，于是多出来的那个1就是左边比右边多出来的一个元素</span></span><br><span class="line">        <span class="keyword">int</span> totalLeft = (leftLength + rightLength + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 在 nums1 的区间 [0, leftLength] 里查找恰当的分割线，</span></span><br><span class="line">        <span class="comment">// 使得 nums1[i - 1] &lt;= nums2[j] &amp;&amp; nums2[j - 1] &lt;= nums1[i]</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = leftLength;</span><br><span class="line">        <span class="comment">// nums1[i - 1] &lt;= nums2[j]</span></span><br><span class="line">        <span class="comment">//  此处要求第一个数组中分割线的左边的值 不大于(小于等于) 第二个数组中分割线的右边的值</span></span><br><span class="line">        <span class="comment">// nums2[j - 1] &lt;= nums1[i]</span></span><br><span class="line">        <span class="comment">//  此处要求第二个数组中分割线的左边的值 不大于(小于等于) 第一个数组中分割线的右边的值</span></span><br><span class="line">        <span class="comment">// 循环条件结束的条件为指针重合，即分割线已找到</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 二分查找，此处为取第一个数组中左右指针下标的中位数，决定起始位置</span></span><br><span class="line">            <span class="comment">// 此处+1首先是为了不出现死循环，即left永远小于right的情况</span></span><br><span class="line">            <span class="comment">// left和right最小差距是1，此时下面的计算结果如果不加1会出现i一直=left的情况，而+1之后i才会=right</span></span><br><span class="line">            <span class="comment">// 于是在left=i的时候可以破坏循环条件，其次下标+1还会保证下标不会越界，因为+1之后向上取整，保证了</span></span><br><span class="line">            <span class="comment">// i不会取到0值，即i-1不会小于0</span></span><br><span class="line">            <span class="comment">// 此时i也代表着在一个数组中左边的元素的个数</span></span><br><span class="line">            <span class="keyword">int</span> i = left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 第一个数组中左边的元素个数确定后，用左边元素的总和-第一个数组中元素的总和=第二个元素中左边的元素的总和</span></span><br><span class="line">            <span class="comment">// 此时j就是第二个元素中左边的元素的个数</span></span><br><span class="line">            <span class="keyword">int</span> j = totalLeft - i;</span><br><span class="line">            <span class="comment">// 此处用了nums1[i - 1] &lt;= nums2[j]的取反，当第一个数组中分割线的左边的值大于第二个数组中分割线的右边的值</span></span><br><span class="line">            <span class="comment">// 说明又指针应该左移，即-1</span></span><br><span class="line">            <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] &gt; nums2[j]) &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索的区间 [left, i - 1]</span></span><br><span class="line">                right = i - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 此时说明条件满足，应当将左指针右移到i的位置，至于为什么是右移，请看i的定义</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索的区间 [i, right]</span></span><br><span class="line">                left = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 退出循环时left一定等于right，所以此时等于left和right都可以</span></span><br><span class="line">        <span class="comment">// 为什么left一定不会大于right?因为left=i。</span></span><br><span class="line">        <span class="comment">// 此时i代表分割线在第一个数组中所在的位置</span></span><br><span class="line">        <span class="comment">// nums1[i]为第一个数组中分割线右边的第一个值</span></span><br><span class="line">        <span class="comment">// nums[i-1]即第一个数组中分割线左边的第一个值</span></span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="comment">// 此时j代表分割线在第二个数组中的位置</span></span><br><span class="line">        <span class="comment">// nums2[j]为第一个数组中分割线右边的第一个值</span></span><br><span class="line">        <span class="comment">// nums2[j-1]即第一个数组中分割线左边的第一个值</span></span><br><span class="line">        <span class="keyword">int</span> j = totalLeft - i;</span><br><span class="line">        <span class="comment">// 当i=0时，说明第一个数组分割线左边没有值，为了不影响</span></span><br><span class="line">        <span class="comment">// nums1[i - 1] &lt;= nums2[j] 和 Math.max(nums1LeftMax, nums2LeftMax)</span></span><br><span class="line">        <span class="comment">// 的判断，所以将它设置为int的最小值</span></span><br><span class="line">        <span class="keyword">int</span> nums1LeftMax = i == <span class="number">0</span> ? Integer.MIN_VALUE : nums1[i - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 等i=第一个数组的长度时，说明第一个数组分割线右边没有值，为了不影响</span></span><br><span class="line">        <span class="comment">// nums2[j - 1] &lt;= nums1[i] 和 Math.min(nums1RightMin, nums2RightMin)</span></span><br><span class="line">        <span class="comment">// 的判断，所以将它设置为int的最大值</span></span><br><span class="line">        <span class="keyword">int</span> nums1RightMin = i == leftLength ? Integer.MAX_VALUE : nums1[i];</span><br><span class="line">        <span class="comment">// 当j=0时，说明第二个数组分割线左边没有值，为了不影响</span></span><br><span class="line">        <span class="comment">// nums2[j - 1] &lt;= nums1[i] 和 Math.max(nums1LeftMax, nums2LeftMax)</span></span><br><span class="line">        <span class="comment">// 的判断，所以将它设置为int的最小值</span></span><br><span class="line">        <span class="keyword">int</span> nums2LeftMax = j == <span class="number">0</span> ? Integer.MIN_VALUE : nums2[j - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 等j=第二个数组的长度时，说明第二个数组分割线右边没有值，为了不影响</span></span><br><span class="line">        <span class="comment">// nums1[i - 1] &lt;= nums2[j] 和 Math.min(nums1RightMin, nums2RightMin)</span></span><br><span class="line">        <span class="comment">// 的判断，所以将它设置为int的最大值</span></span><br><span class="line">        <span class="keyword">int</span> nums2RightMin = j == rightLength ? Integer.MAX_VALUE : nums2[j];</span><br><span class="line">        <span class="comment">// 如果两个数组的长度之和为奇数，直接返回两个数组在分割线左边的最大值即可</span></span><br><span class="line">        <span class="keyword">if</span> (((leftLength + rightLength) % <span class="number">2</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(nums1LeftMax, nums2LeftMax);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果两个数组的长度之和为偶数，返回的是两个数组在左边的最大值和两个数组在右边的最小值的和的二分之一</span></span><br><span class="line">            <span class="comment">// 此处不能被向下取整，所以要强制转换为double类型</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>) ((Math.max(nums1LeftMax, nums2LeftMax) + Math.min(nums1RightMin, nums2RightMin))) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      寻找两个正序数组的中位数
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://benym.cn/tags/LeetCode/"/>
    
      <category term="Hard" scheme="http://benym.cn/tags/Hard/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-136-只出现一次的数字</title>
    <link href="http://benym.cn/2020/06/18/LeetCode-136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://benym.cn/2020/06/18/LeetCode-136-只出现一次的数字/</id>
    <published>2020-06-18T13:22:13.000Z</published>
    <updated>2020-06-18T13:54:27.157Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-136-只出现一次的数字"><a href="#LeetCode-136-只出现一次的数字" class="headerlink" title="LeetCode-136-只出现一次的数字"></a>LeetCode-136-只出现一次的数字</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p> <a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>方法1、异或运算：</strong></p><p>异或运算的特点</p><ul><li>任何数和0做异或运算，结果是原来的数</li><li>任何数和其自身做异或运算，结果是自身</li><li>异或运算满足交换律和结合律，即<code>a^b^a=b^a^a=b^(a^a)=b^0=b</code></li></ul><p>根据这个特点可以直接用异或运算得出出现一次的字符</p><p><strong>方法2、哈希表：</strong></p><p>这个解法不符合题意，用到了一个哈希表来存储数字出现的次数</p><p>之后取出出现次数为1的数字即可</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> single = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            single ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        dict1 = dict()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> dict1:</span><br><span class="line">                dict1[i]+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dict1[i]=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> list(dict1.keys())[list(dict1.values()).index(<span class="number">1</span>)]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      只出现一次的数字
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="LeetCode" scheme="http://benym.cn/tags/LeetCode/"/>
    
      <category term="Python" scheme="http://benym.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-413-等差数列划分</title>
    <link href="http://benym.cn/2020/06/18/LeetCode-413-%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86/"/>
    <id>http://benym.cn/2020/06/18/LeetCode-413-等差数列划分/</id>
    <published>2020-06-18T12:13:57.000Z</published>
    <updated>2020-06-18T13:14:05.047Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-413-等差数列划分"><a href="#LeetCode-413-等差数列划分" class="headerlink" title="LeetCode-413-等差数列划分"></a>LeetCode-413-等差数列划分</h2><p>如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。</p><p>例如，以下数列为等差数列:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1, 3, 5, 7, 9</span><br><span class="line">7, 7, 7, 7</span><br><span class="line">3, -1, -5, -9</span><br></pre></td></tr></table></figure><p>以下数列不是等差数列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1, 1, 2, 5, 7</span><br></pre></td></tr></table></figure> <a id="more"></a><p>数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0&lt;=P&lt;Q&lt;N 。</p><p>如果满足以下条件，则称子数组(P, Q)为等差数组：</p><p>元素 A[P], A[p + 1], …, A[Q - 1], A[Q] 是等差的。并且 P + 1 &lt; Q 。</p><p>函数要返回数组 A 中所有为等差数组的子数组个数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A = [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>方法1、动态规划：</strong></p><p><strong>状态定义</strong>为：当前的等差数组数量</p><p>如果前一个状态是等差数组，则只需要判断后一个数字前两个的差值是否满足等差数组，如果满足则+1</p><p>如1，2，3是等差数组，指针后移到4时仍然满足等差数组的条件，此时不需要往前判断到1，只需要判断到前2位即可，2，3，4是等差数组，之前的1，2，3，4同样也是</p><p>所以<strong>状态转移方程</strong>为：dp[i]=dp[i-1]+1</p><p>之后返回dp数组的和就是等差数组的数量</p><p><strong>方法2、暴力破解：</strong></p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = A.length;</span><br><span class="line">        <span class="keyword">if</span>(A==<span class="keyword">null</span>||len==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i-<span class="number">1</span>]-A[i-<span class="number">2</span>]==A[i]-A[i-<span class="number">1</span>])&#123;</span><br><span class="line">                dp[i]=dp[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                sum+=dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = A.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len-<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> distance = A[i+<span class="number">1</span>]-A[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">2</span>;j&lt;len;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[j]-A[j-<span class="number">1</span>]==distance)&#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      判断子序列
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="DP" scheme="http://benym.cn/tags/DP/"/>
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://benym.cn/tags/LeetCode/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-5-最长回文字串</title>
    <link href="http://benym.cn/2020/06/18/LeetCode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%97%E4%B8%B2/"/>
    <id>http://benym.cn/2020/06/18/LeetCode-5-最长回文字串/</id>
    <published>2020-06-18T06:31:14.000Z</published>
    <updated>2020-06-18T12:18:21.668Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-5-最长回文字串"><a href="#LeetCode-5-最长回文字串" class="headerlink" title="LeetCode-5-最长回文字串"></a>LeetCode-5-最长回文字串</h2><p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p> <a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>方法1、暴力破解：</strong></p><p>暴力破解法，判断每个串开头的所有子串中，大于最长子串的串是否是回文子串</p><p>判断回文字串的方法为，首尾往内遍历，如果首尾不相等则不是回文字串，移动左指针+1，右指针-1；</p><p>否则就是回文子串</p><p><strong>方法2、动态规划：</strong></p><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/" target="_blank" rel="noopener">参考地址1</a></p><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/" target="_blank" rel="noopener">参考地址2</a></p><p><strong>方法3、中心扩散法：</strong></p><p>枚举所有的回文中心位置，回文中心位置需要按照字符串长度分为奇数和偶数的情况</p><p>奇数情况时，回文中心仅有1个字符</p><p>偶数情况时，回文中心有2个字符</p><p>从回文中心出发进行扩散，尽可能的使得子串长度达到最大，不满足时跳出，返回扩散之后回文子串的长度<code>j-i+1-2</code></p><p>判断奇数情况和偶数情况下回文子串的最大长度</p><p>之后按照最大长度找到回文子串开始的位置，截取子串返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">比如</span><br><span class="line">奇数回文串                             偶数回文串</span><br><span class="line">A   A   B   C   B   A                A   A   B   C   C   B   A</span><br><span class="line">0   1   2   3   4   5                0   1   2   3   4   5   6</span><br><span class="line">  begin     i                          begin     i  i+1</span><br><span class="line">          len=5                                  len=6</span><br><span class="line">                   bengin = i-(len-1)/2</span><br></pre></td></tr></table></figure><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span>(len&lt;<span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> maxlen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] charAarray = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j-i+<span class="number">1</span>&gt;maxlen&amp;&amp;validateSubString(charAarray,i,j))&#123;</span><br><span class="line">                    begin = i;</span><br><span class="line">                    maxlen = j-i+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(begin,begin+maxlen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateSubString</span><span class="params">(<span class="keyword">char</span>[] charAarray,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(charAarray[left]!=charAarray[right])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java代码2"><a href="#Java代码2" class="headerlink" title="Java代码2"></a>Java代码2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i][j] 表示 s[i, j] 是否是回文串</span></span><br><span class="line">        <span class="comment">// i是子串的左边界，j是子串的右边界</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">        <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line"><span class="comment">// 对角线恒为true</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 由于dp[i+1][j-1]是行+1，列减1，dp[i][j]依赖于左下方的值，这样不好计算</span></span><br><span class="line">        <span class="comment">// 所以先升序填列，再升序填行，按列遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len; j++) &#123; <span class="comment">// 列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; i++) &#123;<span class="comment">// 行</span></span><br><span class="line">                <span class="keyword">if</span> (charArray[i] != charArray[j]) &#123; <span class="comment">// 头尾字符不相等时</span></span><br><span class="line">                    dp[i][j] = <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// j-1-(i+1)+1&lt;2</span></span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt; <span class="number">3</span>) &#123; <span class="comment">// 如果头尾没有字符，或者只剩一个字符</span></span><br><span class="line">                        dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 只要 dp[i][j] == true 成立，就表示子串 s[i..j] 是回文，此时记录回文长度和起始位置</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxLen) &#123;</span><br><span class="line">                    maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(begin, begin + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java代码3"><a href="#Java代码3" class="headerlink" title="Java代码3"></a>Java代码3</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line">        <span class="comment">// 枚举所有回文中心</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> oddLen = expandAroudCenter(charArray,i,i); <span class="comment">// 以下标i作为回文中心</span></span><br><span class="line">            <span class="keyword">int</span> evenLen = expandAroudCenter(charArray,i,i+<span class="number">1</span>); <span class="comment">//以下标i和i+1作为回文中心</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> curMaxLen = Math.max(oddLen,evenLen);</span><br><span class="line">            <span class="keyword">if</span>(curMaxLen&gt;maxLen)&#123;</span><br><span class="line">                maxLen = curMaxLen;</span><br><span class="line">                <span class="comment">// 画图找规律</span></span><br><span class="line">                begin = i-(maxLen-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(begin,begin+maxLen);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">expandAroudCenter</span><span class="params">(<span class="keyword">char</span>[] charArray,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 当left=right的时候，回文中心是一个字符，回文串的长度是奇数</span></span><br><span class="line">        <span class="comment">// 当right=left+1的时候，此时回文中心两个字符，回文串的长度是偶数</span></span><br><span class="line">        <span class="keyword">int</span> len = charArray.length;</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = right;</span><br><span class="line">        <span class="comment">// 从回文中心向两边扩散</span></span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&lt;len)&#123;</span><br><span class="line">            <span class="keyword">if</span>(charArray[i]==charArray[j])&#123;</span><br><span class="line">                i--;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 跳出while循环时，恰好满足 s.charAt(i)!=s.charAt(j)</span></span><br><span class="line">        <span class="comment">// 回文串的长度 j-i+1-2=j-i-1 ，减2是因为不包括回文中心字符</span></span><br><span class="line">        <span class="keyword">return</span> j-i-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      最长回文字串
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="DP" scheme="http://benym.cn/tags/DP/"/>
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://benym.cn/tags/LeetCode/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="字符串" scheme="http://benym.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-3-无重复字符的最长字串</title>
    <link href="http://benym.cn/2020/06/16/LeetCode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2/"/>
    <id>http://benym.cn/2020/06/16/LeetCode-3-无重复字符的最长字串/</id>
    <published>2020-06-16T06:56:12.000Z</published>
    <updated>2020-06-16T08:53:29.320Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-3-无重复字符的最长字串"><a href="#LeetCode-3-无重复字符的最长字串" class="headerlink" title="LeetCode-3-无重复字符的最长字串"></a>LeetCode-3-无重复字符的最长字串</h2><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p> <a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>方法1、哈希表：</strong></p><p>首先挨个比较i个字符和i+1结合哈希的方法是失败的，这样求的不适用于<code>dvdf</code>这样的测试用例</p><p>我们可以通过记录无重复字符的初始位置start，以及结尾位置end，算出最长的字串是多大</p><p>顺序遍历整个字符数组，判断当前的元素是否在hash表内，如果在则将当前元素作为key值，获取不重复元素对应位置，并更新start，此时，start到end不存在重复字符</p><p>进入下一步，计算区间内字符长度</p><p>如果当前元素不在hash表内，则添加当前字符位置+1，+1表示从当前字符位置后面一个开始不重复</p><p><strong>方法2、滑动窗口：</strong></p><p>窗口的最大值就是最长字串，比如<code>dvdf</code>这样的用例</p><p>当窗口为<code>dv</code>的时候，满足题目要求，当窗口为<code>dvd</code>时，不满足要求，此时需要向右边滑动</p><p>将左边重复的元素d移除，同时在右边新增，直到满足要求为止</p><p>当窗口变化的时候记录当前窗口的最大值</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> end = <span class="number">0</span>; end &lt; c.length; end++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(c[end])) &#123;</span><br><span class="line">                start = Math.max(map.get(c[end]), start);</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max, end - start + <span class="number">1</span>);</span><br><span class="line">            map.put(c[end], end + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        Max,curMax = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        hashset = set()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            curMax += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> s[i] <span class="keyword">in</span> hashset:</span><br><span class="line">                hashset.remove(s[left])</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                curMax -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> curMax &gt; Max: Max = curMax</span><br><span class="line">            hashset.add(s[i])</span><br><span class="line">        <span class="keyword">return</span> Max</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      无重复字符的最长字串
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://benym.cn/tags/LeetCode/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="字符串" scheme="http://benym.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-2-两数相加</title>
    <link href="http://benym.cn/2020/06/16/LeetCode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>http://benym.cn/2020/06/16/LeetCode-2-两数相加/</id>
    <published>2020-06-16T02:02:43.000Z</published>
    <updated>2020-06-16T06:52:24.786Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-2-两数相加"><a href="#LeetCode-2-两数相加" class="headerlink" title="LeetCode-2-两数相加"></a>LeetCode-2-两数相加</h2><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p> <a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>顺序推进+哑结点：</strong></p><p>对于本题的测试用例，不难知道有以下三种情况：</p><ol><li>两个链表长度一致</li><li>两个链表长度一长一短</li><li>两个链表在相加过程中产生进位，进位需要加在下一位</li></ol><p><strong>特例判断</strong>，当l1为空，直接返回l2；当l2为空，直接返回l1</p><p>新增l1，l2的指针t1，t2，方便链表的遍历；新增l3哑结点和对应指针t3，用于存储相加之后的链表</p><p><strong>相加流程：</strong></p><p>当两个链表其中一个不为空的时候，说明还没有加完；</p><p>由于相加的过程中，链表会出现一长一短的情况，所以在其中一个链表遍历完成之后，他的next就为空了，没有val值</p><p>我们可以将后续空的链表的值默认为0，这样在相加的时候就不会对后续没有遍历完的链表产生影响</p><p>所以对于t1，t2两个链表而言，他们的当前节点值是多少，可以由如下判断：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int x = (t1!=null)?t1.val:0;</span><br><span class="line">int y = (t2!=null)?t2.val:0;</span><br></pre></td></tr></table></figure><p>之后当前的和为<code>sum = (x+y+carry);</code></p><p><strong>判断进位</strong>：进位是多少可以由<code>sum/10</code>得到</p><p><strong>存储节点</strong>：每个节点只能存储1位数字，多出的部分成为进位，所以<code>sum=sum%10</code>，利用哑结点的后一位建立一个新的节点<code>t3.next = new ListNode(sum);</code></p><p><strong>顺序移动</strong>t1，t2，t3，其中当t1，t2为空的时候就不再需要移动了，只需要下次用0相加即可</p><p><strong>新增进位节点</strong>：如果最后遍历完毕仍然有进位，那么尾节点就是最后以进位为值的节点<code>t3.next = new ListNode(carry)</code></p><p><strong>最后</strong>返回哑结点的next就是头节点</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        ListNode t1 = l1;</span><br><span class="line">        ListNode t2 = l2;</span><br><span class="line">        ListNode l3 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode t3 = l3;</span><br><span class="line">        <span class="keyword">while</span>(t1!=<span class="keyword">null</span>||t2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = (t1!=<span class="keyword">null</span>)?t1.val:<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> y = (t2!=<span class="keyword">null</span>)?t2.val:<span class="number">0</span>;</span><br><span class="line">            sum = (x+y+carry);</span><br><span class="line">            carry = sum/<span class="number">10</span>;</span><br><span class="line">            sum = sum%<span class="number">10</span>;</span><br><span class="line">            t3.next = <span class="keyword">new</span> ListNode(sum);</span><br><span class="line">            <span class="keyword">if</span>(t1!=<span class="keyword">null</span>) t1 = t1.next;</span><br><span class="line">            <span class="keyword">if</span>(t2!=<span class="keyword">null</span>) t2 = t2.next;</span><br><span class="line">            t3 = t3.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry&gt;<span class="number">0</span>) t3.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        <span class="keyword">return</span> l3.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      两数相加
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://benym.cn/tags/LeetCode/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="链表" scheme="http://benym.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-1-两数之和</title>
    <link href="http://benym.cn/2020/06/16/LeetCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://benym.cn/2020/06/16/LeetCode-1-两数之和/</id>
    <published>2020-06-16T01:30:40.000Z</published>
    <updated>2020-06-16T02:01:39.591Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-1-两数之和"><a href="#LeetCode-1-两数之和" class="headerlink" title="LeetCode-1-两数之和"></a>LeetCode-1-两数之和</h2><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p> <a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>方法1、</strong>暴力破解：</p><p>暴力破解就是固定一个往后面挨个找，时间上比较耗时</p><p><strong>方法2、</strong>哈希表：</p><p>暴力破解比较耗时，那么有没有更快的方法，比如一次遍历搞定？</p><p>通过思考可以发现，数字固定一个再往后面找，这种方法不变的是数字，变化的是数字加和的顺序</p><p>把数字全部存储起来，并得到target和当前数字的差值，如果这个差值在存储的数字里面，就说明和为target找到了，返回对应下标即可。</p><p>于是可以利用hash表存储对应的数字和下标，按照这个思路实现，一次遍历就可以完成target下标和的寻找</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span>||nums==<span class="keyword">null</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">                sum = nums[i]+nums[j];</span><br><span class="line">                <span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java代码2"><a href="#Java代码2" class="headerlink" title="Java代码2"></a>Java代码2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span>||nums==<span class="keyword">null</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> out = target-nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(out))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(out),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      两数之和
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="LeetCode" scheme="http://benym.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-107-二叉树的层次遍历2</title>
    <link href="http://benym.cn/2020/06/11/LeetCode-107-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%862/"/>
    <id>http://benym.cn/2020/06/11/LeetCode-107-二叉树的层次遍历2/</id>
    <published>2020-06-11T12:19:38.000Z</published>
    <updated>2020-06-11T12:48:25.499Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-107-二叉树的层次遍历2"><a href="#LeetCode-107-二叉树的层次遍历2" class="headerlink" title="LeetCode-107-二叉树的层次遍历2"></a>LeetCode-107-二叉树的层次遍历2</h2><p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><a id="more"></a><p><strong>示例 1:</strong></p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回其自底向上的层次遍历为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>BFS层序遍历+头插法：</strong></p><p>涉及到要加入数值的，不太好用递归的方法，采用迭代的方法更容易一点</p><p>使用queue队列进行层序遍历，每次弹出一个层的节点就将它加入到layer中，一层遍历完了之后</p><p>再将一层的结果加入到res的头部，最后返回回来的就是按层倒序的结果</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            List&lt;Integer&gt; layer = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                TreeNode temp = queue.poll();</span><br><span class="line">                layer.add(temp.val);</span><br><span class="line">                <span class="keyword">if</span>(temp.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(temp.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(temp.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(<span class="number">0</span>,layer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      二叉树的层次遍历2
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="树" scheme="http://benym.cn/tags/%E6%A0%91/"/>
    
      <category term="BFS" scheme="http://benym.cn/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-104-二叉树的最大深度</title>
    <link href="http://benym.cn/2020/06/11/LeetCode-104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    <id>http://benym.cn/2020/06/11/LeetCode-104-二叉树的最大深度/</id>
    <published>2020-06-11T11:38:36.000Z</published>
    <updated>2020-06-11T12:18:28.746Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-104-二叉树的最大深度"><a href="#LeetCode-104-二叉树的最大深度" class="headerlink" title="LeetCode-104-二叉树的最大深度"></a>LeetCode-104-二叉树的最大深度</h2><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><a id="more"></a><p><strong>示例 1:</strong></p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>方法1、DFS递归：</strong></p><p>特例：root为空直接返回0</p><p>DFS左子树深度，DFS右子树深度，树的深度=Max(左子树，右子树)+root节点</p><p><strong>方法2、Queue迭代：</strong></p><p>利用层序遍历的思想，一层一层遍历，每过一层深度+1</p><p>利用一个先进先出的Queue队列，先将root节点加入其中，当queue不为空的时候开始遍历</p><p>深度+1，弹出队列头部，判断头部的左右节点是否为空，不为空则加入其中</p><p>对于一层的节点，节点数为queue.size()，对于queue中的每个节点都需要进行左右节点的判断</p><p>当一层遍历完毕时，深度就+1</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = maxDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java代码2-迭代Queue"><a href="#Java代码2-迭代Queue" class="headerlink" title="Java代码2(迭代Queue)"></a>Java代码2(迭代Queue)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">int</span> depth=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                TreeNode temp = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(temp.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(temp.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(temp.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      二叉树的最大深度
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="树" scheme="http://benym.cn/tags/%E6%A0%91/"/>
    
      <category term="DFS" scheme="http://benym.cn/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-1367-二叉树中的列表</title>
    <link href="http://benym.cn/2020/06/11/LeetCode-1367-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8/"/>
    <id>http://benym.cn/2020/06/11/LeetCode-1367-二叉树中的列表/</id>
    <published>2020-06-11T08:38:13.000Z</published>
    <updated>2020-06-11T11:35:38.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-1367-二叉树中的列表"><a href="#LeetCode-1367-二叉树中的列表" class="headerlink" title="LeetCode-1367-二叉树中的列表"></a>LeetCode-1367-二叉树中的列表</h2><p>给你一棵以 root 为根的二叉树和一个 head 为第一个节点的链表。</p><p>如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以 head 为首的链表中每个节点的值，那么请你返回 True ，否则返回 False 。</p><p>一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]</span><br><span class="line">输出：true</span><br><span class="line">解释：树中蓝色的节点构成了与链表对应的子路径。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p> <strong>示例3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]</span><br><span class="line">输出：false</span><br><span class="line">解释：二叉树中不存在一一对应链表的路径。</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li>二叉树和链表中的每个节点的值都满足 1 &lt;= node.val &lt;= 100 。</li><li>链表包含的节点数目在 1 到 100 之间。</li><li>二叉树包含的节点数目在 1 到 2500 之间。</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>DFS递归：</strong></p><p>根据题意知道，head的长度&lt;=root</p><p>我们可以设计一个递归函数，如果head==null说明匹配完成，返回true，如果root==null则说明找完了也没有匹配上</p><p>首先开启root节点的递归，判断开始的路径是否和head匹配，如果匹配则进一步看是这个节点的左子树匹配？还是这个节点的右子树匹配。任意一个子树匹配成功则算匹配成功。</p><p>如果root节点匹配失败，那么需要看root节点的左子树或者root节点的右子树是否能够匹配，分别开启DFS遍历，左右子树应该和root节点进行一样的匹配，同样需要看左子节点的左右节点和右子节点的左右节点到底是哪一个匹配的</p><p>当根节点或者左右子树任意一个匹配成功，则说明包含路径，即<code>dfs(head,root)||isSubPath(head,root.left)||isSubPath(head,root.right)</code></p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubPath</span><span class="params">(ListNode head, TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 先判断当前的节点，如果不对，就看看左子树和右子树</span></span><br><span class="line">        <span class="keyword">return</span> dfs(head,root)||isSubPath(head,root.left)||isSubPath(head,root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(ListNode head,TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 如果链表没了，那就说明匹配完了</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 如果链表没完，树走完了，那就是没匹配上</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 如果值不同，那肯定也是没匹配上</span></span><br><span class="line">        <span class="keyword">if</span>(head.val!=root.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 如果值相同，就继续看看左边右边是不是有相同的</span></span><br><span class="line">        <span class="keyword">return</span> dfs(head.next,root.left)||dfs(head.next,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      二叉树中的列表
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="树" scheme="http://benym.cn/tags/%E6%A0%91/"/>
    
      <category term="DFS" scheme="http://benym.cn/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-143-重排链表</title>
    <link href="http://benym.cn/2020/06/10/LeetCode-143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/"/>
    <id>http://benym.cn/2020/06/10/LeetCode-143-重排链表/</id>
    <published>2020-06-10T12:33:33.000Z</published>
    <updated>2020-06-11T08:28:34.995Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-143-重排链表"><a href="#LeetCode-143-重排链表" class="headerlink" title="LeetCode-143-重排链表"></a>LeetCode-143-重排链表</h2><p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，<br>将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p> <a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>方法1、存储+双指针：</strong></p><p>用一个线性表存储所有的链表元素，之后用2个指针，分别获得链表的头尾</p><p>按照规律对于1，2，3，4这样的链表例子</p><p>1之后是4，4之后是2，2之后是3</p><p>初始化头尾指针，改变头部指针的指向到尾部，并使i指向下一位</p><p>即<code>list.get(i).next = list.get(j);</code>和<code>i++</code></p><p>改变尾部指针指向到原本头部的下一位，由于上面已经<code>i++</code>，此时线性表的i就是上一次i的下一位</p><p>所以<code>list.get(j).next = list.get(i);</code>，之后<code>j--</code></p><p>直到i==j时跳出循环，此时i仍然与原来的链表相连，将i.next=null完成链表构建</p><p><strong>方法2、拆分+翻转+拼接：</strong></p><p>这个解法复习的内容挺多的，按照题目规律，重排链表可以分为如下3个步骤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6</span><br><span class="line">第一步，将链表平均分成两半</span><br><span class="line">1 -&gt; 2 -&gt; 3</span><br><span class="line">4 -&gt; 5 -&gt; 6</span><br><span class="line">    </span><br><span class="line">第二步，将第二个链表逆序</span><br><span class="line">1 -&gt; 2 -&gt; 3</span><br><span class="line">6 -&gt; 5 -&gt; 4</span><br><span class="line">    </span><br><span class="line">第三步，依次连接两个链表</span><br><span class="line">1 -&gt; 6 -&gt; 2 -&gt; 5 -&gt; 3 -&gt; 4</span><br></pre></td></tr></table></figure><p>如何拆分链表，最重要的是找到拆分的中点</p><p>对于偶数链表，拆分的中点在边界左边，对于奇数链表，中点就是中间的那个</p><p>可以利用<strong>快慢指针</strong>来寻找中点，一个指针走2步，一个指针走1步，当快指针走到链表尾部的时候，慢指针的位置就是拆分的中点，由于奇数和偶数拆分点不一样，所以<code>ListNode newHead = slow.next;</code>和<code>slow.next = null;</code>在找到边界点之后，始终后移1位，这样保证了偶数情况下，拆分点始终是第二个链表的头部</p><p>但是对于奇数情况，则会让第一个链表始终比第二个链表多一个数字，这种情况在合并的时候进行处理。</p><p>链表的逆序思想和<a href="/2020/04/19/LeetCode-面试题24-反转链表/" title="LeetCode-面试题24-反转链表">LeetCode-面试题24-反转链表</a>相同</p><p>链表的合并思想和<a href="/2020/04/19/LeetCode-面试题25-合并两个排序的链表/" title="LeetCode-面试题25-合并两个排序的链表">LeetCode-面试题25-合并两个排序的链表</a>大致相同</p><p>稍微有点区别的地方是这里不是按照值进行合并</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">对于</span><br><span class="line">slow  1 -&gt; 2 -&gt; 3</span><br><span class="line">fast  4 -&gt; 5</span><br><span class="line">而言，应该先存储slow和fast的next节点</span><br><span class="line">之后将slow的next变为fast，即1 -&gt; 4</span><br><span class="line">fast的next = 刚才存储的slow.next，即4 -&gt; 2</span><br><span class="line">接下来移动1位slow和fast指针，即slow = 刚才存储的slow.next，fast = 刚才存储的fast.next</span><br></pre></td></tr></table></figure><p>而此时的第一个链表由于始终比第二个链表长，所以判断空的条件为<code>slow!=null&amp;&amp;fast!=null</code>，当满足此条件时，才会进行V字型拼接</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存到 list 中去</span></span><br><span class="line">        List&lt;ListNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            list.add(head);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//头尾指针依次取元素</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = list.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            list.get(i).next = list.get(j);</span><br><span class="line">            i++;</span><br><span class="line">            <span class="comment">//偶数个节点的情况，会提前相遇</span></span><br><span class="line">            <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            list.get(j).next = list.get(i);</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        list.get(i).next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java代码2"><a href="#Java代码2" class="headerlink" title="Java代码2"></a>Java代码2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>&amp;&amp;fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode newHead = slow.next;</span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line">        fast = reversList(newHead);</span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span>(slow!=<span class="keyword">null</span>&amp;&amp;fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode stemp = slow.next;</span><br><span class="line">            ListNode ftemp = fast.next;</span><br><span class="line">            slow.next = fast;</span><br><span class="line">            fast.next = stemp;</span><br><span class="line">            slow = stemp;</span><br><span class="line">            fast = ftemp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reversList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode temp = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      重排链表
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://benym.cn/tags/LeetCode/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="链表" scheme="http://benym.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-142-环形链表2</title>
    <link href="http://benym.cn/2020/06/10/LeetCode-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A82/"/>
    <id>http://benym.cn/2020/06/10/LeetCode-142-环形链表2/</id>
    <published>2020-06-10T08:43:09.000Z</published>
    <updated>2020-06-10T09:20:03.125Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-142-环形链表2"><a href="#LeetCode-142-环形链表2" class="headerlink" title="LeetCode-142-环形链表2"></a>LeetCode-142-环形链表2</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p>说明：不允许修改给定的链表。</p> <a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：tail connects to node index 1</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：tail connects to node index 0</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：no cycle</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p><strong>进阶：</strong><br>你是否可以不用额外空间解决此题？</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>相关链接：</strong></p><ul><li><a href="/2020/06/10/LeetCode-141-环形链表/" title="LeetCode-141-环形链表">LeetCode-141-环形链表</a></li><li><a href="/2020/06/10/LeetCode-面试题02.02-返回倒数第k个节点/" title="LeetCode-面试题02.02-返回倒数第k个节点">LeetCode-面试题02.02-返回倒数第k个节点</a></li></ul><p><strong>快慢指针+双指针：</strong></p><p>想要在环形链表中找到入环的第一个节点，首先要判断是否有环</p><p>在有环的前提下，如果能够计算出环内的节点有多少个，那么问题就变为同返回倒数第k个节点相似的问题</p><p>让其中一个指针先走n步，之后一个指针第一个指针走完n步之后开始走</p><p>两个指针继续移动1步，当第二个指针指向环的入口节点时，第一个指针已经绕了一圈回来到达了入口节点，此时第二个指针的位置就是入口</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode meetingNode = hasCycle(head);</span><br><span class="line">        <span class="keyword">if</span>(meetingNode==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">        ListNode temp = meetingNode;</span><br><span class="line">        <span class="keyword">while</span>(temp.next!=meetingNode)&#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode start = head;</span><br><span class="line">        temp = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(temp!=start)&#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            start = start.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode slow = head.next;</span><br><span class="line">        <span class="keyword">if</span>(slow==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode fast = slow.next;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>&amp;&amp;slow!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast==slow) <span class="keyword">return</span> fast;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            <span class="keyword">if</span>(fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      环形链表2
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://benym.cn/tags/LeetCode/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="链表" scheme="http://benym.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-141-环形链表</title>
    <link href="http://benym.cn/2020/06/10/LeetCode-141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
    <id>http://benym.cn/2020/06/10/LeetCode-141-环形链表/</id>
    <published>2020-06-10T08:16:00.000Z</published>
    <updated>2020-06-10T08:39:28.579Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-141-环形链表"><a href="#LeetCode-141-环形链表" class="headerlink" title="LeetCode-141-环形链表"></a>LeetCode-141-环形链表</h2><p>给定一个链表，判断链表中是否有环。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p> <a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p><strong>进阶：</strong></p><p>你能用 <em>O(1)</em>（即，常量）内存解决此问题吗？</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>快慢指针：</strong></p><p>要找到一个链表有没有环，可以通过设置快慢指针的方式</p><p>如果快的指针赶上了慢的指针说明链表中有环，如果不存在环那么其中一个指针必定会等于null</p><p>初始化慢指针slow=head.next，如果他等于null说明链表只有一个节点，不存在环，返回false</p><p>初始化快指针fast=slow.next，当快慢指针都不为空的时候，判断是否相等，相等则有环</p><p>如果不相等，则移动慢指针1步，移动快指针2步，但快指针移动一步之后需要判断是否为null，不为null才能移动第二步，否则没有环，跳出循环返回false</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        ListNode slow = head.next;</span><br><span class="line">        <span class="keyword">if</span>(slow==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        ListNode fast = slow.next;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>&amp;&amp;slow!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast==slow) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            <span class="keyword">if</span>(fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      环形链表
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="LeetCode" scheme="http://benym.cn/tags/LeetCode/"/>
    
      <category term="链表" scheme="http://benym.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-面试题02.02-返回倒数第k个节点</title>
    <link href="http://benym.cn/2020/06/10/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9802.02-%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>http://benym.cn/2020/06/10/LeetCode-面试题02.02-返回倒数第k个节点/</id>
    <published>2020-06-10T07:28:54.000Z</published>
    <updated>2020-06-10T07:58:20.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-面试题02-02-返回倒数第k个节点"><a href="#LeetCode-面试题02-02-返回倒数第k个节点" class="headerlink" title="LeetCode-面试题02.02-返回倒数第k个节点"></a>LeetCode-面试题02.02-返回倒数第k个节点</h2><p>实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。</p><p><strong>注意：</strong>本题相对原题稍作改动</p> <a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： 1-&gt;2-&gt;3-&gt;4-&gt;5 和 k = 2</span><br><span class="line">输出： 4</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>给定的 <em>k</em> 保证是有效的。</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>双指针：</strong></p><p>根据链表的性质，要获得倒数第k个节点，就等于求n-(k-1)个节点，</p><p>但这需要知道链表的长度，意味着需要两次遍历链表。</p><p>换一种想法，想要知道倒数第k个节点，那么就让一个指针先走k-1步，另外一个指针始终和第一个指针保持k-1的距离</p><p>当第一个指针到达链表结尾时，第二个指针则正好在n-(k-1)的位置，只需要一次遍历即可完成</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthToLast</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode low = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        low = head;</span><br><span class="line">        <span class="keyword">while</span>(fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            low = low.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      返回倒数第k个节点
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="LeetCode" scheme="http://benym.cn/tags/LeetCode/"/>
    
      <category term="链表" scheme="http://benym.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-328-奇偶链表</title>
    <link href="http://benym.cn/2020/06/10/LeetCode-328-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/"/>
    <id>http://benym.cn/2020/06/10/LeetCode-328-奇偶链表/</id>
    <published>2020-06-10T07:14:20.000Z</published>
    <updated>2020-06-10T07:26:40.630Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-328-奇偶链表"><a href="#LeetCode-328-奇偶链表" class="headerlink" title="LeetCode-328-奇偶链表"></a>LeetCode-328-奇偶链表</h2><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p><p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p> <a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL </span><br><span class="line">输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>应当保持奇数节点和偶数节点的相对顺序。</li><li>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>双指针：</strong></p><p>一个指针指向奇数节点，一个指针指向偶数节点</p><p>间隔遍历，奇数指针只能指向奇数节点，偶数指针只能指向偶数节点</p><p>对于链表长度为奇数时，奇数指针one能够指向之后一个数字，此时偶数指针two==null，作为循环结束条件</p><p>对于链表长度为偶数时，奇数指针one会在之前遍历完毕奇数位置，此时偶数指针two.next==null，作为循环结束条件</p><p>最后进行奇偶链表拼接，one.next=tempTwo</p><p>注意：间隔遍历很重要，如果按照顺序遍历，会出现one和two指针在奇偶长度的指向不一样，即one和two在快到链表末尾时候，可能指向的奇数链表也可能指向的偶数链表，这样就无法进行最后指针拼接的判断了，<strong>间隔遍历保证了指针的奇偶性</strong></p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode one = head;</span><br><span class="line">        ListNode two = head.next;</span><br><span class="line">        ListNode tempTwo = two;</span><br><span class="line">        <span class="keyword">while</span>(two!=<span class="keyword">null</span>&amp;&amp;two.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            one.next = two.next;</span><br><span class="line">            one = one.next;</span><br><span class="line">            two.next = one.next;</span><br><span class="line">            two = two.next;</span><br><span class="line">        &#125;</span><br><span class="line">        one.next = tempTwo;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      奇偶链表
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://benym.cn/tags/LeetCode/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="链表" scheme="http://benym.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-300-最长上升子序列</title>
    <link href="http://benym.cn/2020/06/09/LeetCode-300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://benym.cn/2020/06/09/LeetCode-300-最长上升子序列/</id>
    <published>2020-06-09T12:02:29.000Z</published>
    <updated>2020-06-10T05:35:46.986Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-300-最长上升子序列"><a href="#LeetCode-300-最长上升子序列" class="headerlink" title="LeetCode-300-最长上升子序列"></a>LeetCode-300-最长上升子序列</h2><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p> <a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [10,9,2,5,3,7,101,18]</span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</span><br></pre></td></tr></table></figure><p>说明:</p><p>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。<br>你算法的时间复杂度应该为 O(n2) 。<br>进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>动态规划：</strong></p><p>子序列严格上升，不存在中间数字相等的情况，且不要求序列连续</p><p>状态定义为：第i个数字为结尾的最长上升子序列的长度，自身也需要统计在其中，每个位置的初始化长度为1</p><p>状态转移方程：遍历到索引是i的数字的时候，需要看i前面的i-1个数字是否小于当前的nums[i]的值，如果小于则可以构成一个更长的子序列，但i-1个数字中比nums[i]小的数字有多个，所以dp[i]位置的子序列长度，应该是前面i-1个数字的<strong>最长</strong>的那个加上1，即<code>dp[i] = Math.max(dp[j]+1,dp[i])</code></p><p>外层循环到len，控制dp[i]每个位置的初始化为1</p><p>内层循环到i，查看从数组开头到i-1个数，最长的子序列分别是多少</p><p>最后dp数组中的最大值，就是最长上升子序列的长度</p><p><strong>贪心+二分查找：</strong></p><p>实在是想不到这种解法….<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-2/" target="_blank" rel="noopener">原题题解出处</a></p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len&lt;<span class="number">2</span>) <span class="keyword">return</span> len;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            dp[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 看前面i-1个数字</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&lt;nums[i])&#123; <span class="comment">//可以构成更长的子序列，所以dp[j]+1</span></span><br><span class="line">                    dp[i] = Math.max(dp[j]+<span class="number">1</span>,dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(res&lt;dp[i]) res=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java代码2"><a href="#Java代码2" class="headerlink" title="Java代码2"></a>Java代码2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len&lt;<span class="number">2</span>) <span class="keyword">return</span> len;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> maxL = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> high = maxL;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = low+(high-low)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(dp[mid]&lt;num)&#123;</span><br><span class="line">                    low = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    high = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[low]=num;</span><br><span class="line">            <span class="keyword">if</span>(low==maxL)</span><br><span class="line">                maxL++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      最长上升子序列
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="DP" scheme="http://benym.cn/tags/DP/"/>
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://benym.cn/tags/LeetCode/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-47-全排列2</title>
    <link href="http://benym.cn/2020/06/09/LeetCode-47-%E5%85%A8%E6%8E%92%E5%88%972/"/>
    <id>http://benym.cn/2020/06/09/LeetCode-47-全排列2/</id>
    <published>2020-06-09T10:33:18.000Z</published>
    <updated>2020-06-09T11:32:13.769Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-47-全排列2"><a href="#LeetCode-47-全排列2" class="headerlink" title="LeetCode-47-全排列2"></a>LeetCode-47-全排列2</h2><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p> <a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,1,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,1,2],</span><br><span class="line">  [1,2,1],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>回溯+剪枝：</strong></p><p>基于46题<a href="/2020/06/08/LeetCode-46-全排列/" title="LeetCode-46-全排列">LeetCode-46-全排列</a></p><p>对于刚开始就有重复的数字序列，首先先对数组排序，<strong>保证数据有序</strong></p><p>之后构建递归树，因为返回的结果中不能包含重复的排列，所以在如数组1、1、2的排列过程中</p><p>选择第一个1开头和选择第二个1开头的序列将会重复，所以说需要对第二个1开头的所有序列进行剪枝</p><p>对应条件为nums[i]==num[i-1]，即第二个1等于第一个1时</p><p>同时需要考虑仅在第一个1的排列选择完毕之后回退到空path的时候，才进行第二个1的剪枝。此时判断的依据是上一个nums[i-1]刚刚在回溯的过程中被撤销选择。</p><p>对于其他可能重复的位置，如2，1，1。开头2、1都相同于是后续的排列也是重复的，上述的剪枝方法同样适用</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(nums, len, <span class="number">0</span>, path, visited, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> len,<span class="keyword">int</span> depth,List&lt;Integer&gt; path,<span class="keyword">boolean</span>[] visited,List&lt;List&lt;Integer&gt;&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len==depth)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                <span class="comment">// visited[i-1]是因为nums[i-1]在回退的过程中刚刚被撤销选择</span></span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>]&amp;&amp;visited[i-<span class="number">1</span>]==<span class="keyword">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">                visited[i] = <span class="keyword">true</span>;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                dfs(nums,len,depth+<span class="number">1</span>,path,visited,res);</span><br><span class="line">                visited[i] = <span class="keyword">false</span>;</span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      全排列2
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://benym.cn/tags/LeetCode/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="回溯" scheme="http://benym.cn/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-46-全排列</title>
    <link href="http://benym.cn/2020/06/08/LeetCode-46-%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <id>http://benym.cn/2020/06/08/LeetCode-46-全排列/</id>
    <published>2020-06-08T14:18:43.000Z</published>
    <updated>2020-06-09T10:32:14.803Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-46-全排列"><a href="#LeetCode-46-全排列" class="headerlink" title="LeetCode-46-全排列"></a>LeetCode-46-全排列</h2><p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p> <a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>方法1、回溯：</p><p>回溯问题经常会涉及到一个状态数组</p><p>基本的思路想象成一个树的问题，是从一个数字(外层循环分别固定1，2，3数字)出发，往树的更深处遍历</p><ul><li>如果当前位置没有访问过，就将这个数加入到路径中，之后开启更深一层的遍历</li><li>如果路径的长度等于了初始的数组长度，说明找到了一个可能的排列</li><li>如果走到最后没有找到这样的排列路径，则说明此路不同进行回溯操作，将访问的位置状态还原，并同时移除还原路上已经添加的数字</li></ul><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(nums,len,<span class="number">0</span>,path,visited,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> len, <span class="keyword">int</span> depth,</span></span></span><br><span class="line"><span class="function"><span class="params">                     List&lt;Integer&gt; path, <span class="keyword">boolean</span>[] visited,</span></span></span><br><span class="line"><span class="function"><span class="params">                     List&lt;List&lt;Integer&gt;&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len==depth)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                visited[i] = <span class="keyword">true</span>;</span><br><span class="line">                dfs(nums,len,depth+<span class="number">1</span>,path,visited,res);</span><br><span class="line">                visited[i] = <span class="keyword">false</span>;</span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      全排列
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://benym.cn/tags/LeetCode/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="回溯" scheme="http://benym.cn/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
</feed>
