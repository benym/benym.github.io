<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ming.Y</title>
  
  <subtitle>Chances are for people who are prepared</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://benym.cn/"/>
  <updated>2020-05-18T12:25:28.187Z</updated>
  <id>http://benym.cn/</id>
  
  <author>
    <name>BenY</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode-面试题56-2-数组中数字出现的次数2</title>
    <link href="http://benym.cn/2020/05/18/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9856-2-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B02/"/>
    <id>http://benym.cn/2020/05/18/LeetCode-面试题56-2-数组中数字出现的次数2/</id>
    <published>2020-05-18T09:13:05.000Z</published>
    <updated>2020-05-18T12:25:28.187Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-面试题56-2-数组中数字出现的次数2"><a href="#LeetCode-面试题56-2-数组中数字出现的次数2" class="headerlink" title="LeetCode-面试题56-2-数组中数字出现的次数2"></a>LeetCode-面试题56-2-数组中数字出现的次数2</h2><p>在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p> <a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,4,3,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [9,1,7,9,7,9,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><ul><li><p><strong>限制：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10000</code></li><li><code>1 &lt;= nums[i] &lt; 2^31</code></li></ul></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>方法1、异或运算(单1为1，其余0)：</p><p>先对所有数字的各个位求和，求和之后的数字，能够被3整除的，则该位为0，不能够被整除的，则该位为1，之后就能够通过2进制求出对应的数字</p><p>方法2、字典：</p><p>字典方法没啥好说的，遇到没在字典的加入，在字典就+1，最后取value为1的key就是了</p><p>方法3、数组：</p><p>先给数组排序，排序之后判断当前位和后面2位是否相等，如果相等则跳过这3位，i+3</p><p>如果不相等，则说明当前为就是要找的数字</p><p>如果前面都没有找到，则最后一位必定是要找的数字</p><h3 id="Java代码1"><a href="#Java代码1" class="headerlink" title="Java代码1"></a>Java代码1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] bitSum = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>]; <span class="comment">// 最高2^31次方数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> bitMask = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 累加各个位置的二进制表示</span></span><br><span class="line">            <span class="comment">// 这里从数组末尾开始，对应二进制最小位</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">31</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">int</span> bit = nums[i]&amp;bitMask;</span><br><span class="line">                <span class="keyword">if</span>(bit!=<span class="number">0</span>)</span><br><span class="line">                    bitSum[j]+=<span class="number">1</span>;</span><br><span class="line">                    bitMask&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 从数组0位开始，对应于数字的高位，当遍历到余数为1时，res仅为1，比如数字8的二进制为0100</span></span><br><span class="line">        <span class="comment">// 从左到右遍历，当遍历到数字1时</span></span><br><span class="line">        <span class="comment">// 此时res为1，想要从1变成8，需要向左移动2位，而for循环剩下的次数就是需要&lt;&lt;左移的次数，最后得到res才是正确的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">            result = result&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            result+=bitSum[i]%<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">                dic[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[i] +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> dic:</span><br><span class="line">            <span class="keyword">if</span> dic[i]==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="Java代码2"><a href="#Java代码2" class="headerlink" title="Java代码2"></a>Java代码2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length-<span class="number">3</span>;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==nums[i+<span class="number">1</span>]&amp;&amp;nums[i+<span class="number">1</span>]==nums[i+<span class="number">2</span>])</span><br><span class="line">                i+=<span class="number">3</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      数组中数字出现的次数2
    
    </summary>
    
      <category term="剑指Offer" scheme="http://benym.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="Python" scheme="http://benym.cn/tags/Python/"/>
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="剑指Offer" scheme="http://benym.cn/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-面试题56-1-数组中数字出现的次数</title>
    <link href="http://benym.cn/2020/05/18/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9856-1-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B01/"/>
    <id>http://benym.cn/2020/05/18/LeetCode-面试题56-1-数组中数字出现的次数1/</id>
    <published>2020-05-18T08:06:08.000Z</published>
    <updated>2020-05-18T08:57:05.341Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-面试题56-1-数组中数字出现的次数"><a href="#LeetCode-面试题56-1-数组中数字出现的次数" class="headerlink" title="LeetCode-面试题56-1-数组中数字出现的次数"></a>LeetCode-面试题56-1-数组中数字出现的次数</h2><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p> <a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,10,4,1,4,3,3]</span><br><span class="line">输出：[2,10] 或 [10,2]</span><br></pre></td></tr></table></figure><ul><li><p><strong>限制：</strong></p><p><code>2 &lt;= nums.length &lt;= 10000</code></p></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>异或运算(单1为1，其余0)：</p><p>根据异或运算的特点，相同的数字会在异或的时候抵消了，不相同的数字，其不相同的位会被保留</p><p>如果数组中有2个数字是不相同的，所以对数组整体异或之后，剩下的数字肯定至少有一位为1</p><p>如果能够找到第一个为1的那一位，那么就能够通过判断这一位是否为1，而划分数组为2个子数组</p><p>这样问题就分解成了，分别寻找2个子数组中，只出现一次的数字</p><p>由于判断位的条件具有二分性，当判断出一个不相同的数字位为1时，另一个数字该位则不为1，于是划分的子数组中自然一个数组会包含一个不相同数字</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 数组整体异或</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)</span><br><span class="line">            temp^=i;</span><br><span class="line">        <span class="comment">// 初始化mask=1</span></span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 通过mask，判断第一次出现1的位数</span></span><br><span class="line">        <span class="keyword">while</span>((temp&amp;mask)==<span class="number">0</span>)&#123;</span><br><span class="line">            mask&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j:nums)&#123;</span><br><span class="line">            <span class="comment">// 通过判断1出现的位置和数组元素与运算结果是否为0，来二分数组</span></span><br><span class="line">            <span class="keyword">if</span>((j&amp;mask)==<span class="number">0</span>)&#123; <span class="comment">// 相同的数字会分在一起，但不同的数字会因此隔开</span></span><br><span class="line">                num1^=j;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                num2^=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;num1,num2&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      数组中数字出现的次数
    
    </summary>
    
      <category term="剑指Offer" scheme="http://benym.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="剑指Offer" scheme="http://benym.cn/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-面试题55-2-平衡二叉树</title>
    <link href="http://benym.cn/2020/05/18/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9855-2-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://benym.cn/2020/05/18/LeetCode-面试题55-2-平衡二叉树/</id>
    <published>2020-05-18T04:58:06.000Z</published>
    <updated>2020-05-18T08:08:01.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-面试题55-2-平衡二叉树"><a href="#LeetCode-面试题55-2-平衡二叉树" class="headerlink" title="LeetCode-面试题55-2-平衡二叉树"></a>LeetCode-面试题55-2-平衡二叉树</h2><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中<strong>任意节点</strong>的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p> <a id="more"></a><p><strong>示例1：</strong></p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回<code>true</code> 。</p><p><strong>示例 2:</strong></p><p>给定二叉树 <code>[1,2,2,3,3,null,null,4,4]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      1</span><br><span class="line">     / \</span><br><span class="line">    2   2</span><br><span class="line">   / \</span><br><span class="line">  3   3</span><br><span class="line"> / \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure><p>返回 <code>false</code> 。</p><ul><li><strong>限制：</strong><ol><li><code>1 &lt;= 树的结点个数 &lt;= 10000</code></li></ol></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>方法1、DFS分别求深度：</p><p>这种方法就是上一个题的延续了，但是由于需要对每一个节点求对应的左右子树的深度，会造成很多重复计算。这是一个简单的解法但是不是好的解法</p><p>方法2、后序遍历+剪枝：</p><p>这是一个从底至顶的解法，当节点的左右子树的深度差&lt;=1时，就返回当前子树的深度</p><p>当前子树的深度由max(left,right)+1计算得到，如果不满足深度差条件，则说明子树不平衡，直接返回-1</p><p>递归的终止条件是，当root为空，说明越过叶子节点，返回深度0</p><p>当左右子树的深度不平衡时，即left==-1||right==-1时，提前终止递归进行剪枝，返回-1</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> nleft = DFS(root.left);</span><br><span class="line">        <span class="keyword">int</span> nright = DFS(root.right);</span><br><span class="line">        <span class="keyword">int</span> n = Math.abs(nleft-nright);</span><br><span class="line">        <span class="keyword">if</span>(n&gt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isBalanced(root.left)&amp;&amp;isBalanced(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">DFS</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nleft = DFS(root.left);</span><br><span class="line">        <span class="keyword">int</span> nright = DFS(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(nleft,nright)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(root)!=<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self,root:TreeNode)</span>-&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.helper(root.left)</span><br><span class="line">        <span class="keyword">if</span> left==<span class="number">-1</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        right = self.helper(root.right)</span><br><span class="line">        <span class="keyword">if</span> right==<span class="number">-1</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> max(left,right)+<span class="number">1</span> <span class="keyword">if</span> abs(left-right)&lt;=<span class="number">1</span> <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      平衡二叉树
    
    </summary>
    
      <category term="剑指Offer" scheme="http://benym.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="树" scheme="http://benym.cn/tags/%E6%A0%91/"/>
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Python" scheme="http://benym.cn/tags/Python/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="DFS" scheme="http://benym.cn/tags/DFS/"/>
    
      <category term="剑指Offer" scheme="http://benym.cn/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-面试题55-1-二叉树的深度</title>
    <link href="http://benym.cn/2020/05/14/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9855-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/"/>
    <id>http://benym.cn/2020/05/14/LeetCode-面试题55-1-二叉树的深度/</id>
    <published>2020-05-14T10:54:51.000Z</published>
    <updated>2020-05-18T03:02:07.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-面试题55-1-二叉树的深度"><a href="#LeetCode-面试题55-1-二叉树的深度" class="headerlink" title="LeetCode-面试题55-1-二叉树的深度"></a>LeetCode-面试题55-1-二叉树的深度</h2><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p> <a id="more"></a><p><strong>示例1：</strong></p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p><ul><li><strong>提示：</strong><ol><li><code>节点总数 &lt;= 10000</code></li></ol></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>方法1、DFS：</p><p>既然要求树的深度自然少不了深度优先遍历，通过比较左子树的深度和右子树的深度判断最大深度，之后加上根节点</p><p>方法2、BFS：</p><p>层序遍历一般也就是广度优先遍历，在原本队列的实现基础上，对一个层进行循环约束即可，每遍历完一层，深度就+1</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nleft = maxDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> nright = maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(nleft,nright)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue , depth = [] , <span class="number">0</span></span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                temp = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> temp.left:</span><br><span class="line">                    queue.append(temp.left)</span><br><span class="line">                <span class="keyword">if</span> temp.right:</span><br><span class="line">                    queue.append(temp.right)</span><br><span class="line">            depth+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      二叉树的深度
    
    </summary>
    
      <category term="剑指Offer" scheme="http://benym.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="树" scheme="http://benym.cn/tags/%E6%A0%91/"/>
    
      <category term="BFS" scheme="http://benym.cn/tags/BFS/"/>
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Python" scheme="http://benym.cn/tags/Python/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="DFS" scheme="http://benym.cn/tags/DFS/"/>
    
      <category term="剑指Offer" scheme="http://benym.cn/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-145-二叉树的后序遍历</title>
    <link href="http://benym.cn/2020/05/13/LeetCode-145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://benym.cn/2020/05/13/LeetCode-145-二叉树的后序遍历/</id>
    <published>2020-05-13T07:05:04.000Z</published>
    <updated>2020-05-18T03:02:07.022Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-145-二叉树的后序遍历"><a href="#LeetCode-145-二叉树的后序遍历" class="headerlink" title="LeetCode-145-二叉树的后序遍历"></a>LeetCode-145-二叉树的后序遍历</h2><p>给定一个二叉树，返回它的 <em>后序</em> 遍历。</p><p>相关链接：</p><ol><li><a href="/2020/05/13/LeetCode-94-二叉树的中序遍历/" title="LeetCode-94-二叉树的中序遍历">LeetCode-94-二叉树的中序遍历</a></li><li><a href="/2020/05/13/LeetCode-144-二叉树的前序遍历/" title="LeetCode-144-二叉树的前序遍历">LeetCode-144-二叉树的前序遍历</a></li></ol><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [3,2,1]</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>二叉树的遍历问题都有2种解法，一种是递归，一种是迭代</p><p>递归：开启左子树递归，开启右子树递归，添加根节点</p><p>迭代：后序遍历的方式是左右根，前序遍历是根左右，如果用Stack来实现根左右，那么左边先加入就会后出，右边后加入会先出，于是看似是add(left)之后add(right)，实际上会先访问到right再访问left，从而实现前序遍历得到根右左，即后序遍历的倒序，之后将列表倒序就是后序遍历的结果</p><p>迭代模拟：严格按照后序遍历的左右根访问，代码整体与中序遍历很相似，但需要注意其中两个点。</p><p>思想来源于<a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/di-gui-die-dai-qu-qiao-san-chong-fang-fa-quan-jie-/" target="_blank" rel="noopener">这里</a></p><p>第一，stack.peek()只是取出栈顶元素，要和stack.pop()弹出栈顶元素区分开来；</p><p>第二，变量last用于保存当前栈顶所弹出的元素，判断 curr.right == last 是为了避免重复访问同一个元素而陷入死循环当中</p><h3 id="Java代码-递归"><a href="#Java代码-递归" class="headerlink" title="Java代码(递归)"></a>Java代码(递归)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        helper(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        helper(root.left);</span><br><span class="line">        helper(root.right);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java代码-迭代Stack"><a href="#Java代码-迭代Stack" class="headerlink" title="Java代码(迭代Stack)"></a>Java代码(迭代Stack)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;(); <span class="comment">// Stack实现根右左</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        stack.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode temp = stack.pop();</span><br><span class="line">            res.addFirst(temp.val); <span class="comment">// 添加到头部，实现倒序</span></span><br><span class="line">            <span class="keyword">if</span>(temp.left!=<span class="keyword">null</span>)</span><br><span class="line">                stack.add(temp.left);</span><br><span class="line">            <span class="keyword">if</span>(temp.right!=<span class="keyword">null</span>)</span><br><span class="line">                stack.add(temp.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java代码-迭代模拟"><a href="#Java代码-迭代模拟" class="headerlink" title="Java代码(迭代模拟)"></a>Java代码(迭代模拟)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode curr = root;</span><br><span class="line">        TreeNode last = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(curr);</span><br><span class="line">                curr = curr.left;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = stack.peek();</span><br><span class="line">            <span class="keyword">if</span> (curr.right == <span class="keyword">null</span> || curr.right == last) &#123;</span><br><span class="line">                res.add(curr.val);</span><br><span class="line">                stack.pop();</span><br><span class="line">                last = curr;</span><br><span class="line">                curr = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr = curr.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      二叉树的后序遍历
    
    </summary>
    
      <category term="树" scheme="http://benym.cn/categories/%E6%A0%91/"/>
    
    
      <category term="树" scheme="http://benym.cn/tags/%E6%A0%91/"/>
    
      <category term="BFS" scheme="http://benym.cn/tags/BFS/"/>
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Hard" scheme="http://benym.cn/tags/Hard/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-144-二叉树的前序遍历</title>
    <link href="http://benym.cn/2020/05/13/LeetCode-144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://benym.cn/2020/05/13/LeetCode-144-二叉树的前序遍历/</id>
    <published>2020-05-13T05:01:06.000Z</published>
    <updated>2020-05-18T03:02:07.022Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-144-二叉树的前序遍历"><a href="#LeetCode-144-二叉树的前序遍历" class="headerlink" title="LeetCode-144-二叉树的前序遍历"></a>LeetCode-144-二叉树的前序遍历</h2><p>给定一个二叉树，返回它的 <em>前序</em> 遍历。</p><p>相关链接：</p><ol><li><a href="/2020/05/13/LeetCode-94-二叉树的中序遍历/" title="LeetCode-94-二叉树的中序遍历">LeetCode-94-二叉树的中序遍历</a></li><li><a href="/2020/05/13/LeetCode-145-二叉树的后序遍历/" title="LeetCode-145-二叉树的后序遍历">LeetCode-145-二叉树的后序遍历</a></li></ol><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">输出: [1,2,3]</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>二叉树的遍历问题都有2种解法，一种是递归，一种是迭代</p><p>递归：添加根节点，开启左子树递归，开启右子树递归</p><p>迭代：前序遍历一般等同于BFS，一般用Queue来实现，先进先出，层序遍历即可。</p><p>不过奇怪的是这个题跑不过测试用例…….只能换成栈来做，也就是调整一下加入顺序，需要先添加右子树，再添加左子树，由于pop是后进先出，所以弹出的顺序变为了先弹出左子树，再是右子树，变成了Queue的先进先出的样子</p><h3 id="Java代码-递归"><a href="#Java代码-递归" class="headerlink" title="Java代码(递归)"></a>Java代码(递归)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        BFS(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            BFS(root.left);</span><br><span class="line">            BFS(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java代码-迭代Queue"><a href="#Java代码-迭代Queue" class="headerlink" title="Java代码(迭代Queue)"></a>Java代码(迭代Queue)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode temp = queue.poll();</span><br><span class="line">            res.add(temp.val);</span><br><span class="line">            <span class="keyword">if</span>(temp.left!=<span class="keyword">null</span>)</span><br><span class="line">                queue.add(temp.left);</span><br><span class="line">            <span class="keyword">if</span>(temp.right!=<span class="keyword">null</span>)</span><br><span class="line">                queue.add(temp.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java代码-迭代Stack"><a href="#Java代码-迭代Stack" class="headerlink" title="Java代码(迭代Stack)"></a>Java代码(迭代Stack)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode temp = stack.pop();</span><br><span class="line">            res.add(temp.val);</span><br><span class="line">            <span class="keyword">if</span>(temp.right!=<span class="keyword">null</span>)</span><br><span class="line">                stack.add(temp.right);</span><br><span class="line">            <span class="keyword">if</span>(temp.left!=<span class="keyword">null</span>)</span><br><span class="line">                stack.add(temp.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      二叉树的前序遍历
    
    </summary>
    
      <category term="树" scheme="http://benym.cn/categories/%E6%A0%91/"/>
    
    
      <category term="树" scheme="http://benym.cn/tags/%E6%A0%91/"/>
    
      <category term="BFS" scheme="http://benym.cn/tags/BFS/"/>
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-94-二叉树的中序遍历</title>
    <link href="http://benym.cn/2020/05/13/LeetCode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://benym.cn/2020/05/13/LeetCode-94-二叉树的中序遍历/</id>
    <published>2020-05-13T03:01:06.000Z</published>
    <updated>2020-05-18T03:02:07.030Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-94-二叉树的中序遍历"><a href="#LeetCode-94-二叉树的中序遍历" class="headerlink" title="LeetCode-94-二叉树的中序遍历"></a>LeetCode-94-二叉树的中序遍历</h2><p>给定一个二叉树，返回它的<em>中序</em> 遍历。</p><p>相关链接：</p><ol><li><a href="/2020/05/13/LeetCode-144-二叉树的前序遍历/" title="LeetCode-144-二叉树的前序遍历">LeetCode-144-二叉树的前序遍历</a></li><li><a href="/2020/05/13/LeetCode-145-二叉树的后序遍历/" title="LeetCode-145-二叉树的后序遍历">LeetCode-145-二叉树的后序遍历</a></li></ol><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">输出: [1,3,2]</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>二叉树的遍历问题都有2种解法，一种是递归，一种是迭代</p><p>递归：开启左子树递归，添加根节点，开启右子树递归</p><p>迭代：中序遍历一般等同于DFS，用Stack来实现，后进先出。迭代是先把左子树全部添加进Stack中，然后弹出一个尾部，获得对应的val之后遍历右子树，在添加左子树的时候同时也添加了根节点，所以pop弹出时再添加val实际上会对左子树和左子树的根节点进行操作</p><h3 id="Java代码-递归"><a href="#Java代码-递归" class="headerlink" title="Java代码(递归)"></a>Java代码(递归)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        DFS(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        DFS(root.left);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        DFS(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java代码-迭代"><a href="#Java代码-迭代" class="headerlink" title="Java代码(迭代)"></a>Java代码(迭代)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span>||!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            res.add(node.val);</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      二叉树的中序遍历
    
    </summary>
    
      <category term="树" scheme="http://benym.cn/categories/%E6%A0%91/"/>
    
    
      <category term="树" scheme="http://benym.cn/tags/%E6%A0%91/"/>
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="DFS" scheme="http://benym.cn/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-面试题54-二叉搜索树的第k大节点</title>
    <link href="http://benym.cn/2020/05/12/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9854-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/"/>
    <id>http://benym.cn/2020/05/12/LeetCode-面试题54-二叉搜索树的第k大节点/</id>
    <published>2020-05-12T08:34:23.000Z</published>
    <updated>2020-05-18T03:02:07.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-面试题54-二叉搜索树的第k大节点"><a href="#LeetCode-面试题54-二叉搜索树的第k大节点" class="headerlink" title="LeetCode-面试题54-二叉搜索树的第k大节点"></a>LeetCode-面试题54-二叉搜索树的第k大节点</h2><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p> <a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,1,4,null,2], k = 1</span><br><span class="line">   3</span><br><span class="line">  / \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [5,3,6,2,4,null,null,1], k = 3</span><br><span class="line">       5</span><br><span class="line">      / \</span><br><span class="line">     3   6</span><br><span class="line">    / \</span><br><span class="line">   2   4</span><br><span class="line">  /</span><br><span class="line"> 1</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><ul><li><p><strong>限制：</strong></p><p><code>1 ≤ k ≤ 二叉搜索树元素个数</code></p></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>方法1、中序遍历的倒序：</p><p>对于二叉搜索树，左节点总是比根节点小，右节点总是比根节点大</p><p>观察可以得知，中序遍历后得到的序列是递增的，求第K个大的节点可以转化为求中序遍历的倒序的第k个节点</p><p>中序遍历序列一般可以用DFS得到</p><p>对此可以先遍历右子节点，每遍历一个右子节点，计数器加1，之后遍历左子节点</p><p>当计数器等于k时，返回对应节点的值</p><p>方法2、栈式迭代：</p><p>对于DFS和BFS问题，都可以利用一个栈来进行迭代计算，这里依旧采用倒序，先把所有的右子节点加入到stack中</p><p>之后弹出栈顶元素，如果k==n，则返回当前节点值，否则，node=node.left，按照右中左的顺序遍历</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>||k==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        DFS(root,k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(TreeNode root,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        DFS(root.right,k);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count==k)&#123;</span><br><span class="line">            res = root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        DFS(root.left,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthLargest</span><span class="params">(self, root: TreeNode, k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        stack = []</span><br><span class="line">        node = root</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> node:</span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                stack.append(node)</span><br><span class="line">                node = node.right</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> node.val</span><br><span class="line">            node = node.left</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      二叉搜索树的第k大节点
    
    </summary>
    
      <category term="剑指Offer" scheme="http://benym.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="树" scheme="http://benym.cn/tags/%E6%A0%91/"/>
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Python" scheme="http://benym.cn/tags/Python/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="DFS" scheme="http://benym.cn/tags/DFS/"/>
    
      <category term="剑指Offer" scheme="http://benym.cn/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-面试题53-2-0到n-1中缺失的数字</title>
    <link href="http://benym.cn/2020/05/12/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9853-2-0%E5%88%B0n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://benym.cn/2020/05/12/LeetCode-面试题53-2-0到n-1中缺失的数字/</id>
    <published>2020-05-12T08:10:46.000Z</published>
    <updated>2020-05-18T03:02:07.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-面试题53-2-0到n-1中缺失的数字"><a href="#LeetCode-面试题53-2-0到n-1中缺失的数字" class="headerlink" title="LeetCode-面试题53-2-0到n-1中缺失的数字"></a>LeetCode-面试题53-2-0到n-1中缺失的数字</h2><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p> <a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,3]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,2,3,4,5,6,7,9]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure><ul><li><p><strong>限制：</strong></p><p><code>1 &lt;= 数组长度 &lt;= 10000</code></p></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>二分查找：</p><p>递增且数字范围在0~n-1的数组，数字和它对应的下标一定是相等的，缺失的数子会造成，该数字之后的数组下标在原本相等的情况下+1</p><p>可以利用二分查找，在当前位置数字不等于index的时候，考虑特殊情况2种</p><ul><li>当前位置==0</li><li>当前位置的前一个位置nums[mid-1]==mid-1，即前一个数字不缺失</li></ul><p>这两种情况说明该位置就是缺失数字的位置，直接返回mid</p><p>如果不符合特殊情况，则需要在mid左半边查找，end=mid-1</p><p>如果该位置和下标相等，则表示mid左边不存在缺失，需要在右半边查找，start=mid+1</p><p>如果找完了前面所有的都没有发现缺失的数字，说明缺失数字在数组末尾，此时start=mid+1=nums.length，缺失的数字即是num.length</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;=end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (start+end)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]!=mid)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mid==<span class="number">0</span>||nums[mid-<span class="number">1</span>]==mid-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">                &#125;</span><br><span class="line">                end = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                start = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(start==nums.length)</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        <span class="comment">// 无效输入，比如数组不是排序的</span></span><br><span class="line">        <span class="comment">// 或者有数字不在0-n-1范围内</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      0到n-1中缺失的数字
    
    </summary>
    
      <category term="剑指Offer" scheme="http://benym.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="剑指Offer" scheme="http://benym.cn/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-面试题53-1-在排序数组中查找数字I</title>
    <link href="http://benym.cn/2020/05/12/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9853-1-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97I/"/>
    <id>http://benym.cn/2020/05/12/LeetCode-面试题53-1-在排序数组中查找数字I/</id>
    <published>2020-05-12T06:24:43.000Z</published>
    <updated>2020-05-18T03:02:07.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-面试题53-1-在排序数组中查找数字I"><a href="#LeetCode-面试题53-1-在排序数组中查找数字I" class="headerlink" title="LeetCode-面试题53-1-在排序数组中查找数字I"></a>LeetCode-面试题53-1-在排序数组中查找数字I</h2><p>统计一个数字在排序数组中出现的次数。</p> <a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><ul><li><p><strong>限制：</strong></p><p><code>0 &lt;= 数组长度 &lt;= 50000</code></p></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>在有序的数组中二分查找，确定第一个k出现的位置和最后一个k出现的位置，然后两个位置相减即是出现次数</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums!=<span class="keyword">null</span>&amp;&amp;len&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> first = GetFristK(nums,len,target,<span class="number">0</span>,len-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> last = GetLastK(nums,len,target,<span class="number">0</span>,len-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(first&gt;-<span class="number">1</span>&amp;&amp;last&gt;-<span class="number">1</span>)&#123;</span><br><span class="line">                count = last-first+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetFristK</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> len,<span class="keyword">int</span> target,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;end)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (start+end)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> midData = nums[mid];</span><br><span class="line">        <span class="keyword">if</span>(midData==target)&#123;</span><br><span class="line">            <span class="comment">// 找到第一个k的位置</span></span><br><span class="line">            <span class="keyword">if</span>(mid&gt;<span class="number">0</span>&amp;&amp;nums[mid-<span class="number">1</span>]!=target||mid==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 如果前面还有k，缩小范围继续找</span></span><br><span class="line">                end = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(midData&gt;target)</span><br><span class="line">            end = mid-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            start = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> GetFristK(nums,len,target,start,end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetLastK</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> len,<span class="keyword">int</span> target,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;end)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (start+end)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> midData = nums[mid];</span><br><span class="line">        <span class="keyword">if</span>(midData==target)&#123;</span><br><span class="line">            <span class="comment">// 找到最后一个k的位置</span></span><br><span class="line">            <span class="keyword">if</span>(mid&lt;len-<span class="number">1</span>&amp;&amp;nums[mid+<span class="number">1</span>]!=target||mid==len-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                start = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(midData&lt;target)</span><br><span class="line">            start = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            end = mid-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> GetLastK(nums,len,target,start,end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      在排序数组中查找数字I
    
    </summary>
    
      <category term="剑指Offer" scheme="http://benym.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="剑指Offer" scheme="http://benym.cn/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-面试题52-两个链表的第一个公共节点</title>
    <link href="http://benym.cn/2020/05/12/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9852-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9%20-%20%E5%89%AF%E6%9C%AC/"/>
    <id>http://benym.cn/2020/05/12/LeetCode-面试题52-两个链表的第一个公共节点 - 副本/</id>
    <published>2020-05-12T04:55:26.000Z</published>
    <updated>2020-05-18T03:02:07.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-面试题52-两个链表的第一个公共节点"><a href="#LeetCode-面试题52-两个链表的第一个公共节点" class="headerlink" title="LeetCode-面试题52-两个链表的第一个公共节点"></a>LeetCode-面试题52-两个链表的第一个公共节点</h2><p>输入两个链表，找出它们的第一个公共节点。</p> <a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Reference of the node with value = 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><br><span class="line">输出：Reference of the node with value = 2</span><br><span class="line">输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class="line">输出：null</span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 null。</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>如果两个链表没有交点，返回 null.</li><li>在返回结果后，两个链表仍须保持原有的结构。</li><li>可假定整个链表结构中没有循环。</li><li>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>方法1、双指针+先遍历：</p><p>因为链表一长一短，所以先让长的一方走到和短的一方开始的位置，然后用双指针同时进行遍历，出现第一个相同的节点时就返回对应指针</p><p>方法2、双指针+重置：</p><p>同样是双指针，因为一长一短的关系，有一个指针会先到达末尾，当第一个指针pA先到末尾时，将他重置到链表B的开始位置，当第二个指针pB到达末尾时，将他重置到链表A开始的位置。由于有一个先到达先重置，在等待第二个指针走到末尾的过程中，先达到的指针pA将会走这段A比B多出的长度。这样当第二个指针重置时，两个指针都在一个位置开始，之后遍历到相同的节点返回即可</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lenA = getTreelen(headA);</span><br><span class="line">        <span class="keyword">int</span> lenB = getTreelen(headB);</span><br><span class="line">        <span class="keyword">int</span> firstStep = Math.abs(lenA-lenB);</span><br><span class="line">        ListNode pLong = headA;</span><br><span class="line">        ListNode pShort = headB;</span><br><span class="line">        <span class="keyword">if</span>(lenA&lt;lenB)&#123;</span><br><span class="line">            pLong = headB;</span><br><span class="line">            pShort = headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 长的先走几步</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;firstStep;i++)&#123;</span><br><span class="line">            pLong = pLong.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pLong!=<span class="keyword">null</span>&amp;&amp;pShort!=<span class="keyword">null</span>&amp;&amp;pLong!=pShort)&#123;</span><br><span class="line">            pLong = pLong.next;</span><br><span class="line">            pShort = pShort.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pLong;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTreelen</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lenTree = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            lenTree++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lenTree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA: ListNode, headB: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        node1, node2 = headA, headB</span><br><span class="line">        <span class="keyword">while</span> node1 != node2:</span><br><span class="line">            node1 = node1.next <span class="keyword">if</span> node1 <span class="keyword">else</span> headB</span><br><span class="line">            node2 = node2.next <span class="keyword">if</span> node2 <span class="keyword">else</span> headA</span><br><span class="line">        <span class="keyword">return</span> node1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      两个链表的第一个公共节点
    
    </summary>
    
      <category term="剑指Offer" scheme="http://benym.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Python" scheme="http://benym.cn/tags/Python/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="链表" scheme="http://benym.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="剑指Offer" scheme="http://benym.cn/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-面试题51-数组中的逆序对</title>
    <link href="http://benym.cn/2020/05/09/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9851-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    <id>http://benym.cn/2020/05/09/LeetCode-面试题51-数组中的逆序对/</id>
    <published>2020-05-09T10:33:02.000Z</published>
    <updated>2020-05-18T03:02:07.060Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-面试题51-数组中的逆序对"><a href="#LeetCode-面试题51-数组中的逆序对" class="headerlink" title="LeetCode-面试题51-数组中的逆序对"></a>LeetCode-面试题51-数组中的逆序对</h2><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p> <a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,5,6,4]</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>0 &lt;= 数组长度 &lt;= 50000</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>方法1、暴力破解(超时)：</p><p>两个指针循环判断后面的数是不是小于前面的数，是就+1，但这样超时了。算一个没办法的解法吧</p><p>方法2、归并排序：</p><p>基本上代码就是归并排序的思想，但递归的终止条件有了变化，因为分裂区间需要判断是否有逆序数的关系</p><p>当区间的left==right的时候，说明这个区间只有一个数字了，一个数字不能组成逆序数，因此这个区间的逆序数为0</p><p>在跨区间逆序数计算时，如果左边区间比较小就需要先把左边区间的数放入temp数组中，这个时候代表左边的数比又边的数小，<strong>但此时不是逆序的关系，不需要统计逆序对</strong>；只有当右边区间比左边区间小的时候，需要统计逆序对个数，此时的逆序对个数为，左边区间还剩下的数的个数即<code>mid-left+1</code></p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            copy[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">return</span> MergeSort(copy, <span class="number">0</span>, len - <span class="number">1</span>, temp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当这个区间只剩一个元素时，这个子区间就不存在逆序数，返回0</span></span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// int mid = (left+right)/2;</span></span><br><span class="line">        <span class="comment">// 防止int溢出</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> leftPairs = MergeSort(nums, left, mid, temp);</span><br><span class="line">        <span class="keyword">int</span> rightPairs = MergeSort(nums, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">        <span class="comment">// 如果分出来的数组本身有序，则返回左边+右边</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> leftPairs + rightPairs;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> crossPairs = mergeAndCount(nums, left, mid, right, temp);</span><br><span class="line">        <span class="keyword">return</span> leftPairs + rightPairs + crossPairs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">mergeAndCount</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;=right; i++) &#123;</span><br><span class="line">            temp[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = left; k &lt;= right; k++) &#123;</span><br><span class="line">            <span class="comment">// 如果左边数组遍历完了，就直接把右边拷贝回去</span></span><br><span class="line">            <span class="keyword">if</span> (i == mid + <span class="number">1</span>) &#123;</span><br><span class="line">                nums[k] = temp[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == right + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果右边数组遍历完了，就直接把左边拷贝回去</span></span><br><span class="line">                nums[k] = temp[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp[i] &lt;= temp[j]) &#123;</span><br><span class="line">                nums[k] = temp[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[k] = temp[j];</span><br><span class="line">                j++;</span><br><span class="line">                count += (mid - i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><p>暴力破解失败…..</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePairs</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        i,j,count = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&lt;nums[i]):</span><br><span class="line">                    count+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      数组中的逆序对
    
    </summary>
    
      <category term="剑指Offer" scheme="http://benym.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Hard" scheme="http://benym.cn/tags/Hard/"/>
    
      <category term="Python" scheme="http://benym.cn/tags/Python/"/>
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="剑指Offer" scheme="http://benym.cn/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="分治" scheme="http://benym.cn/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-归并排序</title>
    <link href="http://benym.cn/2020/05/09/LeetCode-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://benym.cn/2020/05/09/LeetCode-归并排序/</id>
    <published>2020-05-09T10:16:01.000Z</published>
    <updated>2020-05-18T03:02:07.030Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-归并排序"><a href="#LeetCode-归并排序" class="headerlink" title="LeetCode-归并排序"></a>LeetCode-归并排序</h2><p>归并排序算法回顾</p> <a id="more"></a><p><strong>示例1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [4,0,1,2,0,5]</span><br><span class="line">输出: [0,0,1,2,4,5]</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>归并排序算法采用分治的思想</p><p>把原本的数组不断进行二分，直到分为数组元素是单个的时候，之后开始排序合并</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">// 创建临时数组避免重复开辟空间</span></span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        MergerSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, temp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : arr)&#123;</span><br><span class="line">            System.out.print(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergerSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            MergerSort(arr, left, mid, temp); <span class="comment">// 左边归并排序，使得左子序列有序</span></span><br><span class="line">            MergerSort(arr, mid + <span class="number">1</span>, right, temp); <span class="comment">// 右边归并排序，使得右子序列有序</span></span><br><span class="line">            Merge(arr, left, mid, right, temp); <span class="comment">// 将两个有序子数组合并</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = left; <span class="comment">// 左序列指针</span></span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>; <span class="comment">// 右序列指针</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>; <span class="comment">// 临时数组指针</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">                temp[t++] = arr[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[t++] = arr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将左边剩余元素填充进temp中</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            temp[t++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将右边剩余元素填充进temp中</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">            temp[t++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 拷贝回原数组</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            arr[left++] = temp[t++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      归并排序
    
    </summary>
    
      <category term="算法" scheme="http://benym.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="排序算法" scheme="http://benym.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-面试题50-第一次只出现一次的字符</title>
    <link href="http://benym.cn/2020/05/08/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9850-%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
    <id>http://benym.cn/2020/05/08/LeetCode-面试题50-第一次只出现一次的字符/</id>
    <published>2020-05-08T11:23:20.000Z</published>
    <updated>2020-05-18T03:02:07.060Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-面试题50-第一次只出现一次的字符"><a href="#LeetCode-面试题50-第一次只出现一次的字符" class="headerlink" title="LeetCode-面试题50-第一次只出现一次的字符"></a>LeetCode-面试题50-第一次只出现一次的字符</h2><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。</p> <a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;abaccdeff&quot;</span><br><span class="line">返回 &quot;b&quot;</span><br><span class="line"></span><br><span class="line">s = &quot;&quot; </span><br><span class="line">返回 &quot; &quot;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>0 &lt;= s 的长度 &lt;= 50000</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>哈希表：</p><p>每出现一次字符就把字符放入hash表中，如果有重复的就把对应位置+1</p><p>遍历的时候由于hash表重新put改变了原本的先后顺序(Java的hashmap不能原地改变，Python的dict可以原地改变)，所以需要按照字符顺序遍历，当第1次value为1的时候，就返回该字符</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">' '</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; maps = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : chars) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!maps.containsKey(c)) &#123;</span><br><span class="line">                maps.put(c, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maps.put(c, maps.get(c) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : chars) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maps.get(c) == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python代码1"><a href="#Python代码1" class="headerlink" title="Python代码1"></a>Python代码1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstUniqChar</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> len(s)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">' '</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                d[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d[i]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> d.items():</span><br><span class="line">            <span class="keyword">if</span> v==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> k</span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      第一次只出现一次的字符
    
    </summary>
    
      <category term="剑指Offer" scheme="http://benym.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Python" scheme="http://benym.cn/tags/Python/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="剑指Offer" scheme="http://benym.cn/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-面试题49-丑数</title>
    <link href="http://benym.cn/2020/05/08/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9849-%E4%B8%91%E6%95%B0/"/>
    <id>http://benym.cn/2020/05/08/LeetCode-面试题49-丑数/</id>
    <published>2020-05-08T09:10:42.000Z</published>
    <updated>2020-05-18T03:02:07.059Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-面试题49-丑数"><a href="#LeetCode-面试题49-丑数" class="headerlink" title="LeetCode-面试题49-丑数"></a>LeetCode-面试题49-丑数</h2><p>我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p> <a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 10</span><br><span class="line">输出: 12</span><br><span class="line">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ol><li><code>1</code> 是丑数。</li><li><code>n</code> <strong>不超过</strong>1690。</li></ol><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这个题暴力破解的解法很耗时，就是循环判断一个数是否能被2，3，5整除，如果都能，则最后的因子是1，就说明这是丑数，外层还需要一个n的循环，非常耗时。更好的解法如下</p><p><strong>三指针：</strong></p><p>问题分析：一个丑数只有2，3，5这3个因子，1也是丑数，那么基本的3个丑数就可以由<code>1*2、1*3、1*5</code>得到，而其他的丑数也可以由2、3、5的乘积得到，这样问题就转化为了一个类似DP的问题，最小的问题是2、3、5，大一点的问题是乘以2、3、5得到的丑数。</p><p>由于需要从小到大的顺序排列n个丑数，所以怎么去保持丑数的顺序很重要</p><p>在每次计算出基于2、3、5的3个丑数时，始终把最小的丑数添加进dp[i]中</p><p>之后谁的结果最小，就移动那个指针</p><p>如果第i个丑数==2xp2，也就是说前面0-p2个丑数*2不可能产生比第i个丑数更大的丑数了，所以p2++</p><p>p3，p5同理</p><p>一个更好理解的例子源于<a href="https://leetcode-cn.com/u/sunrise-9/" target="_blank" rel="noopener">https://leetcode-cn.com/u/sunrise-9/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">丑数的排列肯定是1,2,3,4,5,6,8,10.... 然后有一个特点是，任意一个丑数都是由小于它的某一个丑数*2，*3或者*5得到的，那么如何得到所有丑数呢？ 现在假设有3个数组，分别是： A：&#123;1*2，2*2，3*2，4*2，5*2，6*2，8*2，10*2......&#125;</span><br><span class="line"></span><br><span class="line">B：&#123;1*3，2*3，3*3，4*3，5*3，6*3，8*3，10*3......&#125;</span><br><span class="line"></span><br><span class="line">C：&#123;1*5，2*5，3*5，4*5，5*5，6*5，8*5，10*5......&#125;</span><br><span class="line"></span><br><span class="line">那么所有丑数的排列，必定就是上面ABC3个数组的合并结果然后去重得到的，那么这不就转换成了三个有序数组的无重复元素合并的问题了吗？而这三个数组就刚好是&#123;1,2,3,4,5,6,8,10....&#125;乘以2,3,5得到的。</span><br><span class="line"></span><br><span class="line">合并有序数组的一个比较好的方法，就是每个数组都对应一个指针，然后比较这些指针所指的数中哪个最小，就将这个数放到结果数组中，然后该指针向后挪一位。</span><br><span class="line"></span><br><span class="line">回到本题，要求丑数ugly数组中的第n项，而目前只知道ugly[0]=1，所以此时三个有序链表分别就只有一个元素：</span><br><span class="line"></span><br><span class="line">A ： &#123;1*2......&#125;</span><br><span class="line"></span><br><span class="line">B ： &#123;1*3......&#125;</span><br><span class="line"></span><br><span class="line">C ：&#123;1*5......&#125;</span><br><span class="line"></span><br><span class="line">假设三个数组的指针分别是i,j,k，此时均是指向第一个元素，然后比较A[i]，B[j]和C[k]，得到的最小的数A[i]，就是ugly[1]，此时ugly就变成&#123;1,2&#125;了，对应的ABC数组就分别变成了：</span><br><span class="line"></span><br><span class="line">A ： &#123;1*2，2*2......&#125;</span><br><span class="line"></span><br><span class="line">B ： &#123;1*3, 2*3......&#125;</span><br><span class="line"></span><br><span class="line">C ：&#123;1*5,2*5......&#125;</span><br><span class="line"></span><br><span class="line">此时根据合并有序数组的原理，A数组指针i就指向了下一个元素，即&apos;2*2&apos;，而j和k依然分别指向B[0]和C[0]，然后进行下一轮合并，就是A[1]和B[0]和C[0]比较，最小值作为ugly[2].....如此循环n次，就可以得到ugly[n]了。</span><br><span class="line"></span><br><span class="line">此外，注意到ABC三个数组实际上就是ugly[]*2，ugly[]*3和ugly[]*5的结果，所以每次只需要比较A[i]=ugly[i]*2，B[j]=ugly[j]*3和C[k]=ugly[k]*5的大小即可。然后谁最小，就把对应的指针往后移动一个，为了去重，如果多个元素都是最小，那么这多个指针都要往后移动一个。</span><br></pre></td></tr></table></figure><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p2=<span class="number">0</span>,p3=<span class="number">0</span>,p5=<span class="number">0</span>; <span class="comment">// 想象初始化3个有序链表的第一个元素，分别为2、3、5为基数乘的数组</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">// 返回的下一个丑数应该是*2,*3,*5之后的最小丑数</span></span><br><span class="line">            dp[i] = Math.min(dp[p2]*<span class="number">2</span>,Math.min(dp[p3]*<span class="number">3</span>,dp[p5]*<span class="number">5</span>));</span><br><span class="line">            <span class="keyword">if</span>(dp[i]==dp[p2]*<span class="number">2</span>) p2++;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]==dp[p3]*<span class="number">3</span>) p3++;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]==dp[p5]*<span class="number">5</span>) p5++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      丑数
    
    </summary>
    
      <category term="剑指Offer" scheme="http://benym.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="剑指Offer" scheme="http://benym.cn/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="DP" scheme="http://benym.cn/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-面试题48-最长不含重复字符的子字符串</title>
    <link href="http://benym.cn/2020/05/08/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9848-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://benym.cn/2020/05/08/LeetCode-面试题48-最长不含重复字符的子字符串/</id>
    <published>2020-05-08T02:25:53.000Z</published>
    <updated>2020-05-18T03:02:07.059Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-面试题48-最长不含重复字符的子字符串"><a href="#LeetCode-面试题48-最长不含重复字符的子字符串" class="headerlink" title="LeetCode-面试题48-最长不含重复字符的子字符串"></a>LeetCode-面试题48-最长不含重复字符的子字符串</h2><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p> <a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>方法1、DP+哈希表：</strong></p><p>设置右边界为j，左边界为i</p><ul><li>当字串左边没有相同的字符时，dp[j] = dp[j-1]+1</li><li>当dp[j-1]&lt;j-i，说明字符在dp[j-1]区间之外，如acbr，对于acb而言下一个字符r不是重复的字符，其在dp[j-1]之外，所以dp[j] = dp[j-1]+1</li><li>当dp[j-1]&gt;=j-i，说明字符在dp[j-1]区间之中，含有重复字符，则dp[j]的左边界由第一次出现的重复字符的位置觉得，dp[j]=j-i</li></ul><p>第一二种情况可以合并为一个，由于返回值取dp列表最大值，可以借助dp变量，存储dp[j]，每轮更新res</p><p>节省原本需要dp列表的空间</p><p><strong>方法2、双指针+哈希表：</strong></p><p>按照顺序遍历字符串，同时计算子串的长度，当到达相同的字符时候，自然希望子串的起始位置变成重复的位置。</p><p>而下一次子串的长度则=计算下一次碰到重复字符的位置<code>end</code>到上一次碰到重复字符位置<code>start</code>的差</p><p>那么如何去知道前面是否有重复的字符？</p><p>如果不使用hash表，就需要从最开始遍历到末尾end进行判断，这样时间复杂度太高。</p><p>所以这里采用hash表的方式存储每一个字符最后出现的位置，以便于快速找到上一次start的位置，由于遍历从0开始，所以将start初始化为-1，表示第一个位置长度为1，最后取最大的字串长度</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character,Integer&gt; dict = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>,dp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s.length();j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = dict.containsKey(s.charAt(j))?dict.get(s.charAt(j)):-<span class="number">1</span>; <span class="comment">// 获取索引</span></span><br><span class="line">            dict.put(s.charAt(j),j); <span class="comment">// 更新hash</span></span><br><span class="line">            <span class="comment">// dp[j-1] &lt; j-i时，dp[j-1]+1</span></span><br><span class="line">            <span class="comment">// dp[j-1] &gt; j-i时，j-i</span></span><br><span class="line">            dp = dp&lt;j-i?dp+<span class="number">1</span>:j-i;</span><br><span class="line">            res = Math.max(res,dp); <span class="comment">// max(dp[j-1],dp[j])</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        start,res= <span class="number">-1</span>,<span class="number">0</span></span><br><span class="line">        positionMap = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[end] <span class="keyword">in</span> positionMap:</span><br><span class="line">                start = max(positionMap[s[end]],start)</span><br><span class="line">            positionMap[s[end]] = end</span><br><span class="line">            res = max(res,end-start)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      最长不含重复字符的子字符串
    
    </summary>
    
      <category term="剑指Offer" scheme="http://benym.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="Python" scheme="http://benym.cn/tags/Python/"/>
    
      <category term="字符串" scheme="http://benym.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="剑指Offer" scheme="http://benym.cn/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="DP" scheme="http://benym.cn/tags/DP/"/>
    
      <category term="双指针" scheme="http://benym.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-面试题47-礼物的最大价值</title>
    <link href="http://benym.cn/2020/05/07/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9847-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/"/>
    <id>http://benym.cn/2020/05/07/LeetCode-面试题47-礼物的最大价值/</id>
    <published>2020-05-07T13:12:39.000Z</published>
    <updated>2020-05-18T03:02:07.058Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-面试题47-礼物的最大价值"><a href="#LeetCode-面试题47-礼物的最大价值" class="headerlink" title="LeetCode-面试题47-礼物的最大价值"></a>LeetCode-面试题47-礼物的最大价值</h2><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p> <a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>动态规划：</strong></p><p>由于只能向右和向下移动，所以对于第一行和第一列而言，可能的最大值就是直接向右和向下移动</p><p>设置二维dp矩阵</p><ul><li><p>第一列表示为i不等于0时，<code>dp[i][0]</code>仅与<code>dp[i-1][0]</code>有关，于是可以在原矩阵直接进行修改</p></li><li><p>第一行表示为j不等于0时，<code>dp[0][j]</code>仅与<code>dp[0][j-1]</code>有关</p><p>对于一行和一列可以先计算出来，避免循环中重复的判断</p></li><li><p>当i和j都不等于0时，<code>dp[i][j]</code>应该等于其左边格子的累和以及上边格子累和的最大值+当前格子的值</p><p>即<code>dp[i][j]=Max(dp[i-1][j],dp[i][j-1])+gift(i,j)</code></p></li></ul><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span>||grid.length == <span class="number">0</span>||grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            grid[i][<span class="number">0</span>]+=grid[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            grid[<span class="number">0</span>][j]+=grid[<span class="number">0</span>][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                grid[i][j] += Math.max(grid[i-<span class="number">1</span>][j],grid[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxValue</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid <span class="keyword">or</span> len(grid)==<span class="number">0</span> <span class="keyword">or</span> len(grid[<span class="number">0</span>])==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> i==<span class="number">0</span> <span class="keyword">and</span> j==<span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> i!=<span class="number">0</span> <span class="keyword">and</span> j==<span class="number">0</span>: grid[i][j]+=grid[i<span class="number">-1</span>][j]</span><br><span class="line">                <span class="keyword">if</span> i==<span class="number">0</span> <span class="keyword">and</span> j!=<span class="number">0</span>: grid[i][j]+=grid[i][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">if</span> i!=<span class="number">0</span> <span class="keyword">and</span> j!=<span class="number">0</span>: grid[i][j]+=max(grid[i<span class="number">-1</span>][j],grid[i][j<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> grid[len(grid)<span class="number">-1</span>][len(grid[<span class="number">0</span>])<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      礼物的最大价值
    
    </summary>
    
      <category term="剑指Offer" scheme="http://benym.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="Python" scheme="http://benym.cn/tags/Python/"/>
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="剑指Offer" scheme="http://benym.cn/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="DP" scheme="http://benym.cn/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-面试题46-把数字翻译成字符串</title>
    <link href="http://benym.cn/2020/05/07/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9846-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://benym.cn/2020/05/07/LeetCode-面试题46-把数字翻译成字符串/</id>
    <published>2020-05-07T07:56:27.000Z</published>
    <updated>2020-05-18T03:02:07.058Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-面试题46-把数字翻译成字符串"><a href="#LeetCode-面试题46-把数字翻译成字符串" class="headerlink" title="LeetCode-面试题46-把数字翻译成字符串"></a>LeetCode-面试题46-把数字翻译成字符串</h2><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p> <a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 12258</span><br><span class="line">输出: 5</span><br><span class="line">解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>0 &lt;= num &lt; 2^31</code></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>动态规划：</strong></p><p>初始化dp[0]=dp[1]=1，即翻译”无数字”和”第1位数字”的翻译方法数量均为1</p><p>当num的第1，2位的组成的数字属于[10,25]时，dp[2]=dp[1]+dp[0]=2，有2种翻译方法，显然dp[1]=1，所以dp[0]=1</p><ul><li>当1个数被翻译为1个字母时，剩下的方案即dp[i-1]，dp[i]=dp[i-1]</li><li>当2个数组合在[10,25]的范围时，方案有2种，一是翻译1个数，二是翻译2个组合的数，dp[i] = dp[i-1]+dp[i-2]</li></ul><p>为了优化空间，这里使用2个变量，分别代表dp[i]和dp[i-1]，当i从2开始时，dp[2]就可以通过dp0+dp1得到，之后顺序递推这两个数值</p><p><strong>递归(回溯)：</strong></p><p>想象成一棵二叉树，可以选择翻译1个数，也可以选择翻译1个组合数</p><p>当二叉树走的深度没有达到字符串长度时，就要进行判断</p><ul><li>如果组合数符合[10,25]，则翻译的可能性有使用1个数字<code>i+1</code>和使用2个数字<code>i+2</code>两种可能，开启2种可能的递归调用。</li><li>如果不符合，则翻译只有一种可能，即<code>i+1</code>深度下的可能性</li></ul><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        String s = String.valueOf(num);</span><br><span class="line">        <span class="keyword">int</span> dp0 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> dp1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=s.length();i++)&#123;</span><br><span class="line">            String temp = s.substring(i-<span class="number">2</span>,i);</span><br><span class="line">            <span class="keyword">int</span> res = temp.compareTo(<span class="string">"10"</span>)&gt;=<span class="number">0</span>&amp;&amp;temp.compareTo(<span class="string">"25"</span>)&lt;=<span class="number">0</span> ? dp0 + dp1 : dp1;</span><br><span class="line">            dp0 = dp1;</span><br><span class="line">            dp1 = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">translateNum</span><span class="params">(self, num: int)</span> -&gt; int:</span></span><br><span class="line">        s = str(num)</span><br><span class="line">        length = len(s)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> self.Sum(s,<span class="number">0</span>,length)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Sum</span><span class="params">(self,s,i,length)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;=length:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i&lt;=length<span class="number">-1</span>:</span><br><span class="line">            nsum = int(s[i])*<span class="number">10</span>+int(s[i+<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> nsum&gt;=<span class="number">10</span> <span class="keyword">and</span> nsum&lt;=<span class="number">25</span>:</span><br><span class="line">                <span class="keyword">return</span> self.Sum(s,i+<span class="number">1</span>,length)+self.Sum(s,i+<span class="number">2</span>,length)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> self.Sum(s,i+<span class="number">1</span>,length)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      把数字翻译成字符串
    
    </summary>
    
      <category term="剑指Offer" scheme="http://benym.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="Python" scheme="http://benym.cn/tags/Python/"/>
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="剑指Offer" scheme="http://benym.cn/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="DP" scheme="http://benym.cn/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-面试题45-把数组排成最小的数</title>
    <link href="http://benym.cn/2020/05/06/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9845-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/"/>
    <id>http://benym.cn/2020/05/06/LeetCode-面试题45-把数组排成最小的数/</id>
    <published>2020-05-06T10:51:48.000Z</published>
    <updated>2020-05-18T03:02:07.058Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-面试题45-把数组排成最小的数"><a href="#LeetCode-面试题45-把数组排成最小的数" class="headerlink" title="LeetCode-面试题45-把数组排成最小的数"></a>LeetCode-面试题45-把数组排成最小的数</h2><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p> <a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [10,2]</span><br><span class="line">输出: &quot;102&quot;</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,30,34,5,9]</span><br><span class="line">输出: &quot;3033459&quot;</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>0 &lt; nums.length &lt;= 100</code></li></ul><p><strong>说明：</strong></p><ul><li>输出结果可能非常大，所以你需要返回一个字符串而不是整数</li><li>拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>排序：</p><p>对于两个数字m和n，可以拼接成mn和nm，如果mn&lt;nm，那么就应该打印出mn，也就是m应该排在n之前，此时定义m”小于”n；反之，如果nm&lt;mn，应该打印nm，此时定义n”小于”m；如果mn=nm，则n”等于”m，由于组合的数字很大，所以这也是一个大数问题，用字符串来进行拼接得到结果</p><p>在Java代码中可以重写Arrays中的compareTo接口，使x+y和y+x进行大小比较，sort方法默认升序，所以比较出来的数组自然是最小的</p><p>Python代码….原来还可以根据key自定义规则，方法来自<a href="https://leetcode-cn.com/u/bigkjp97/" target="_blank" rel="noopener">https://leetcode-cn.com/u/bigkjp97/</a>因为默认升序，所以只需要改变大于或者小于的规则即可，其他规则富比较方法中不变不影响</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        String[] str = <span class="keyword">new</span> String[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            str[i] = String.valueOf(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(str, (x, y) -&gt; (x + y).compareTo(y + x));</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(String s:str)</span><br><span class="line">            res.append(s);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python代码1"><a href="#Python代码1" class="headerlink" title="Python代码1"></a>Python代码1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallerNumKey</span><span class="params">(str)</span>:</span> <span class="comment"># 定义一个类</span></span><br><span class="line">    <span class="comment"># 富比较方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(x, y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x + y &lt; y + x</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumber</span><span class="params">(self, nums: List[int])</span> -&gt; str:</span></span><br><span class="line">        smallest_num = <span class="string">''</span>.join(sorted(map(str, nums),key=SmallerNumKey))</span><br><span class="line">        <span class="keyword">return</span> smallest_num</span><br></pre></td></tr></table></figure><h3 id="Python代码2"><a href="#Python代码2" class="headerlink" title="Python代码2"></a>Python代码2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumber</span><span class="params">(self, nums: List[int])</span> -&gt; str:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sort_rule</span><span class="params">(x, y)</span>:</span></span><br><span class="line">            a, b = x + y, y + x</span><br><span class="line">            <span class="keyword">if</span> a &gt; b: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> a &lt; b: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        strs.sort(map(str,nums),key = functools.cmp_to_key(sort_rule))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(strs)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      把数组排成最小的数
    
    </summary>
    
      <category term="剑指Offer" scheme="http://benym.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="Python" scheme="http://benym.cn/tags/Python/"/>
    
      <category term="大数问题" scheme="http://benym.cn/tags/%E5%A4%A7%E6%95%B0%E9%97%AE%E9%A2%98/"/>
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="剑指Offer" scheme="http://benym.cn/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-面试题44-数字序列中某一位的数字</title>
    <link href="http://benym.cn/2020/05/06/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9844-%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://benym.cn/2020/05/06/LeetCode-面试题44-数字序列中某一位的数字/</id>
    <published>2020-05-06T07:15:55.000Z</published>
    <updated>2020-05-18T03:02:07.057Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-面试题44-数字序列中某一位的数字"><a href="#LeetCode-面试题44-数字序列中某一位的数字" class="headerlink" title="LeetCode-面试题44-数字序列中某一位的数字"></a>LeetCode-面试题44-数字序列中某一位的数字</h2><p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p><p>请写一个函数，求任意第n位对应的数字。</p> <a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 11</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>1 &lt;= n &lt; 2^31</code></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>找规律：</strong></p><p>首先int类型只能表示2^31-1个数，所以存储的时候需要用long表示</p><div class="table-container"><table><thead><tr><th>数字范围</th><th>位数</th><th>数字数量</th><th>数位数量</th></tr></thead><tbody><tr><td>数字范围1-9</td><td>位数=1</td><td>数字数量=9</td><td>数位数量=9</td></tr><tr><td>数字范围10-99</td><td>位数=2</td><td>数字数量=90</td><td>数位数量 =180</td></tr><tr><td>数字范围100-999</td><td>位数=3</td><td>数字数量=900</td><td>数位数量=2700</td></tr><tr><td>数字范围start-end</td><td>位数=digit</td><td>数字数量=9xstart</td><td>数位数量=9xstartxdigit</td></tr></tbody></table></div><p>可以从上规律分析出，可以通过划分数字的范围，去确定输入n位在几位数的区间，之后再几位数的区间中找到这一位数字。</p><ul><li><p>剑指offer的解法：</p><p>比如数字序列的1001位，由上表可知1001位的数字范围是100-999，因为1001&lt;2700，1001-180-9=881位，即数字范围100~999中的881位数字，由于这个范围数字是3位数，881/3=270，余1。即在100的基础上走过270个数字之后，再移动1位即是1001位数。可以从数字n开始出发，每排除一种位数的范围，就把n减去这个范围的位数，然后确定n应该在的范围</p></li><li><p>递推的解法：</p><p>观察上面的表格可以看出</p><p>位数递推公式<code>digit = digit+1</code></p><p>起始数字公式 <code>start=startx10</code></p><p>数位数量公式<code>count=9xstartxdigit</code></p><p>求解分为3步：</p><ul><li>确定n所在数字的位数，记为digit</li><li>确定n所在的数字，记为num</li><li>确定n是num中的哪一数位，返回结果</li></ul></li></ul><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span> out = findNthDigit(n);</span><br><span class="line">        System.out.println(out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">10</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> digits = <span class="number">1</span>; <span class="comment">// 代表是几位数</span></span><br><span class="line">        <span class="comment">// 找到n位于几位数的范围中</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> nums = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (digits == <span class="number">1</span>) nums = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">else</span> nums = <span class="number">9</span> * (<span class="keyword">long</span>) Math.pow(<span class="number">10</span>, digits - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (n &lt; nums * digits)</span><br><span class="line">                <span class="keyword">return</span> digitsN(n, digits);</span><br><span class="line">            n -= digits * nums;</span><br><span class="line">            digits++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在几位数中找出那一位数字</span></span><br><span class="line">    <span class="comment">// 比如811=270x3+1是从100开始的270个数字的中间1位</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">digitsN</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> nums = begin(digits) + n / digits;</span><br><span class="line">        <span class="comment">// 求得那个数字中的第几位，如370，7是这个数字的第2位</span></span><br><span class="line">        <span class="keyword">int</span> indexFromRight = digits - n % digits;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; indexFromRight; i++) &#123;</span><br><span class="line">            nums /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) nums % <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到所属位数的初始值，如3位数的初始值是100</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">begin</span><span class="params">(<span class="keyword">int</span> digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (digits == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">long</span>) Math.pow(<span class="number">10</span>, digits - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNthDigit</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        digit,start,count = <span class="number">1</span>,<span class="number">1</span>,<span class="number">9</span></span><br><span class="line">        <span class="keyword">while</span> n&gt;count:</span><br><span class="line">            n-=count</span><br><span class="line">            start*=<span class="number">10</span></span><br><span class="line">            digit+=<span class="number">1</span></span><br><span class="line">            count = <span class="number">9</span>*start*digit</span><br><span class="line">        num = start + (n<span class="number">-1</span>)//digit <span class="comment"># 确定所求数位所在的数字</span></span><br><span class="line">        res = str(num)[(n<span class="number">-1</span>)%digit]<span class="comment"># 确定所求数位在num的哪一数位，余数即使对应位置</span></span><br><span class="line">        <span class="keyword">return</span> int(res)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      数字序列中某一位的数字
    
    </summary>
    
      <category term="剑指Offer" scheme="http://benym.cn/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="Python" scheme="http://benym.cn/tags/Python/"/>
    
      <category term="大数问题" scheme="http://benym.cn/tags/%E5%A4%A7%E6%95%B0%E9%97%AE%E9%A2%98/"/>
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="剑指Offer" scheme="http://benym.cn/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
</feed>
