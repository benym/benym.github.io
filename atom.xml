<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ming.Y</title>
  
  <subtitle>Chances are for people who are prepared</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://benym.cn/"/>
  <updated>2020-07-02T11:22:08.156Z</updated>
  <id>http://benym.cn/</id>
  
  <author>
    <name>BenY</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常见排序算法总结</title>
    <link href="http://benym.cn/2020/07/02/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://benym.cn/2020/07/02/常见排序算法总结/</id>
    <published>2020-07-02T08:17:37.000Z</published>
    <updated>2020-07-02T11:22:08.156Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见排序算法总结"><a href="#常见排序算法总结" class="headerlink" title="常见排序算法总结"></a>常见排序算法总结</h2><p>总结了常用的排序算法，以及对应分析</p><p>相关链接：</p><ol><li><a href="/2020/06/28/LeetCode-冒泡排序/" title="LeetCode-冒泡排序">LeetCode-冒泡排序</a></li><li><a href="/2020/06/28/LeetCode-选择排序/" title="LeetCode-选择排序">LeetCode-选择排序</a></li><li><a href="/2020/06/28/LeetCode-插入排序/" title="LeetCode-插入排序">LeetCode-插入排序</a></li><li><a href="/2020/05/04/LeetCode-快速排序/" title="LeetCode-快速排序">LeetCode-快速排序</a></li><li><a href="/2020/05/09/LeetCode-归并排序/" title="LeetCode-归并排序">LeetCode-归并排序</a></li><li><a href="/2020/06/28/LeetCode-希尔排序/" title="LeetCode-希尔排序">LeetCode-希尔排序</a></li><li><a href="/2020/07/01/LeetCode-桶排序/" title="LeetCode-桶排序">LeetCode-桶排序</a></li><li><a href="/2020/07/01/LeetCode-基数排序/" title="LeetCode-基数排序">LeetCode-基数排序</a></li><li><a href="/2020/07/01/LeetCode-堆排序/" title="LeetCode-堆排序">LeetCode-堆排序</a><a id="more"></a></li></ol><p>总结各种排序算法的时间复杂度和空间复杂度，以及其对应的稳定性</p><div class="table-container"><table><thead><tr><th style="text-align:center">算法种类</th><th style="text-align:center">最好情况</th><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最坏情况</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">是否稳定</th></tr></thead><tbody><tr><td style="text-align:center">冒泡排序</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(1)</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">选择排序</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(1)</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">插入排序</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(1)</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">快速排序</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(logn)</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">归并排序</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(n)</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">希尔排序</td><td style="text-align:center"></td><td style="text-align:center">O(n^1.3)-O(n^2)</td><td style="text-align:center"></td><td style="text-align:center">O(1)</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">桶排序</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(n*(log(n/m)+1))</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(n+m)</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">基数排序</td><td style="text-align:center">O(d(n+r))</td><td style="text-align:center">O(d(n+r))</td><td style="text-align:center">O(d(n+r))</td><td style="text-align:center">O(r)</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">堆排序</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(1)</td><td style="text-align:center">否</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      排序算法总结
    
    </summary>
    
      <category term="算法" scheme="http://benym.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="排序算法" scheme="http://benym.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-堆排序</title>
    <link href="http://benym.cn/2020/07/01/LeetCode-%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://benym.cn/2020/07/01/LeetCode-堆排序/</id>
    <published>2020-07-01T07:23:25.000Z</published>
    <updated>2020-07-01T12:06:37.444Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-堆排序"><a href="#LeetCode-堆排序" class="headerlink" title="LeetCode-堆排序"></a>LeetCode-堆排序</h2><p>堆排序算法回顾</p> <a id="more"></a><p><strong>示例1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1, 4, 3, 100, 323, 53, 13, 559230, 123, 20, 43, 12]</span><br><span class="line">输出: [1,3,4,12,13,20,43,53,100,123,323,559230]</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>一个不错的堆排序讲解，<a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">出处在这</a></p><p>了解堆排序首先需要了解堆</p><p><strong>堆</strong>是一种具有如下性质的完全二叉树：<strong>每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆</strong></p><p>大顶堆满足：arr[i]&gt;=arr[2i+1]&amp;&amp;arr[i]&gt;=arr[2i+2]</p><p>小顶堆满足：arr[i]&lt;=arr[2i+1]&amp;&amp;arr[i]&lt;=arr[2i+2]</p><p><strong>堆排序</strong>的基本思想是： </p><ul><li><strong>将待排序序列构造成一个大顶堆/小顶堆，此时，整个序列的最大值就是堆顶的根节点。</strong></li><li><strong>将其与末尾元素进行交换，此时末尾就为最大/小值。</strong></li><li><strong>然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。</strong></li><li><strong>如此反复执行，便能得到一个有序序列了</strong></li></ul><p>堆排序是一种选择排序，整体主要由构建初始堆+交换堆顶元素和末尾元素并重建堆两部分组成。</p><p>其中构建初始堆的复杂度为O(n)，在交换并重建堆的过程中，需交换n-1次，而重建堆的过程中，根据完全二叉树的性质</p><p>[log2(n-1),log2(n-2),….,1]逐步递减，所以<strong>时间复杂度近似为O(nlogn)</strong>，堆排序是一种不稳定的排序算法</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">100</span>, <span class="number">323</span>, <span class="number">53</span>, <span class="number">13</span>, <span class="number">559230</span>, <span class="number">123</span>, <span class="number">20</span>, <span class="number">43</span>, <span class="number">12</span>&#125;;</span><br><span class="line">        sort(array);</span><br><span class="line">        <span class="keyword">for</span> (Integer i : array) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构建大顶堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">//从第一个非叶子节点从下至上，从右至左调整结构</span></span><br><span class="line">            adjustHeap(arr, i, arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调整堆结构+交换堆顶元素与末尾元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = arr.length - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            swap(arr, <span class="number">0</span>, j);<span class="comment">// 将堆顶元素和末尾元素进行交换</span></span><br><span class="line">            adjustHeap(arr, <span class="number">0</span>, j);<span class="comment">// 重新对堆进行调整</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整大顶堆(仅是调整过程，建立在大顶堆已构建的基础上)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];<span class="comment">// 先取出当前元素i</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i * <span class="number">2</span> + <span class="number">1</span>; k &lt; length; k = k * <span class="number">2</span> + <span class="number">1</span>) &#123;<span class="comment">// 从i节点的左子节点开始，也就是2i+1处开始</span></span><br><span class="line">            <span class="keyword">if</span> (k + <span class="number">1</span> &lt; length &amp;&amp; arr[k] &lt; arr[k + <span class="number">1</span>]) &#123;<span class="comment">// 如果左子节点小于右子节点，k指向右子节点</span></span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[k] &gt; temp) &#123;<span class="comment">// 如果子节点大于父节点，将子节点值赋给父节点(不用进行交换)</span></span><br><span class="line">                arr[i] = arr[k];</span><br><span class="line">                i = k;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = temp;<span class="comment">// 将temp值放到最终的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      堆排序
    
    </summary>
    
      <category term="算法" scheme="http://benym.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="排序算法" scheme="http://benym.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-基数排序</title>
    <link href="http://benym.cn/2020/07/01/LeetCode-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>http://benym.cn/2020/07/01/LeetCode-基数排序/</id>
    <published>2020-07-01T07:23:25.000Z</published>
    <updated>2020-07-01T08:28:51.927Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-基数排序"><a href="#LeetCode-基数排序" class="headerlink" title="LeetCode-基数排序"></a>LeetCode-基数排序</h2><p>基数排序算法回顾</p> <a id="more"></a><p><strong>示例1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1, 4, 3, 100, 323, 53, 13, 559230, 123, 20, 43, 12]</span><br><span class="line">输出: [1,3,4,12,13,20,43,53,100,123,323,559230]</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>​        基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；</p><p>​        基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。基数排序基于分别排序，分别收集，所以是稳定的。</p><p>​        时间复杂度：设待排序列为n个记录，d个关键码，关键码的取值范围为radix，则进行链式基数排序的时间复杂度为O(d(n+radix))，其中，一趟分配时间复杂度为O(n)，一趟收集时间复杂度为O(radix)，共进行d趟分配和收集。</p><p>​        基数排序是稳定的排序算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">100</span>, <span class="number">323</span>, <span class="number">53</span>, <span class="number">13</span>, <span class="number">559230</span>, <span class="number">123</span>, <span class="number">20</span>, <span class="number">43</span>, <span class="number">12</span>&#125;;</span><br><span class="line">        sort(array);</span><br><span class="line">        <span class="keyword">for</span> (Integer i : array) &#123;</span><br><span class="line">            System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基数排序，注意这里只能排序正整数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 找到数组中最大数max，并计算它的位数maxDig</span></span><br><span class="line">        <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> maxTemp : array) &#123;</span><br><span class="line">            max = Math.max(max, maxTemp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxDig = String.valueOf(max).length();</span><br><span class="line">        <span class="comment">// 创建从0-9的基数数据集</span></span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            map.put(i, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从低位baseDig开始到高位maxDig进行指定位的基数排序</span></span><br><span class="line">        <span class="keyword">int</span> baseDig = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (baseDig &lt;= maxDig) &#123;</span><br><span class="line">            <span class="comment">// 第一阶段，遍历目标数组，将数组元素放入指定的基数数据集中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> temp : array) &#123;</span><br><span class="line">                String strVal = String.valueOf(temp);</span><br><span class="line">                <span class="comment">// 获取元素baseDig位的数字，放入相对的基数数据集中</span></span><br><span class="line">                <span class="comment">// 如果不存在，将该元素放入0基数数据集中</span></span><br><span class="line">                Integer key = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (strVal.length() &lt; baseDig) &#123;</span><br><span class="line">                    key = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取指定位上的字符，并转化成目标基数key</span></span><br><span class="line">                    <span class="keyword">char</span> bitNum = strVal.charAt(strVal.length() - baseDig);</span><br><span class="line">                    key = Integer.valueOf(String.valueOf(bitNum));</span><br><span class="line">                &#125;</span><br><span class="line">                map.get(key).add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 第二阶段，将0-9基数数据集中的数据，放回到数组中</span></span><br><span class="line">            <span class="comment">// 表示当前baseDig位的基数排序完成</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                Iterator&lt;Integer&gt; it = map.get(i).iterator();</span><br><span class="line">                <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                    array[j++] = it.next();</span><br><span class="line">                &#125;</span><br><span class="line">                map.get(i).clear();</span><br><span class="line">            &#125;</span><br><span class="line">            baseDig++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      基数排序
    
    </summary>
    
      <category term="算法" scheme="http://benym.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="排序算法" scheme="http://benym.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-桶排序</title>
    <link href="http://benym.cn/2020/07/01/LeetCode-%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://benym.cn/2020/07/01/LeetCode-桶排序/</id>
    <published>2020-07-01T01:59:15.000Z</published>
    <updated>2020-07-01T07:19:32.749Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-桶排序"><a href="#LeetCode-桶排序" class="headerlink" title="LeetCode-桶排序"></a>LeetCode-桶排序</h2><p>桶排序算法回顾</p> <a id="more"></a><p><strong>示例1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [4,0,1,2,0,5]</span><br><span class="line">输出: [0,0,1,2,4,5]</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>桶排序(Bucket Sort)的原理很简单，它是将数组分到有限数量的桶子里。是一种非比较的排序方法</p><p>在了解桶排序之前，先了解<strong>计数排序</strong></p><p>其中计数排序思想如下：</p><p>假设待排序的数组a中共有N个整数，并且已知数组a中数据的范围[0, MAX)。在桶排序时，创建容量为MAX的桶数组r，并将桶数组元素都初始化为0；将容量为MAX的桶数组中的每一个单元都看作一个”桶”。<br>在排序时，逐个遍历数组a，将数组a的值，作为”桶数组r”的下标。当a中数据被读取时，就将桶的值加1。例如，读取到数组a[3]=5，则将r[5]的值+1。</p><h3 id="Java代码1"><a href="#Java代码1" class="headerlink" title="Java代码1"></a>Java代码1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BucketSort2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">10</span>&#125;;</span><br><span class="line">        bucketSort2(arr);</span><br><span class="line">        <span class="keyword">for</span> (Integer i : arr) &#123;</span><br><span class="line">            System.out.print(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bucketSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            max = Math.max(max, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            bucket[arr[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucket.length; j++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (bucket[j]-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                arr[index++] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>桶排序可以看做是计数排序的扩展，在计数排序中，每个桶只存储相同的元素</p><p>而桶排序中每个桶存储一定范围的元素，通过映射函数，将待排序数组中的元素存储到各个对应的桶中</p><p>之后对每个桶中的元素进行排序</p><p>最后将非空桶中的元素逐个放入原序列中</p><p>桶排序需要尽量保证元素分散均匀，否则当所有数据集中在同一个桶中时，桶排序就会失效</p><p><strong>桶排序的稳定性取决于桶内部使用的排序算法</strong></p><h3 id="Java代码2"><a href="#Java代码2" class="headerlink" title="Java代码2"></a>Java代码2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BucketSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        bucketSort(arr);</span><br><span class="line">        <span class="keyword">for</span> (Integer i : arr) &#123;</span><br><span class="line">            System.out.print(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 计算最大值与最小值</span></span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            max = Math.max(max, arr[i]);</span><br><span class="line">            min = Math.min(min, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算桶的数量</span></span><br><span class="line">        <span class="keyword">int</span> bucketNum = (max - min) / arr.length + <span class="number">1</span>; <span class="comment">//保证每个桶存的区间范围平均，+1代表余数补1个桶</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketNum);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++) &#123;</span><br><span class="line">            bucketArr.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将每个元素放入桶</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = (arr[i] - min) / (arr.length); <span class="comment">//确定arr[i]存储在哪个桶</span></span><br><span class="line">            bucketArr.get(num).add(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对每个桶进行排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketArr.size(); i++) &#123;</span><br><span class="line">            Collections.sort(bucketArr.get(i)); <span class="comment">// 内层排序算法可选择</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将桶中的元素赋值到原序列</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketArr.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketArr.get(i).size(); j++) &#123;</span><br><span class="line">                arr[index++] = bucketArr.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>对于待排序序列大小为N，共分为M个桶，主要步骤有：</p><ul><li>N次循环，将每个元素装入对应的桶中</li><li>M次循环，对每个桶中的数据进行排序(平均每个桶有N/M个元素)</li></ul><p>一般使用较为快速的排序算法，时间复杂度为O(nlogn)，实际的桶排序过程是以链表形式插入的</p><p>整个桶排序的时间复杂度为：</p><p><code>O(N)+O(M*(N/M*log(N/M)))=O(N*(log(N/M)+1))</code></p><p>当N=M时，复杂度为O(N)</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p><code>O(N+M)</code></p>]]></content>
    
    <summary type="html">
    
      桶排序
    
    </summary>
    
      <category term="算法" scheme="http://benym.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="排序算法" scheme="http://benym.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java反射获取类对象的三种方式</title>
    <link href="http://benym.cn/2020/06/29/Java%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://benym.cn/2020/06/29/Java反射获取类对象的三种方式/</id>
    <published>2020-06-29T11:36:09.000Z</published>
    <updated>2020-06-29T12:31:19.452Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java反射获取类对象的三种方式"><a href="#Java反射获取类对象的三种方式" class="headerlink" title="Java反射获取类对象的三种方式"></a>Java反射获取类对象的三种方式</h2><p>简单了解Java获取类的3种方式</p> <a id="more"></a><p><strong>1、Class.forName(“全类名”)</strong></p><p>将字节吗文件加载进内存，返回Class对象，多用于配指文件，将类名定义在配置文件中，便于利用java的反射机制生成类对象，加载类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载一个用户实体类UserBean</span></span><br><span class="line">Class c1 = Class.forName(``<span class="string">"com.test.UserBean"</span>``)；</span><br></pre></td></tr></table></figure><p><strong>2、类名.class</strong></p><p>通过类名的属性class获取，多用于传递参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c2 = UserBean.class;</span><br></pre></td></tr></table></figure><p><strong>3、对象.getClass()</strong></p><p>多用于对象获取字节码的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UserBean user = <span class="keyword">new</span> UserBean();</span><br><span class="line">Class c3 = user.getClass();</span><br></pre></td></tr></table></figure><p>对于三种方式获取到的类对象都指向堆内存中同一个地址，所以三种方式获取的类对象都是同一个，根据实际应用环境选择使用。</p>]]></content>
    
    <summary type="html">
    
      总结
    
    </summary>
    
      <category term="Java" scheme="http://benym.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="反射" scheme="http://benym.cn/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>海量数据TopK问题</title>
    <link href="http://benym.cn/2020/06/29/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AETopK%E9%97%AE%E9%A2%98/"/>
    <id>http://benym.cn/2020/06/29/海量数据TopK问题/</id>
    <published>2020-06-29T08:18:11.000Z</published>
    <updated>2020-06-29T11:28:11.883Z</updated>
    
    <content type="html"><![CDATA[<h2 id="海量数据TopK问题"><a href="#海量数据TopK问题" class="headerlink" title="海量数据TopK问题"></a>海量数据TopK问题</h2><p>在大规模数据处理中，经常会遇到这类问题：在海量数据中找到出现频率/数值最大的前K个数</p><p>本文主要提供这类问题的基本解决方法</p> <a id="more"></a><p>假设这样一个场景，一个问题阅读量越高，说明这个问题越有价值，越应该推送给用户</p><p>假设数据量有1亿，取Top100</p><ol><li>最容易想到的方法是将全部数据进行<strong>排序</strong>，但如果数据量太大 ，这显然是不能接受的。</li><li>第二种方法为<strong>局部淘汰法</strong>，该方法与排序方法类似，用一个容器保存前K个数，然后将剩余的所有数字——与容器内的最小数字相比，如果所有后续的元素都比容器内的K个数还小，那么容器内这个K个数就是最大K个数。如果某一后续元素比容器内最小数字大，则删掉容器内最小元素，并将该元素插入容器，最后遍历完这1亿个数，得到的结果容器中保存的数即为最终结果了。此时的时间复杂度为O（n+m^2），其中m为容器的大小，即K。</li><li>第三种方法是<strong>分治法</strong>，将1亿个数据分成100份，每份100万个数据，找到每份数据中最大的100个(即每份数据的TopK)，最后在剩下的100*100个数据里面找出最大的100个。如果100万数据选择足够理想，那么可以过滤掉1亿数据里面99%的数据。100万个数据里面查找最大的100个数据的方法如下：用快速排序的方法，将数据分为2堆，如果大的那堆个数N大于100个，继续对大堆快速排序一次分成2堆，如果大的那堆个数N大于100个，继续对大堆快速排序一次分成2堆，如果大堆个数N小于100个，就在小的那堆里面快速排序一次，找第100-n大的数字；递归以上过程，就可以找到第100大的数。参考上面的找出第100大数字，就可以类似的方法找到前100大数字了。</li><li>第四种方法是<strong>Hash法</strong>。如果这1亿个数里面有很多重复的数，先通过Hash法，把这1亿个数字去重复，这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间，然后通过分治法或最小堆法查找最大的100个数。</li><li>第五种方法采用<strong>最小堆</strong>。首先读入前100个数来创建大小为100的最小堆，然后遍历后续的数字，并于堆顶（最小）数字进行比较。如果比最小的数小，则继续读取后续数字；如果比堆顶数字大，则替换堆顶元素并重新调整堆为最小堆。整个过程直至1亿个数全部遍历完为止。然后按照中序遍历的方式输出当前堆中的所有100个数字。建堆时间复杂度是O(m)，堆调整的时间复杂度是O(logm)，最终的时间复杂度=1次建堆的时间+n次堆调整的时间，所以该算法的时间复杂度为O(nlogm)，空间复杂度是100（常数）。</li></ol><p><strong>代码示例：</strong></p><p>我们首先可以用HashMap去存储问题和阅读量的映射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line">String read;</span><br><span class="line">HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line"><span class="keyword">while</span> (fileStream.hasNext())&#123;</span><br><span class="line">    url = read();</span><br><span class="line">   <span class="keyword">if</span> (map.containsKey(read))&#123;</span><br><span class="line">        map.get(read)++;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        map.put(read, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后， 我们使用长度为100的<strong>最小堆</strong>来找到最热的100条数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Map.Entry&lt;String, Integer&gt;&gt; queue =</span><br><span class="line">    <span class="keyword">new</span> PriorityQueue&lt;Map.Entry&lt;String, Integer&gt;&gt;(<span class="number">100</span>,</span><br><span class="line">           <span class="keyword">new</span> Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Entry&lt;String, Integer&gt; o1, Entry&lt;String, Integer&gt; o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getValue() - o2.getValue();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">         </span><br><span class="line"><span class="keyword">int</span> k = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet())&#123;</span><br><span class="line">    <span class="keyword">if</span> (queue.size() &lt; k)&#123;</span><br><span class="line">        queue.add(entry);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue() &gt; queue.peek().getValue())&#123;</span><br><span class="line">            queue.poll();</span><br><span class="line">        queue.add(entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      总结
    
    </summary>
    
      <category term="Java" scheme="http://benym.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="TopK" scheme="http://benym.cn/tags/TopK/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-希尔排序</title>
    <link href="http://benym.cn/2020/06/28/LeetCode-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>http://benym.cn/2020/06/28/LeetCode-希尔排序/</id>
    <published>2020-06-28T09:16:04.000Z</published>
    <updated>2020-06-28T12:20:26.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-希尔排序"><a href="#LeetCode-希尔排序" class="headerlink" title="LeetCode-希尔排序"></a>LeetCode-希尔排序</h2><p>希尔排序算法回顾</p> <a id="more"></a><p><strong>示例1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [4,0,1,2,0,5]</span><br><span class="line">输出: [0,0,1,2,4,5]</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>希尔排序算法回顾</p><p>希尔排序是插入排序的一种又称”缩小增量排序”</p><p>它是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止</p><p>希尔排序是不稳定的排序算法，时间复杂度O(n^1.3)-O(n^2)</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        shellSort(arr);</span><br><span class="line">        <span class="keyword">for</span> (Integer i : arr) &#123;</span><br><span class="line">            System.out.print(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前正在比较的数字</span></span><br><span class="line">        <span class="keyword">int</span> current;</span><br><span class="line">        <span class="comment">//初始增量</span></span><br><span class="line">        <span class="keyword">int</span> gap = arr.length / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//gap==1的时候，数组已经有序</span></span><br><span class="line">        <span class="keyword">while</span> (gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;<span class="comment">//内部就是一个插入排序</span></span><br><span class="line">                current = arr[i];</span><br><span class="line">                <span class="comment">// 与current同组的前一个数字</span></span><br><span class="line">                <span class="keyword">int</span> preIndex = i - gap;</span><br><span class="line">                <span class="comment">// 找到同组内比current小的数字</span></span><br><span class="line">                <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; current &lt; arr[preIndex]) &#123;</span><br><span class="line">                    <span class="comment">// 向后移动同组内已排好序的，大于current的数字</span></span><br><span class="line">                    arr[preIndex + gap] = arr[preIndex];</span><br><span class="line">                    preIndex -= gap;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//插入current到相应的位置</span></span><br><span class="line">                arr[preIndex + gap] = current;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//缩小增量</span></span><br><span class="line">            gap /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      希尔排序
    
    </summary>
    
      <category term="算法" scheme="http://benym.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="排序算法" scheme="http://benym.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-插入排序</title>
    <link href="http://benym.cn/2020/06/28/LeetCode-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://benym.cn/2020/06/28/LeetCode-插入排序/</id>
    <published>2020-06-28T08:46:47.000Z</published>
    <updated>2020-06-28T09:15:09.779Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-插入排序"><a href="#LeetCode-插入排序" class="headerlink" title="LeetCode-插入排序"></a>LeetCode-插入排序</h2><p>插入排序算法回顾</p> <a id="more"></a><p><strong>示例1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [4,0,1,2,0,5]</span><br><span class="line">输出: [0,0,1,2,4,5]</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>插入排序算法回顾</p><p>插入排序是一种简单直观的排序算法，其基本原理是通过构建有序序列，对未排序的数组，需要在已排序的序列中从后向前进行扫描，找到相应位置并插入。在从后向前扫描的过程中，需要反复把已排序的元素向后移动，为新元素提供插入的空间。</p><p>插入排序是稳定的排序算法，时间复杂度O(n^(1-2))</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        insertSort(arr, arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer i : arr) &#123;</span><br><span class="line">            System.out.print(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            <span class="keyword">int</span> left = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; arr[left] &gt; temp) &#123;</span><br><span class="line">                arr[left + <span class="number">1</span>] = arr[left];</span><br><span class="line">                left--;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[left + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      插入排序
    
    </summary>
    
      <category term="算法" scheme="http://benym.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="排序算法" scheme="http://benym.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-选择排序</title>
    <link href="http://benym.cn/2020/06/28/LeetCode-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>http://benym.cn/2020/06/28/LeetCode-选择排序/</id>
    <published>2020-06-28T08:16:47.000Z</published>
    <updated>2020-06-28T08:47:06.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-选择排序"><a href="#LeetCode-选择排序" class="headerlink" title="LeetCode-选择排序"></a>LeetCode-选择排序</h2><p>选择排序算法回顾</p> <a id="more"></a><p><strong>示例1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [4,0,1,2,0,5]</span><br><span class="line">输出: [0,0,1,2,4,5]</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>选择排序算法回顾</p><p>选择排序是指每一趟从待排序的数据元素中选出最大（或最小）的一个元素，顺序放在已排好序的数列的最后，直到全部待排序的数据元素排完。时间复杂度O(n^2)，是不稳定的排序算法。</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        selectionSort(arr);</span><br><span class="line">        <span class="keyword">for</span> (Integer i : arr) &#123;</span><br><span class="line">            System.out.print(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = min + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[min] &gt; arr[j]) &#123;</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[min];</span><br><span class="line">                arr[min] = arr[i];</span><br><span class="line">                arr[i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      选择排序
    
    </summary>
    
      <category term="算法" scheme="http://benym.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="排序算法" scheme="http://benym.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-冒泡排序</title>
    <link href="http://benym.cn/2020/06/28/LeetCode-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>http://benym.cn/2020/06/28/LeetCode-冒泡排序/</id>
    <published>2020-06-28T08:02:20.000Z</published>
    <updated>2020-06-28T08:15:18.474Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-冒泡排序"><a href="#LeetCode-冒泡排序" class="headerlink" title="LeetCode-冒泡排序"></a>LeetCode-冒泡排序</h2><p>冒泡排序算法回顾</p> <a id="more"></a><p><strong>示例1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [4,0,1,2,0,5]</span><br><span class="line">输出: [0,0,1,2,4,5]</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>冒泡排序算法回顾，列表中两个相邻的数比较大小，如果前面的比后面的大，则交换位置</p><p>整个过程像冒泡一样，时间复杂度O(n^2)，是稳定的排序算法</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        bubbleSort(arr, arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer i : arr) &#123;</span><br><span class="line">            System.out.print(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      冒泡排序
    
    </summary>
    
      <category term="算法" scheme="http://benym.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="排序算法" scheme="http://benym.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程实现的几种方式</title>
    <link href="http://benym.cn/2020/06/28/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://benym.cn/2020/06/28/Java多线程实现的几种方式/</id>
    <published>2020-06-28T02:25:41.000Z</published>
    <updated>2020-06-28T03:12:33.342Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java多线程实现的几种方式"><a href="#Java多线程实现的几种方式" class="headerlink" title="Java多线程实现的几种方式"></a>Java多线程实现的几种方式</h2><p>多进程是计算机中的一个重要概念，通常一个任务称为一个进程，比如浏览网页、播放音乐都是一个进程。</p><p>在进程内部可能还需要执行多个子任务，比如在使用word文档打字的时候，不仅要进行字符打印，同时还要进行字符统计、拼接检查等任务。</p><p>进程和线程的关系是：一个进程可以包含一个或者多个线程，但至少会包含一个线程。</p><p>在Java中，多线程的学习是非常重要的，本文主要概括Java多线程实现的几种方式。</p> <a id="more"></a><p>Java中实现多进程的方式大概有3种：</p><ol><li>实现Runnable接口，重写run方法</li><li>继承Thread类，重写run方法(Thread类本身也实现了Runnable接口)</li><li>实现Callable接口，重写call方法(带有返回值)</li></ol><h4 id="通过Runnable接口实现多线程"><a href="#通过Runnable接口实现多线程" class="headerlink" title="通过Runnable接口实现多线程"></a>通过Runnable接口实现多线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"start new thread!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现Runnable接口的类，只定义了任务，自身不具有线程能力。需要通过Thread类的构造器来将任务驱动在一个线程中。</p><h4 id="通过继承Thread类实现"><a href="#通过继承Thread类实现" class="headerlink" title="通过继承Thread类实现"></a>通过继承Thread类实现</h4><p>Thread类中已经实现了Runnable接口，所以可以直接继承Thread类，覆写run方法实现多线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"New Thread : "</span>+Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">"Main Thread : "</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通过继承Callable接口实现"><a href="#通过继承Callable接口实现" class="headerlink" title="通过继承Callable接口实现"></a>通过继承Callable接口实现</h4><p>相较于实现Runnable接口，Callable方法可以有返回值，并且可以抛出异常</p><p>执行Callable方法，需要FutureTask实现类的支持，用于接受运算的结果，FutureTask是Future接口的实现</p><p>需要覆写call方法，运行Callable任务可以拿到一个Future对象，Future表示异步计算的结果</p><p>通过Future对象可了解任务执行情况，可取消任务的执行，还可以获取任务执行的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadDemo td = <span class="keyword">new</span> ThreadDemo();</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;Integer&gt; result = <span class="keyword">new</span> FutureTask&lt;&gt;(td);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(result).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer sum = result.get();</span><br><span class="line">            System.out.println(sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      总结
    
    </summary>
    
      <category term="Java" scheme="http://benym.cn/categories/Java/"/>
    
    
      <category term="多线程" scheme="http://benym.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-22-括号生成</title>
    <link href="http://benym.cn/2020/06/26/LeetCode-22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
    <id>http://benym.cn/2020/06/26/LeetCode-22-括号生成/</id>
    <published>2020-06-26T10:52:11.000Z</published>
    <updated>2020-06-26T12:30:29.257Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-22-括号生成"><a href="#LeetCode-22-括号生成" class="headerlink" title="LeetCode-22-括号生成"></a>LeetCode-22-括号生成</h2><p>数字 <em>n</em> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[</span><br><span class="line">       &quot;((()))&quot;,</span><br><span class="line">       &quot;(()())&quot;,</span><br><span class="line">       &quot;(())()&quot;,</span><br><span class="line">       &quot;()(())&quot;,</span><br><span class="line">       &quot;()()()&quot;</span><br><span class="line">     ]</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>方法1、DFS：</strong></p><p>深度优先遍历选择左括号和右括号，由于String拼接每次会产生一个新的String对象，所以传入的字符串不会影响其他结果，当左括号&gt;0时，左括号-1进入下一次拼接。只有当左右括号数目相等为n的时候，拼接的括号才是合法的，此时加入到最终结果，返回上一层。当左括号用完了的时候进行右括号的拼接</p><p><strong>方法2、回溯：</strong></p><p>回溯法基本上和DFS一致，只是这里的回溯需要手动回溯，由于String每次生成一个新的String对象耗时比较多，所以可以用StringBuilder，然而StringBuilder拼接的时候会把上一次的字符记录着，所以在DFS之后需要手动回溯，即删除上一层拼接的字符<code>cur.deleteCharAt(cur.length()-1);</code></p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        dfs(n,n,<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right,String curStr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="number">0</span>&amp;&amp;right==<span class="number">0</span>)&#123;</span><br><span class="line">            res.add(curStr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            dfs(left-<span class="number">1</span>,right,curStr+<span class="string">"("</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right&gt;left)&#123;</span><br><span class="line">            dfs(left,right-<span class="number">1</span>,curStr+<span class="string">")"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java代码2"><a href="#Java代码2" class="headerlink" title="Java代码2"></a>Java代码2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        backtrack(res, <span class="keyword">new</span> StringBuilder(), <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;String&gt; res,StringBuilder cur,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> max)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.length()==max*<span class="number">2</span>)&#123;</span><br><span class="line">            res.add(cur.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;max)&#123;</span><br><span class="line">            cur.append(<span class="string">'('</span>);</span><br><span class="line">            backtrack(res,cur,left+<span class="number">1</span>,right,max);</span><br><span class="line">            cur.deleteCharAt(cur.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right&lt;left)&#123;</span><br><span class="line">            cur.append(<span class="string">')'</span>);</span><br><span class="line">            backtrack(res,cur,left,right+<span class="number">1</span>,max);</span><br><span class="line">            cur.deleteCharAt(cur.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      括号生成
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="DFS" scheme="http://benym.cn/tags/DFS/"/>
    
      <category term="字符串" scheme="http://benym.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="回溯" scheme="http://benym.cn/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-19-删除链表的倒数第N个节点</title>
    <link href="http://benym.cn/2020/06/26/LeetCode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>http://benym.cn/2020/06/26/LeetCode-19-删除链表的倒数第N个节点/</id>
    <published>2020-06-26T08:38:24.000Z</published>
    <updated>2020-06-26T10:34:55.275Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-19-删除链表的倒数第N个节点"><a href="#LeetCode-19-删除链表的倒数第N个节点" class="headerlink" title="LeetCode-19-删除链表的倒数第N个节点"></a>LeetCode-19-删除链表的倒数第N个节点</h2><p>给定一个链表，删除链表的倒数第 <em>n</em> 个节点，并且返回链表的头结点。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>给定的 <em>n</em> 保证是有效的。</p><p><strong>进阶：</strong></p><p>你能尝试使用一趟扫描实现吗？</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>方法1、双指针：</strong></p><p>两次遍历是一定能找到的，但是这样复杂度比较高，所以直接能想到的是使用双指针来进行操作，一次遍历即可完成</p><p>快指针先走n+1步，之后慢指针和快指针一起走</p><p>当快指针走到末尾时，慢指针刚好指向要删除节点的前一个节点，改变指向就可以完成节点删除。</p><p>其中需要初始化1个哑结点作为辅助，该节点位于列表头部，用来简化某些特例，比如列表中只含有一个节点，或者需要删除列表的头部。</p><p>快指针和慢指针的间隔始终是n</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;n+<span class="number">1</span>; i++) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = pre.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      删除链表的倒数第N个节点
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="链表" scheme="http://benym.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>利用AOP实现操作日志</title>
    <link href="http://benym.cn/2020/06/26/%E5%88%A9%E7%94%A8AOP%E5%AE%9E%E7%8E%B0%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97/"/>
    <id>http://benym.cn/2020/06/26/利用AOP实现操作日志/</id>
    <published>2020-06-26T02:54:58.000Z</published>
    <updated>2020-06-26T07:36:25.941Z</updated>
    
    <content type="html"><![CDATA[<h2 id="利用AOP实现操作日志"><a href="#利用AOP实现操作日志" class="headerlink" title="利用AOP实现操作日志"></a>利用AOP实现操作日志</h2><p>AOP能够实现一些前置或者后置任务，作为一个切面，来完成例如日志记录、性能统计、安全控制、事务处理、异常处理等任务。这篇文章主要是总结自己利用AOP去实现全局操作日志记录功能的步骤。</p> <a id="more"></a><p>要完成日志功能的记录和查询首先需要一个数据库表，命名为sysLog</p><p>包含id、visitTime、username、ip、url、executionTime、method字段</p><p>分别代表主键、访问时间、操作者用户名、访问ip、访问资源url、执行时长、访问方法。</p><p>创建一个对应的实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SysLog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> Date visitTime;</span><br><span class="line">    <span class="keyword">private</span> String visitTimeStr;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> Long executionTime;</span><br><span class="line">    <span class="keyword">private</span> String method;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建AOP切面</p><ol><li><p>前置通知：</p><p>开始时间的获取直接new Date()即可</p><p>利用JoinPoint对象的<code>getTarget()</code>方法可以获得被代理的对象，之后通过getClass()获取要访问的类</p><p>那么如何去获得类中的方法名称呢？</p><p>JoinPoint中还有一个方法叫<code>getSignature()</code>用于获取封装了署名信息的对象，在该对象中可以获取到目标方</p><p>法名，所属类的Class等信息</p><p>除此之外还可以通过<code>getArgs()</code>方法获取传入目标方法的参数对象</p></li><li><p>后置通知：</p><p>结束时间可以直接用new Date().getTime()减去开始时间，即可获得访问时长了</p><p>我们还想要获取Controller中执行注解的url，有一下几个步骤：</p><p>当访问的类、访问的方法不为空且当前的类不是AOP这个类的时候，进行反射url获取</p><p>我们可以通过<code>getAnnotation(xxx.class)</code>获取class的注解，并通过<code>.value()</code>找到对应的RequesMapping映</p><p>射值，在这里我们分别通过<code>clazz.getAnnotation</code>和<code>method.getAnnotation</code>获取对应的类和方法上的url</p><p>之后进行字符串拼接即可得到完整的操作路径。</p><p>如何获取IP地址呢？如果我们能够拿到request对象，那么获取ip地址就比较容易，这里采用了Spring提供的</p><p><code>org.springframework.web.context.request.RequestContextListener</code>，在LogAop中我们可以注入一</p><p>个<code>HttpServletRequest request</code>，通过<code>request.getRemoteAddr()</code>获取ip地址。</p><p>由于当前的用户受到SpringSecurity的控制，所以获取操作用户的对象，也必须从SpringSecurity的上下文中获取</p><p>具体代码如下，获取的User非用户定义，而是SpringSecurity中提供的User；</p><p>或者通过<code>request.getSession().getAttribute(&quot;SPRING_SECURITY_CONTEXT&quot;)</code>也可以获取User对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SecurityContext context = SecurityContextHolder.getContext();<span class="comment">// 从上下文中获取当前登陆的用户</span></span><br><span class="line">User user = (User) context.getAuthentication().getPrincipal();</span><br><span class="line">String username = user.getUsername();</span><br></pre></td></tr></table></figure><p>之后可以对上面的信息进行数据存储，或者查询操作</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HttpServletRequest request;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ISysLogService sysLogService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date visitTime; <span class="comment">// 开始时间</span></span><br><span class="line">    <span class="keyword">private</span> Class clazz;<span class="comment">// 访问的类</span></span><br><span class="line">    <span class="keyword">private</span> Method method;<span class="comment">// 访问的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//前置通知 主要是获取开始时间，执行的类是哪一个，执行的是哪一个方法</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* com.cqupt.lesson.controller.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint jp)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">        visitTime = <span class="keyword">new</span> Date();<span class="comment">// 当前时间是就是开始访问的时间</span></span><br><span class="line">        clazz = jp.getTarget().getClass();<span class="comment">// 具体要访问的类</span></span><br><span class="line">        String methodName = jp.getSignature().getName();<span class="comment">// 获取访问的方法的名称</span></span><br><span class="line">        Object[] args = jp.getArgs();<span class="comment">// 获取访问的方法的参数</span></span><br><span class="line">        <span class="comment">// 获取具体执行方法的Method对象</span></span><br><span class="line">        <span class="keyword">if</span> (args == <span class="keyword">null</span> || args.length == <span class="number">0</span>) &#123;</span><br><span class="line">            method = clazz.getMethod(methodName);<span class="comment">// 只能获取无参数的方法</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 构建Class[]数组</span></span><br><span class="line">            Class[] classArgs = <span class="keyword">new</span> Class[args.length];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                classArgs[i] = args[i].getClass();</span><br><span class="line">            &#125;</span><br><span class="line">            clazz.getMethod(methodName, classArgs);<span class="comment">// 获取有参的方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后置通知</span></span><br><span class="line">    <span class="comment">//通过反射完成方法体的寻找</span></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"execution(* com.cqupt.lesson.controller.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">(JoinPoint jp)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> time = <span class="keyword">new</span> Date().getTime() - visitTime.getTime();<span class="comment">// 获取访问时长</span></span><br><span class="line"></span><br><span class="line">        String url = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">// 获取url</span></span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="keyword">null</span> &amp;&amp; method != <span class="keyword">null</span> &amp;&amp; clazz != LogAop.class) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//1、获取类上的@RequestMapping("/orders")</span></span><br><span class="line">            RequestMapping classAnnotation = (RequestMapping) clazz.getAnnotation(RequestMapping.class);</span><br><span class="line">            <span class="keyword">if</span> (classAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">                String[] classValue = classAnnotation.value();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//2、获取方法上的@RequestMapping("/findAll")</span></span><br><span class="line">                RequestMapping methodAnnotation = method.getAnnotation(RequestMapping.class);</span><br><span class="line">                <span class="keyword">if</span> (methodAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    String[] methodValue = methodAnnotation.value();</span><br><span class="line">                    url = classValue[<span class="number">0</span>] + methodValue[<span class="number">0</span>];</span><br><span class="line">                    <span class="comment">// 获取访问的ip地址</span></span><br><span class="line">                    String ip = request.getRemoteAddr();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 获取当前操作的用户</span></span><br><span class="line">                    SecurityContext context = SecurityContextHolder.getContext();<span class="comment">// 从上下文中获取当前登陆的用户</span></span><br><span class="line">                    User user = (User) context.getAuthentication().getPrincipal();</span><br><span class="line">                    String username = user.getUsername();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//将日志相关信息封装到SysLog对象</span></span><br><span class="line">                    SysLog sysLog = <span class="keyword">new</span> SysLog();</span><br><span class="line">                    sysLog.setExecutionTime(time);<span class="comment">//执行时长</span></span><br><span class="line">                    sysLog.setIp(ip);</span><br><span class="line">                    sysLog.setMethod(<span class="string">"[类名] "</span> + clazz.getName() + <span class="string">"[方法名] "</span> + method.getName());</span><br><span class="line">                    sysLog.setUrl(url);</span><br><span class="line">                    sysLog.setUsername(username);</span><br><span class="line">                    sysLog.setVisitTime(visitTime);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//调用Service完成操作</span></span><br><span class="line">                    sysLogService.save(sysLog);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      使用总结
    
    </summary>
    
      <category term="Java" scheme="http://benym.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="AOP" scheme="http://benym.cn/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>Redis实现共享Session</title>
    <link href="http://benym.cn/2020/06/25/Redis%E5%AE%9E%E7%8E%B0%E5%85%B1%E4%BA%ABSession/"/>
    <id>http://benym.cn/2020/06/25/Redis实现共享Session/</id>
    <published>2020-06-25T08:30:43.000Z</published>
    <updated>2020-06-26T02:23:34.558Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis实现共享Session"><a href="#Redis实现共享Session" class="headerlink" title="Redis实现共享Session"></a>Redis实现共享Session</h2><p>Session共享，一般有一个这样的场景。以往单机的项目，数据请求都是在一个服务器上，session保存在这个服务器上自然是没有问题的。但是如果项目需要部署在多台服务器上的时候，session就会存在共享的问题</p> <a id="more"></a><p>举一个例子：</p><p>假如现在有两台服务器同时运行，分别是ServerA和ServerB。</p><p>假设第一次请求(登陆请求)被分配到了A进行处理，A收到请求之后会生成一个sessionId并保存到内存中，然后返回给用户(浏览器)，浏览器会把sessionId保存到cookie中，第一次请求完成。如果之后每一次请求还是由A来进行处理，那么一切正常。如果A服务器挂掉了，这时候请求被分配到B，B拿到的sessionId是由A生成的，两边就对不上了。于是用户会发现，需要重新登陆了。</p><p>那么这样的问题应该怎么样去解决呢？</p><p>首先，问题的根源出在sessionId无法共享上，想要把sessionId共享，一个简单的思路就是把sessionId保存到数据库中(这里选择redis)，这样验证的时候就不再从当前服务器获取sessionId了，而改为了从redis中获取</p><p>实现思路如下：</p><ol><li>登陆页面提交用户名密码</li><li>登陆成功之后生成token。Token相当于原来的sessionId，字符串等，可以使用UUID</li><li>把用户信息保存到redis中。Key就是token，value就是userId</li><li>设置key的过期时间。模拟Session的过期时间</li><li>拦截器请求校验sessionId</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>登陆成功，生成sessionId存入redis</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SysUserMapper sysUserMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisService redisService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LoginRespVo <span class="title">login</span><span class="params">(LoginReqVo vo)</span> </span>&#123;</span><br><span class="line">        SysUser sysUser = sysUserMapper.selectByUsername(vo.getUsername());</span><br><span class="line">        <span class="keyword">if</span>(sysUser==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(<span class="number">4001005</span>,<span class="string">"不存在该用户,请先注册"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sysUser.getStatus()==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(<span class="number">4001006</span>,<span class="string">"该帐号已被禁用"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!PasswordUtils.matches(sysUser.getSalt(),vo.getPassword(),sysUser.getPassword()))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(<span class="number">4001007</span>,<span class="string">"用户名密码不匹配"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String token = UUID.randomUUID().toString();</span><br><span class="line">        LoginRespVo respVo = <span class="keyword">new</span> LoginRespVo();</span><br><span class="line">        respVo.setUserId(sysUser.getId());</span><br><span class="line">        respVo.setToken(token);</span><br><span class="line">        redisService.set(token,sysUser.getId(),<span class="number">60</span>, TimeUnit.MINUTES);</span><br><span class="line">        redisService.set(sysUser.getId(),token,<span class="number">60</span>,TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> respVo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中LoginRespVo类为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cqupt.lesson.vo.req;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModelProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginReqVo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"用户名"</span>)</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"密码"</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SessionInterceptor拦截器校验sessionId，拦截器实现HandlerInterceptor的preHandle方法，可以获取从头部获取token或者从cookie获取token，之后进行token的验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cqupt.lesson.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.cqupt.lesson.exception.BusinessException;</span><br><span class="line"><span class="keyword">import</span> com.cqupt.lesson.service.RedisService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisService redisService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String token = request.getHeader(<span class="string">"token"</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(token))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(<span class="number">4001002</span>,<span class="string">"用户凭证不能为空"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(!redisService.hasKey(token))&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(<span class="number">4001002</span>,<span class="string">"用户凭证无效"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            String userId = (String) redisService.get(token);</span><br><span class="line">            <span class="keyword">if</span>(redisService.hasKey(userId)&amp;&amp;!token.equals(redisService.get(userId)))&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(<span class="number">4001002</span>,<span class="string">"帐号已在异地登陆"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后设置一个web拦截器，并注入自定义的拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cqupt.lesson.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.cqupt.lesson.interceptor.TokenInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebAppConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TokenInterceptor <span class="title">tokenInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TokenInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(tokenInterceptor()).addPathPatterns(<span class="string">"/api/**"</span>).excludePathPatterns(<span class="string">"/api/user/login"</span>,<span class="string">"/api/user/register"</span>,<span class="string">"/api/user/code/*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>登陆Service代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SysUserMapper sysUserMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisService redisService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LoginRespVo <span class="title">login</span><span class="params">(LoginReqVo vo)</span> </span>&#123;</span><br><span class="line">        SysUser sysUser = sysUserMapper.selectByUsername(vo.getUsername());</span><br><span class="line">        <span class="keyword">if</span>(sysUser==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(<span class="number">4001005</span>,<span class="string">"不存在该用户,请先注册"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sysUser.getStatus()==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(<span class="number">4001006</span>,<span class="string">"该帐号已被禁用"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!PasswordUtils.matches(sysUser.getSalt(),vo.getPassword(),sysUser.getPassword()))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(<span class="number">4001007</span>,<span class="string">"用户名密码不匹配"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String token = UUID.randomUUID().toString();</span><br><span class="line">        LoginRespVo respVo = <span class="keyword">new</span> LoginRespVo();</span><br><span class="line">        respVo.setUserId(sysUser.getId());</span><br><span class="line">        respVo.setToken(token);</span><br><span class="line">        redisService.set(token,sysUser.getId(),<span class="number">60</span>, TimeUnit.MINUTES);</span><br><span class="line">        redisService.set(sysUser.getId(),token,<span class="number">60</span>,TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> respVo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>登陆Controller实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/api"</span>)</span><br><span class="line"><span class="meta">@Api</span>(tags = <span class="string">"用户模块"</span>,description = <span class="string">"用户模块相关接口"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/user/login"</span>)</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"用户登陆接口"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> LoginRespVo <span class="title">login</span><span class="params">(@RequestBody LoginReqVo vo)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.login(vo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      使用总结
    
    </summary>
    
      <category term="Java" scheme="http://benym.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Redis" scheme="http://benym.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>自定义RedisTemplate</title>
    <link href="http://benym.cn/2020/06/25/%E8%87%AA%E5%AE%9A%E4%B9%89RedisTemplate/"/>
    <id>http://benym.cn/2020/06/25/自定义RedisTemplate/</id>
    <published>2020-06-25T07:36:22.000Z</published>
    <updated>2020-06-25T08:25:18.207Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自定义RedisTemplate"><a href="#自定义RedisTemplate" class="headerlink" title="自定义RedisTemplate"></a>自定义RedisTemplate</h2><p>在Spring Data Redis中，有一个高度封装的<code>RedisTemplate</code>类，实现了对Redis客户端的操作，其中提供了针对数据的<code>StringRedisSerializer</code>序列化方式，但这只能序列化String类型的Key和Value。在日常的数据处理中，通常会面对存储一个对象数据的任务，所以需要定义一个自己的序列化和反序列化方法。</p> <a id="more"></a><h3 id="Redis基本数据结构"><a href="#Redis基本数据结构" class="headerlink" title="Redis基本数据结构"></a>Redis基本数据结构</h3><p>RedisTemplate中定义了对应的redis五种数据结构操作：</p><ul><li>opsForValue();//操作字符串</li><li>opsForHash();//操作hash</li><li>opsForList();  //操作list</li><li>opsForSet();  //操作set</li><li>opsForZSet();//操作有序set</li></ul><p>RedisTemplate可以直接通过@Autowired获取对象引用，<strong>为什么能够直接声明获取引用呢</strong>？</p><ul><li>在spring boot启动后会向spring 注入两个bean RedisTemplate、StringRedisTemplate</li><li>源码中StringRedisTemplate继承自RedisTemplate</li><li>RedisTemplate是一个泛型类，而StringRedisTemplate则不是</li><li>StringRedisTemplate只能对key=String，value=String的键值对进行操作，RedisTemplate可以对任何类型的key-value键值对操作</li><li>他们各自序列化的方式不同，但最终都是得到了一个字节数组，殊途同归，StringRedisTemplate使用的是<br>StringRedisSerializer类；RedisTemplate使用的是JdkSerializationRedisSerializer类。反序列化，则是一个得到String，一个得到Object</li></ul><p>RedisTemplate在操作数据的时候，存入数据会将数据先序列化成<strong>字节数组</strong>然后在存入Redis数据库(默认<br>JdkSerializationRedisSerializer:这个序列化方法就是Jdk提供的了,首先要求我们要被序列化的类继承自Serializeable接口，然后通过Jdk对象序列化的方法保存)，这个时候打开Redis查看的时候，你会看到你的数据不是以可读的形式，展现的，而是以字节数组显示。</p><p>而StringRedisSerializer在操作数据的时候就是通过String.getBytes()来实现的。而且在Redis中，所有存储的值都是字符串类型的。所以这种方法保存后，通过Redis-cli控制台或者Redis-Desktop-Manager图形化工具，是可以清楚的查看到我们保存了什么key,value是什么。</p><p>如当我们从以前的项目升级为RedisTemplate在不指定序列化方式的时候取不到原来的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> RedisTemplate  redisTemplate;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRedisTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(redisTemplate.opsForValue().get(<span class="string">"username"</span>));</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> 输出：<span class="keyword">null</span></span><br></pre></td></tr></table></figure><p>这是因为升级成RedisTemplate他的默认使用序列化是JdkSerializationRedisSerializer，所以当需要获取数据的时候就找不到数据了(因为拿key去匹配的时候两种序列化得到的byte数组是不一样的)。</p><p>我们把RedisTemplate序列化方式设置成StringRedisSerializer看看效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRedisTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">"username"</span>,<span class="string">"张三"</span>);</span><br><span class="line">    StringRedisSerializer stringRedisSerializer=<span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">    redisTemplate.setKeySerializer(stringRedisSerializer);</span><br><span class="line">    redisTemplate.setValueSerializer(stringRedisSerializer);</span><br><span class="line">    System.out.println(redisTemplate.opsForValue().get(<span class="string">"username"</span>));</span><br><span class="line"> &#125;</span><br><span class="line">输出：张三</span><br></pre></td></tr></table></figure><p>当我们指定使用StringRedisSerializer做value的序列化时，StringRedisSerializer的泛型指定的是String，传其他对象就会报类不能转换为String的异常</p><p>我们希望redis能够保存对象数据，就应该要自定义StringRedisSerializer</p><p>在StringRedisSerializer的源码中，它继承了<code>RedisSerializer&lt;String&gt;</code>，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">package</span> org.springframework.data.redis.serializer;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.Assert;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringRedisSerializer</span> <span class="keyword">implements</span> <span class="title">RedisSerializer</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Charset charset;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> StringRedisSerializer US_ASCII;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> StringRedisSerializer ISO_8859_1;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> StringRedisSerializer UTF_8;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">StringRedisSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(StandardCharsets.UTF_8);</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">StringRedisSerializer</span><span class="params">(Charset charset)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(charset, <span class="string">"Charset must not be null!"</span>);</span><br><span class="line">    <span class="keyword">this</span>.charset = charset;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">deserialize</span><span class="params">(@Nullable <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bytes == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> String(bytes, <span class="keyword">this</span>.charset);</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(<span class="meta">@Nullable</span> String string) &#123;</span><br><span class="line">    <span class="keyword">return</span> string == <span class="keyword">null</span> ? <span class="keyword">null</span> : string.getBytes(<span class="keyword">this</span>.charset);</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    US_ASCII = <span class="keyword">new</span> StringRedisSerializer(StandardCharsets.US_ASCII);</span><br><span class="line">    ISO_8859_1 = <span class="keyword">new</span> StringRedisSerializer(StandardCharsets.ISO_8859_1);</span><br><span class="line">    UTF_8 = <span class="keyword">new</span> StringRedisSerializer(StandardCharsets.UTF_8);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义redis序列化工具类"><a href="#自定义redis序列化工具类" class="headerlink" title="自定义redis序列化工具类"></a>自定义redis序列化工具类</h3><p>将传入的Object对象转化为JSON字符串，之后再变为字节数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cqupt.lesson.serializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.SerializationException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.Assert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStringRedisSerializer</span> <span class="keyword">implements</span> <span class="title">RedisSerializer</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Charset charset;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStringRedisSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStringRedisSerializer</span><span class="params">(Charset charset)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(charset, <span class="string">"Charset must not be null!"</span>);</span><br><span class="line">        <span class="keyword">this</span>.charset = charset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(Object object) <span class="keyword">throws</span> SerializationException &#123;</span><br><span class="line">        <span class="keyword">if</span>(object==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(object <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">            <span class="keyword">return</span> object.toString().getBytes(charset);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            String string = JSON.toJSONString(object);</span><br><span class="line">            <span class="keyword">return</span> string.getBytes(charset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> SerializationException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (bytes == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> String(bytes, charset));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时需要加入fastjson依赖，创建一个<code>RedisConfig</code>配置类，设置2种key-value的序列化方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cqupt.lesson.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.cqupt.lesson.serializer.MyStringRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String,Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span></span>&#123;</span><br><span class="line">        RedisTemplate&lt;String,Object&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        redisTemplate.setHashKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        redisTemplate.setValueSerializer(<span class="keyword">new</span> MyStringRedisSerializer());</span><br><span class="line">        redisTemplate.setHashValueSerializer(<span class="keyword">new</span> MyStringRedisSerializer());</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后自定义一个RedisService类，接管RedisTemplate的功能，并在此基础上进行一点判空修改(代码过长，只贴一部分)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String,Object&gt; redisTemplate;</span><br><span class="line">    <span class="comment">/** -------------------key相关操作--------------------- */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否存在key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>:      YuanMing</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@UpdateUser</span>:</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Version</span>:     0.0.1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>       java.lang.Boolean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">hasKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span>==key)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.hasKey(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>:      YuanMing</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@UpdateUser</span>:</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Version</span>:     0.0.1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>       Boolean  成功返回true 失败返回false</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">delete</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span>==key)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      使用总结
    
    </summary>
    
      <category term="Java" scheme="http://benym.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Redis" scheme="http://benym.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-17-电话号码的字母组合</title>
    <link href="http://benym.cn/2020/06/24/LeetCode-17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <id>http://benym.cn/2020/06/24/LeetCode-17-电话号码的字母组合/</id>
    <published>2020-06-24T07:51:32.000Z</published>
    <updated>2020-06-24T09:20:29.898Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-17-电话号码的字母组合"><a href="#LeetCode-17-电话号码的字母组合" class="headerlink" title="LeetCode-17-电话号码的字母组合"></a>LeetCode-17-电话号码的字母组合</h2><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p> <a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</span><br></pre></td></tr></table></figure><p><strong>说明:</strong><br>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>方法1、回溯：</strong></p><p>首先需要建立一个map，存储数字到字符串的映射</p><p>排列组合问题一般想象成树形问题，可以进行回溯选择</p><p>本题中回溯的停止条件是当深度达到输入字符长度的时候</p><p>回溯流程：</p><ul><li>选择第一个输入的数字</li><li>找到这个数字对应的字母列表，并选择第一个字母加入到<code>tmp</code>中</li><li>开启下一层递归</li><li>当加入过一个答案之后，进行回溯，即删除刚选择的最后一个字符，选择另外的路走</li></ul><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;() &#123;&#123;</span><br><span class="line">            put(<span class="string">"2"</span>, <span class="string">"abc"</span>);</span><br><span class="line">            put(<span class="string">"3"</span>, <span class="string">"def"</span>);</span><br><span class="line">            put(<span class="string">"4"</span>, <span class="string">"ghi"</span>);</span><br><span class="line">            put(<span class="string">"5"</span>, <span class="string">"jkl"</span>);</span><br><span class="line">            put(<span class="string">"6"</span>, <span class="string">"mno"</span>);</span><br><span class="line">            put(<span class="string">"7"</span>, <span class="string">"pqrs"</span>);</span><br><span class="line">            put(<span class="string">"8"</span>, <span class="string">"tuv"</span>);</span><br><span class="line">            put(<span class="string">"9"</span>, <span class="string">"wxyz"</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    StringBuilder tmp = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits==<span class="keyword">null</span>||digits.length()==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        backtrack(digits,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(String digits,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=digits.length())&#123;</span><br><span class="line">            res.add(tmp.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String letter = map.get(digits.substring(index,index+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;letter.length();i++)&#123;</span><br><span class="line">            tmp.append(letter.charAt(i));</span><br><span class="line">            backtrack(digits,index+<span class="number">1</span>);</span><br><span class="line">            tmp.deleteCharAt(tmp.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      电话号码的字母组合
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="LeetCode" scheme="http://benym.cn/tags/LeetCode/"/>
    
      <category term="字符串" scheme="http://benym.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-215-数组中的第K个最大元素</title>
    <link href="http://benym.cn/2020/06/24/LeetCode-215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    <id>http://benym.cn/2020/06/24/LeetCode-215-数组中的第K个最大元素/</id>
    <published>2020-06-24T02:18:17.000Z</published>
    <updated>2020-06-24T07:06:06.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-215-数组中的第K个最大元素"><a href="#LeetCode-215-数组中的第K个最大元素" class="headerlink" title="LeetCode-215-数组中的第K个最大元素"></a>LeetCode-215-数组中的第K个最大元素</h2><p>在未排序的数组中找到第 <strong>k</strong> 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p> <a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4] 和 k = 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3,1,2,4,5,5,6] 和 k = 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>方法1、优先队列：</strong></p><p>首先想到的是给数组进行排序，排序之后就很容易找到第k个最大的元素</p><p>那么有没有不排序的方法，自然就会想到建立堆来进行操作</p><p>我们可以建立一个大顶堆，最大的数在建堆的过程中排最上面，一次遍历就能完成数组从大到小的构建</p><p>寻找排序之后的第k个最大的元素，也就是寻找大顶堆的正序第k个元素</p><p>之后一直弹出到k-1为止，下一个位置就是第k个最大的元素</p><p><strong>方法2、暴力破解：</strong></p><p>排序之后，倒置一下，第k-1个位置就是第k个最大的元素，不倒置就是nums.length-k个位置</p><p><strong>方法3、快速选择：</strong></p><p>摘自<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcode/" target="_blank" rel="noopener">LeetCode官方题解</a></p><p>就像快速排序那样，本算法也是 Tony Hoare 发明的，因此也被称为 Hoare选择算法。</p><p>本方法大致上与快速排序相同。简便起见，注意到第 k 个最大元素也就是第 N - k 个最小元素，因此可以用第 k 小算法来解决本问题。</p><p>首先，我们选择一个枢轴，并在线性时间内定义其在排序数组中的位置。这可以通过 划分算法 的帮助来完成。</p><p>为了实现划分，沿着数组移动，将每个元素与枢轴进行比较，并将小于枢轴的所有元素移动到枢轴的左侧。</p><p>这样，在输出的数组中，枢轴达到其合适位置。所有小于枢轴的元素都在其左侧，所有大于或等于的元素都在其右侧。</p><p>这样，数组就被分成了两部分。如果是快速排序算法，会在这里递归地对两部分进行快速排序。</p><p>而在这里，由于知道要找的第 N - k 小的元素在哪部分中，我们不需要对两部分都做处理。</p><p>最终的算法十分直接了当 :</p><ul><li><p>随机选择一个枢轴。</p></li><li><p>使用划分算法将枢轴放在数组中的合适位置 pos。将小于枢轴的元素移到左边，大于等于枢轴的元素移到右边。</p></li><li><p>比较 pos 和 N - k 以决定在哪边继续递归处理。</p></li></ul><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            Arrays.sort(nums);</span><br><span class="line">            <span class="keyword">return</span> nums[len - k];</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((v1,v2)-&gt;v2-v1);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            queue.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()&amp;&amp;i&lt;k-<span class="number">1</span>)&#123;</span><br><span class="line">            queue.poll();</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        nums.sort(reverse=<span class="keyword">True</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[k<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h3 id="Java代码2"><a href="#Java代码2" class="headerlink" title="Java代码2"></a>Java代码2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nums;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="keyword">this</span>.nums[a];</span><br><span class="line">        <span class="keyword">this</span>.nums[a] = <span class="keyword">this</span>.nums[b];</span><br><span class="line">        <span class="keyword">this</span>.nums[b] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> pivot_index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 优化之后的快排，比枢轴元素大的理论应该放右边，但右边这部分甚至不需要排序</span></span><br><span class="line">        <span class="comment">// 只需要找到N-k个位置就可以了</span></span><br><span class="line">        <span class="keyword">int</span> pivot = <span class="keyword">this</span>.nums[pivot_index];</span><br><span class="line">        <span class="comment">// 1. 移动枢轴到最右</span></span><br><span class="line">        swap(pivot_index, right);</span><br><span class="line">        <span class="keyword">int</span> store_index = left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 移动所有小的元素到枢轴左边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.nums[i] &lt; pivot) &#123;</span><br><span class="line">                swap(store_index, i);</span><br><span class="line">                store_index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 还原枢轴到最终位置，左边的元素全部比他小</span></span><br><span class="line">        swap(store_index, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> store_index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">quickselect</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k_smallest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) <span class="comment">// 如果list只包含一个元素</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.nums[left];  <span class="comment">// 则返回这个元素</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择一个随机的枢轴</span></span><br><span class="line">        Random random_num = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> pivot_index = left + random_num.nextInt(right - left);</span><br><span class="line"></span><br><span class="line">        pivot_index = partition(left, right, pivot_index);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枢轴在N-k小的位置上，比较pos和N-k</span></span><br><span class="line">        <span class="keyword">if</span> (k_smallest == pivot_index)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.nums[k_smallest];</span><br><span class="line">            <span class="comment">// 左递归</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (k_smallest &lt; pivot_index)</span><br><span class="line">            <span class="keyword">return</span> quickselect(left, pivot_index - <span class="number">1</span>, k_smallest);</span><br><span class="line">        <span class="comment">// 右递归</span></span><br><span class="line">        <span class="keyword">return</span> quickselect(pivot_index + <span class="number">1</span>, right, k_smallest);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nums = nums;</span><br><span class="line">        <span class="keyword">int</span> size = nums.length;</span><br><span class="line">        <span class="comment">// 第k个最大的元素，也就是第N-k个最小的元素</span></span><br><span class="line">        <span class="keyword">return</span> quickselect(<span class="number">0</span>, size - <span class="number">1</span>, size - k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      数组中的第K个最大元素
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="LeetCode" scheme="http://benym.cn/tags/LeetCode/"/>
    
      <category term="Python" scheme="http://benym.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-20-有效的括号</title>
    <link href="http://benym.cn/2020/06/24/LeetCode-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>http://benym.cn/2020/06/24/LeetCode-20-有效的括号/</id>
    <published>2020-06-24T01:37:20.000Z</published>
    <updated>2020-06-24T02:14:43.907Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-20-有效的括号"><a href="#LeetCode-20-有效的括号" class="headerlink" title="LeetCode-20-有效的括号"></a>LeetCode-20-有效的括号</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p>注意空字符串可被认为是有效字符串。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;()&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;(]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;([)]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例5：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>方法1、栈：</p><p>观察题目可知，要想构成有效的括号，最开始加入的<code>(</code>括号的反<code>)</code>必须是最后加入</p><p>这种规律符合栈的先进后出的方式，于是可以用栈来模拟</p><p>当扫描到前括号<code>(</code>、<code>{</code>、<code>[</code>的时候，在栈中加入对应的反括号<code>)</code>,<code>}</code>,<code>]</code></p><p>当全部匹配时，栈为空等于true</p><p>特例处理当输入的字符为<code>null</code>的时候，直接返回true</p><p>当输入的字符为<code>[</code>的时候，栈中会加入反括号<code>]</code>，此时栈不为空，返回false</p><p>当输入的字符为<code>]</code>的时候，栈中不会加入反括号，此时如果直接返回栈是否为空，会返回true，但这是一个错误的结果</p><p>所以新增一个新的判断，<code>else if(stack.isEmpty()||c!=stack.pop())</code>联合判别反括号和栈空的情况，都是false</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>||s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] cs = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:cs)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">'('</span>)&#123;</span><br><span class="line">                stack.push(<span class="string">')'</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">'&#123;'</span>)&#123;</span><br><span class="line">                stack.push(<span class="string">'&#125;'</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">'['</span>)&#123;</span><br><span class="line">                stack.push(<span class="string">']'</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(stack.isEmpty()||c!=stack.pop())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      有效的括号
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="Python" scheme="http://benym.cn/tags/Python/"/>
    
      <category term="字符串" scheme="http://benym.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-15-三数之和</title>
    <link href="http://benym.cn/2020/06/23/LeetCode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://benym.cn/2020/06/23/LeetCode-15-三数之和/</id>
    <published>2020-06-23T09:01:45.000Z</published>
    <updated>2020-06-23T13:14:50.289Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-15-三数之和"><a href="#LeetCode-15-三数之和" class="headerlink" title="LeetCode-15-三数之和"></a>LeetCode-15-三数之和</h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p> <a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>方法1、双指针：</strong></p><p>不重复问题首先一步是要对数组进行排序</p><p>排序之后固定一个数nums[i]，之后利用左右指针找nums[left]+nums[right]+nums[i]==0的数，就可以添加进入结果集合</p><p>但过程中需要考虑数据重复的问题</p><p>如果nums[i]&gt;0，则说明三数之和必然无法等于0，直接跳出循环</p><p>如果nums[i]==nums[i-1]，则说明该数字重复，会导致重复的结果，所以直接跳过</p><p>之后当left&lt;right的时候，且</p><p>sum==0，nums[left]==nums[left+1]会导致重复的结果，应该跳过，所以left++</p><p>sum==0，nums[right]==nums[right-1]时，会导致重复的，应该跳过，所以right—</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(len&lt;<span class="number">3</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len-<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> left = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = len-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[left]+nums[right]==<span class="number">0</span>)&#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[i],nums[left],nums[right]));</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[left]==nums[left+<span class="number">1</span>]) left++;</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[right]==nums[right-<span class="number">1</span>]) right--;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]+nums[left]+nums[right]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      三数之和
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="LeetCode" scheme="http://benym.cn/tags/LeetCode/"/>
    
  </entry>
  
</feed>
