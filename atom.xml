<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ming.Y</title>
  
  <subtitle>Chances are for people who are prepared</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://benym.cn/"/>
  <updated>2020-09-20T13:01:28.449Z</updated>
  <id>http://benym.cn/</id>
  
  <author>
    <name>BenY</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode-679-24点游戏</title>
    <link href="http://benym.cn/2020/09/20/LeetCode-679-24%E7%82%B9%E6%B8%B8%E6%88%8F/"/>
    <id>http://benym.cn/2020/09/20/LeetCode-679-24点游戏/</id>
    <published>2020-09-20T02:32:30.000Z</published>
    <updated>2020-09-20T13:01:28.449Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-679-24点游戏"><a href="#LeetCode-679-24点游戏" class="headerlink" title="LeetCode-679-24点游戏"></a>LeetCode-679-24点游戏</h2><p>你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 <code>*</code>，<code>/</code>，<code>+</code>，<code>-</code>，<code>(</code>，<code>)</code> 的运算得到 24。</p> <a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [4, 1, 8, 7]</span><br><span class="line">输出: True</span><br><span class="line">解释: (8-4) * (7-1) = 24</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 2, 1, 2]</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure><p>注意:</p><ol><li>除法运算符 / 表示实数除法，而不是整数除法。例如 4 / (1 - 2/3) = 12 。</li><li>每个运算符对两个数进行运算。特别是我们不能用 - 作为一元运算符。例如，[1, 1, 1, 1] 作为输入时，表达式 -1 - 1 - 1 - 1 是不允许的。</li><li>你不能将数字连接在一起。例如，输入为 [1, 2, 1, 2] 时，不能写成 12 + 12 。</li></ol><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>题解来自<a href="https://leetcode-cn.com/problems/24-game/solution/24-dian-you-xi-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/24-game/solution/24-dian-you-xi-by-leetcode-solution/</a></p><p><strong>方法1、回溯：</strong></p><p>一共有 4 个数和 3 个运算操作，因此可能性非常有限。一共有多少种可能性呢？</p><p>首先从 4 个数字中有序地选出 2 个数字，共有 4×3=12 种选法，并选择加、减、乘、除 4 种运算操作之一，用得到的结果取代选出的 2个数字，剩下 3个数字。</p><p>然后在剩下的 3 个数字中有序地选出 2 个数字，共有3×2=6 种选法，并选择 4 种运算操作之一，用得到的结果取代选出的 2 个数字，剩下 2 个数字。</p><p>最后剩下 2 个数字，有 2 种不同的顺序，并选择 4 种运算操作之一。</p><p>因此，一共有12×4×6×4×2×4=9216 种不同的可能性。</p><p>可以通过回溯的方法遍历所有不同的可能性。具体做法是，使用一个列表存储目前的全部数字，每次从列表中选出 2 个数字，再选择一种运算操作，用计算得到的结果取代选出的 2 个数字，这样列表中的数字就减少了 1 个。重复上述步骤，直到列表中只剩下 1 个数字，这个数字就是一种可能性的结果，如果结果等于 24，则说明可以通过运算得到 24。如果所有的可能性的结果都不等于 24，则说明无法通过运算得到 24。</p><p>实现时，有一些细节需要注意。</p><ul><li><p>除法运算为实数除法，因此结果为浮点数，列表中存储的数字也都是浮点数。在判断结果是否等于 2424 时应考虑精度误差，这道题中，误差小于 10^{-6}可以认为是相等。</p></li><li><p>进行除法运算时，除数不能为 0，如果遇到除数为 0 的情况，则这种可能性可以直接排除。由于列表中存储的数字是浮点数，因此判断除数是否为 00 时应考虑精度误差，这道题中，当一个数字的绝对值小于 10^{-6} 时，可以认为该数字等于 00。</p></li></ul><p>还有一个可以优化的点。</p><ul><li>加法和乘法都满足交换律，因此如果选择的运算操作是加法或乘法，则对于选出的 22 个数字不需要考虑不同的顺序，在遇到第二种顺序时可以不进行运算，直接跳过。</li></ul><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TARGET = <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> EPSILON = <span class="number">1e-6</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ADD = <span class="number">0</span>, MULTIPLY = <span class="number">1</span>, SUBTRACT = <span class="number">2</span>, DIVIDE = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgePoint24</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Double&gt; list = <span class="keyword">new</span> ArrayList&lt;Double&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            list.add((<span class="keyword">double</span>) num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> solve(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">solve</span><span class="params">(List&lt;Double&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.abs(list.get(<span class="number">0</span>) - TARGET) &lt; EPSILON;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size = list.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">                    List&lt;Double&gt; list2 = <span class="keyword">new</span> ArrayList&lt;Double&gt;();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; size; k++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (k != i &amp;&amp; k != j) &#123;</span><br><span class="line">                            list2.add(list.get(k));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (k &lt; <span class="number">2</span> &amp;&amp; i &gt; j) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (k == ADD) &#123;</span><br><span class="line">                            list2.add(list.get(i) + list.get(j));</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k == MULTIPLY) &#123;</span><br><span class="line">                            list2.add(list.get(i) * list.get(j));</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k == SUBTRACT) &#123;</span><br><span class="line">                            list2.add(list.get(i) - list.get(j));</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k == DIVIDE) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (Math.abs(list.get(j)) &lt; EPSILON) &#123;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                list2.add(list.get(i) / list.get(j));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (solve(list2)) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        list2.remove(list2.size() - <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      24点游戏
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="LeetCode" scheme="http://benym.cn/tags/LeetCode/"/>
    
      <category term="Hard" scheme="http://benym.cn/tags/Hard/"/>
    
  </entry>
  
  <entry>
    <title>判断一棵二叉树是否为二叉搜索树和完全二叉树</title>
    <link href="http://benym.cn/2020/09/10/%E5%88%A4%E6%96%AD%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%92%8C%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://benym.cn/2020/09/10/判断一棵二叉树是否为二叉搜索树和完全二叉树/</id>
    <published>2020-09-10T08:30:22.000Z</published>
    <updated>2020-09-10T08:33:55.531Z</updated>
    
    <content type="html"><![CDATA[<h2 id="判断一棵二叉树是否为二叉搜索树和完全二叉树"><a href="#判断一棵二叉树是否为二叉搜索树和完全二叉树" class="headerlink" title="判断一棵二叉树是否为二叉搜索树和完全二叉树"></a>判断一棵二叉树是否为二叉搜索树和完全二叉树</h2><p>给定一棵二叉树，已经其中没有重复值的节点，请判断该二叉树是否为搜索二叉树和完全二叉树。</p> <a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&#123;2,1,3&#125;</span><br><span class="line">输出：[true,true]</span><br></pre></td></tr></table></figure><p><strong>备注：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n&lt;=500000</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>详见注释理解</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 the root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span>[] judgeIt(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// 二叉搜索树的中序遍历严格递增</span></span><br><span class="line">        <span class="comment">// 每个节点左边节点小于右边节点，左子树的最大值一定小于根节点，小于右子树的最大值</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">boolean</span>[]&#123;<span class="keyword">false</span>, <span class="keyword">false</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        midSearch(root, list);</span><br><span class="line">        <span class="keyword">boolean</span> f1 = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list.get(i) &lt; list.get(i - <span class="number">1</span>)) &#123;</span><br><span class="line">                f1 = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> f2 = isCompleteTree(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">boolean</span>[]&#123;f1, f2&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCompleteTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 完全二叉树，除了最后一层，每一层都是满的</span></span><br><span class="line">        <span class="comment">// 层序遍历，当遇到节点为null的时候，队列中剩下的节点必须为叶子节点</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                    TreeNode temp = queue.poll();</span><br><span class="line">                    <span class="keyword">if</span> (temp.left != <span class="keyword">null</span> || temp.right != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                    TreeNode temp = queue.poll();</span><br><span class="line">                    <span class="keyword">if</span> (temp.left != <span class="keyword">null</span> || temp.right != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">midSearch</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        midSearch(root.left, list);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        midSearch(root.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      如题
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="树" scheme="http://benym.cn/tags/%E6%A0%91/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="LeetCode" scheme="http://benym.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-16-最接近的三数之和</title>
    <link href="http://benym.cn/2020/09/08/LeetCode-16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://benym.cn/2020/09/08/LeetCode-16-最接近的三数之和/</id>
    <published>2020-09-08T02:20:20.000Z</published>
    <updated>2020-09-08T12:57:35.609Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-16-最接近的三数之和"><a href="#LeetCode-16-最接近的三数之和" class="headerlink" title="LeetCode-16-最接近的三数之和"></a>LeetCode-16-最接近的三数之和</h2><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p> <a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,2,1,-4], target = 1</span><br><span class="line">输出：2</span><br><span class="line">解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 10^3</code></li><li><code>-10^3 &lt;= nums[i] &lt;= 10^3</code></li><li><code>-10^4 &lt;= target &lt;= 10^4</code></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>方法1、回溯：</strong></p><p>回溯穷举所有可能的排列，如果当前深度达到3，且当前sum值更接近target就更新答案res</p><p>从deep=0，sum=0，index=0开始遍历</p><p>回溯前深度+1，sum加上当前的nums[i]</p><p>回溯之后深度-1，sum减去上一轮加入的值</p><p><strong>方法2、排序+双指针：</strong></p><p>详见<a href="https://leetcode-cn.com/problems/3sum-closest/solution/zui-jie-jin-de-san-shu-zhi-he-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/3sum-closest/solution/zui-jie-jin-de-san-shu-zhi-he-by-leetcode-solution/</a></p><h3 id="Java代码1"><a href="#Java代码1" class="headerlink" title="Java代码1"></a>Java代码1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        res = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">        backtrace(nums, target, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> deep, <span class="keyword">int</span> sum,  <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (deep == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(target - res) &gt; Math.abs(sum - target)) &#123;</span><br><span class="line">                res = sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            deep++;</span><br><span class="line">            backtrace(nums, target, deep, sum,  i + <span class="number">1</span>);</span><br><span class="line">            sum -= nums[i];</span><br><span class="line">            deep--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java代码2"><a href="#Java代码2" class="headerlink" title="Java代码2"></a>Java代码2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> start = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> end = len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">                <span class="keyword">int</span> value = nums[i] + nums[start] + nums[end];</span><br><span class="line">                <span class="keyword">if</span> (value == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> value;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (Math.abs(value - target) &lt; min) &#123;</span><br><span class="line">                    min = Math.abs(value - target);</span><br><span class="line">                    ans = value;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (value &gt; target) &#123;</span><br><span class="line">                    end--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    start++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      最接近的三数之和
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="LeetCode" scheme="http://benym.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-字符串排序</title>
    <link href="http://benym.cn/2020/08/30/LeetCode-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F/"/>
    <id>http://benym.cn/2020/08/30/LeetCode-字符串排序/</id>
    <published>2020-08-30T09:23:46.000Z</published>
    <updated>2020-09-01T07:06:39.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-字符串排序"><a href="#LeetCode-字符串排序" class="headerlink" title="LeetCode-字符串排序"></a>LeetCode-字符串排序</h2><p>编写一个程序，将输入字符串中的字符按如下规则排序。<br>规则 1 ：英文字母从 A 到 Z 排列，不区分大小写。<br>如，输入： Type 输出： epTy<br>规则 2 ：同一个英文字母的大小写同时存在时，按照输入顺序排列。<br>如，输入： BabA 输出： aABb<br>规则 3 ：非英文字母的其它字符保持原来的位置。<br>如，输入： By?e 输出： Be?y</p><a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">A Famous Saying: Much Ado About Nothing(2012/8).</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">A aaAAbc dFgghh : iimM nNn oooos Sttuuuy (2012/8).</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入例子:</span><br><span class="line">A Famous Saying: Much Ado About Nothing (2012/8).</span><br><span class="line"></span><br><span class="line">输出例子:</span><br><span class="line">A aaAAbc dFgghh: iimM nNn oooos Sttuuuy (2012/8).</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>外层循环按照26个字母的顺序循环，内层进行字母顺序进行字符串的遍历，如按照A字母内层一轮，将A和a加入到结果集。循环完毕之后，res中即存储的排序好的字符串</p><p>由于需要保持原本的非英文字符串不变，再遍历一次字符串，将非英文字符按照原位置插入到res中即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = sc.nextLine().trim();</span><br><span class="line">        <span class="keyword">char</span>[] cs = str.toCharArray();</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//  循环26个字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 循环字符串排序，按照A字母一轮，B字母一轮添加进builder</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; str.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cs[j] == (i + <span class="string">'a'</span>) || cs[j] == (i + <span class="string">'A'</span>)) &#123;</span><br><span class="line">                    res.append(cs[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再次遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 如果不是英文字符，直接添加进结果</span></span><br><span class="line">            <span class="keyword">if</span> (!(cs[i] &gt;= <span class="string">'a'</span> &amp;&amp; cs[i] &lt;= <span class="string">'z'</span> || cs[i] &gt;= <span class="string">'A'</span> &amp;&amp; cs[i] &lt;= <span class="string">'Z'</span>)) &#123;</span><br><span class="line">                res.insert(i, cs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      零钱兑换
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="字符串" scheme="http://benym.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>01背包问题详解</title>
    <link href="http://benym.cn/2020/08/25/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/"/>
    <id>http://benym.cn/2020/08/25/01背包问题详解/</id>
    <published>2020-08-25T07:26:04.000Z</published>
    <updated>2020-08-25T09:32:26.960Z</updated>
    
    <content type="html"><![CDATA[<h2 id="01背包问题详解"><a href="#01背包问题详解" class="headerlink" title="01背包问题详解"></a>01背包问题详解</h2><p><strong>问题描述：</strong></p><div class="note info"><p>给定 n 件物品，物品的重量为 w[i]，物品的价值为 c[i]。现挑选物品放入背包中，假定背包能承受的最大重量为 V，问应该如何选择装入背包中的物品，使得装入背包中物品的总价值最大？</p></div><a id="more"></a><p><strong>输入：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 4</span><br><span class="line">1 1500</span><br><span class="line">4 3000</span><br><span class="line">3 2000</span><br><span class="line">1 2000</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4000</span><br></pre></td></tr></table></figure><p><strong>解释：</strong>输入的第一行n，W分别代表接下来有n组输入数据，背包的总容量为W；在接下来的n行中，每一行2个数字，分别表示为wi和vi，代表第n个物品的重量和价值。</p><hr><p>参考链接</p><p><a href="https://www.jianshu.com/p/a66d5ce49df5" target="_blank" rel="noopener">https://www.jianshu.com/p/a66d5ce49df5</a></p><p><a href="https://www.cnblogs.com/kkbill/p/12081172.html" target="_blank" rel="noopener">https://www.cnblogs.com/kkbill/p/12081172.html</a></p><p><a href="https://blog.csdn.net/chanmufeng/article/details/82955730" target="_blank" rel="noopener">https://blog.csdn.net/chanmufeng/article/details/82955730</a></p><p>动态规划类的问题，最重要的是如何去定义<strong>状态</strong>，找到问题的子问题，从而定义出<strong>状态转移方程</strong>。背包问题是一类经典的动态规划题目，01背包问题是其中最为基础的一个。本文结合多个题解，给出01背包问题的直观解释，以及多种求解方法的代码实现。</p><h4 id="01背包问题的另一种风格描述"><a href="#01背包问题的另一种风格描述" class="headerlink" title="01背包问题的另一种风格描述"></a>01背包问题的另一种风格描述</h4><p>假设你是一个小偷，背着一个可装下<strong>4磅</strong>东西的背包，你可以偷窃的物品如下：</p><p><img src="https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/image-Package-1.png" alt="image-20200825153711754" style="zoom:80%;"></p><p>为了让偷窃的商品价值最高，你该选择哪些商品？</p><h4 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h4><p>最简单的算法是：尝试各种可能的商品组合，并找出价值最高的组合。</p><p><img src="https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/%20image-Package-2.png" alt="image-20200825153824472" style="zoom:80%;"></p><p>这样显然是可行的，但是速度非常慢。在只有3件商品的情况下，你需要计算8个不同的集合；当有4件商品的时候，你需要计算16个不同的集合。每增加一件商品，需要计算的集合数都将翻倍！<strong>对于每一件商品，都有选或不选两种可能，即这种算法的运行时间是O(2ⁿ)。</strong></p><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>解决这样问题的答案就是使用动态规划！下面来看看动态规划的工作原理。动态规划先解决子问题，再逐步解决大问题。</p><p>对于背包问题，你先解决小背包（子背包）问题，再逐步解决原来的问题。</p><p><img src="https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/%20image-Package-3.png" alt="image-20200825153854442" style="zoom:80%;"></p><p>比较有趣的一句话是：<strong>每个动态规划都从一个网格开始。</strong> （所以学会网格的推导至关重要，而有些题解之所以写的不好，就是因为没有给出网格的推导过程，或者说，没有说清楚为什么要”这样“设计网格。本文恰是解决了我这方面长久以来的困惑！）</p><p>背包问题的网格如下：</p><p><img src="https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/%20image-Package-4.png" alt="image-20200825153924860" style="zoom:80%;"></p><p>网格的各行表示商品，各列代表不同容量（1~4磅）的背包。<strong>所有这些列你都需要，因为它们将帮助你计算子背包的价值。</strong></p><p>网格最初是空的。<strong>你将填充其中的每个单元格，网格填满后，就找到了问题的答案！</strong></p><h4 id="1-吉他行"><a href="#1-吉他行" class="headerlink" title="1. 吉他行"></a>1. 吉他行</h4><p>后面会列出计算这个网格中单元格值得公式，但现在我们先来一步一步做。首先来看第一行。</p><p><img src="https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/image-Package-5.png" alt="image-20200825154002985" style="zoom:80%;"></p><p><strong>这是吉他行，意味着你将尝试将吉他装入背包。在每个单元格，都需要做一个简单的决定：偷不偷吉他？</strong>别忘了，你要找出一个价值最高的商品集合。</p><p><strong>第一个单元格表示背包的的容量为1磅。吉他的重量也是1磅，这意味着它能装入背包！因此这个单元格包含吉他，价值为1500美元。</strong></p><p>下面来填充网格。</p><p><img src="https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/image-Package-6.png" alt="image-20200825154030729" style="zoom:80%;"></p><p>与这个单元格一样，<strong>每个单元格都将包含当前可装入背包的所有商品。</strong></p><p>来看下一个单元格。这个单元格表示背包容量为2磅，完全能够装下吉他！</p><p><img src="https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/image-Package-7.png" alt="image-20200825154058167" style="zoom:80%;"></p><p>这行的其他单元格也一样。<strong>别忘了，这是第一行，只有吉他可供你选择，换而言之，你假装现在还没发偷窃其他两件商品。</strong></p><p><img src="https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/image-Package-8.png" alt="image-20200825154125762" style="zoom:80%;"></p><p>此时你很可能心存疑惑：原来的问题说的是4磅的背包，我们为何要考虑容量为1磅、2磅等得背包呢？前面说过，<strong>动态规划从子问题着手，逐步解决大问题。</strong>这里解决的子问题将帮助你解决大问题。</p><p><img src="https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/image-Package-9.png" alt="image-20200825154203348" style="zoom:80%;"></p><p>别忘了，你要做的是让背包中商品的价值最大。<em>这行表示的是当前的最大价值。</em>它指出，如果你有一个容量4磅的背包，可在其中装入的商品的最大价值为1500美元。</p><p>你知道这不是最终解。随着算法往下执行，你将逐步修改最大价值。</p><h4 id="2-音响行"><a href="#2-音响行" class="headerlink" title="2. 音响行"></a>2. 音响行</h4><p>我们来填充下一行——音响行。<strong>你现在处于第二行，可以偷窃的商品有吉他和音响。</strong></p><p>我们先来看第一个单元格，它表示容量为1磅的背包。在此之前，可装入1磅背包的商品最大价值为1500美元。</p><p><img src="https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/image-Package-10.png" alt="image-20200825154236868" style="zoom:80%;"></p><p>该不该偷音响呢？</p><p>背包的容量为1磅，显然不能装下音响。由于容量为1磅的背包装不下音响，因此最大价值依然是1500美元。</p><p><img src="https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/image-Package-11.png" alt="image-20200825154304126" style="zoom:80%;"></p><p>接下来的两个单元格的情况与此相同。在这些单元格中，背包的容量分别为2磅和3磅，而以前的最大价值为1500美元。由于这些背包装不下音响，因此最大的价值保持不变。</p><p><img src="https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/image-Package-12.png" alt="image-20200825154326186" style="zoom:80%;"></p><p>背包容量为4磅呢？终于能够装下音响了！原来最大价值为1500美元，但如果在背包中装入音响而不是吉他，价值将为3000美元！因此还是偷音响吧。</p><p><img src="https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/image-Package-13.png" alt="image-20200825154353311" style="zoom:80%;"></p><p>你更新了最大价值。如果背包的容量为4磅，就能装入价值至少3000美元的商品。在这个网格中，你逐步地更新最大价值。</p><p><img src="https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/image-Package-14.png" alt="image-20200825154426433" style="zoom:80%;"></p><h4 id="3-笔记本电脑行"><a href="#3-笔记本电脑行" class="headerlink" title="3. 笔记本电脑行"></a>3. 笔记本电脑行</h4><p>下面以同样的方式处理笔记本电脑。笔记本电脑重3磅，没法将其装入1磅或者2磅的背包，因此前两个单元格的最大价值仍然是1500美元。</p><p><img src="https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/%20image-Package-15.png" alt="image-20200825154511130" style="zoom:80%;"></p><p>对于容量为3磅的背包，原来的最大价值为1500美元，但现在你可以选择偷窃价值2000美元的笔记本电脑而不是吉他，这样新的最大价值将为2000美元。</p><p><img src="https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/image-20200825154902119.png" alt="image-20200825154902119" style="zoom:80%;"></p><p><strong>对于容量为4磅的背包，情况很有趣。</strong>这是非常重要的部分。当前的最大价值为3000美元，你可不偷音响，而偷笔记本电脑，但它只值2000美元。</p><p><img src="https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/image-20200825154924996.png" alt="image-20200825154924996" style="zoom: 67%;"></p><p>价值没有原来高，但是等一等，<strong>笔记本电脑的重量只有3磅，背包还有1磅的重量没用！</strong></p><p><img src="https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/image-20200825154946629.png" alt="image-20200825154946629" style="zoom:67%;"></p><p><strong>在1磅的容量中，可装入的商品的最大价值是多少呢？</strong> 你之前计算过！</p><p><img src="https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/image-20200825155038665.png" alt="image-20200825155038665" style="zoom:80%;"></p><p>根据之前计算的最大价值可知，在1磅的容量中可装入吉他，价值1500美元。因此，你需要做如下的比较：</p><p><img src="https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/image-20200825155055030.png" alt="image-20200825155055030" style="zoom:67%;"></p><p>你可能始终心存疑惑：为何计算小背包可装入的商品的最大价值呢？但愿你现在明白了其中的原因！<strong>当出现部分剩余空间时，你可根据这些子问题的答案来确定余下的空间可装入哪些商品。</strong>笔记本电脑和吉他的总价值为3500美元，因此偷它们是更好的选择。</p><p>最终的网格类似于下面这样。</p><p><img src="https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/image-20200825155111047.png" alt="image-20200825155111047" style="zoom:80%;"></p><p>答案如下：将吉他和笔记本电脑装入背包时价值更高，为3500美元。</p><p>你可能认为，计算最后一个单元格的价值时，我使用了不同的公式。那是因为填充之前的单元格时，我故意避开了一些复杂的因素。其实，计算每个单元格的价值时，使用的公式都相同。这个公式如下。</p><p><img src="https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/image-20200825155126003.png" alt="image-20200825155126003"></p><p>你可以使用这个公式来计算每个单元格的价值，最终的网格将与前一个网格相同。现在你明白了为何要求解子问题了吧？——因为你可以合并两个子问题的解来得到更大问题的解。</p><p><img src="https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/image-20200825155144946.png" alt="image-20200825155144946" style="zoom: 67%;"></p><h4 id="4-等等，再增加一件商品将如何变化呢？"><a href="#4-等等，再增加一件商品将如何变化呢？" class="headerlink" title="4. 等等，再增加一件商品将如何变化呢？"></a>4. 等等，再增加一件商品将如何变化呢？</h4><p>假设你发现还有第四件商品可偷——一个iPhone！<em>（或许你会毫不犹豫的拿走，但是请别忘了问题的本身是要拿走价值最大的商品）</em></p><p><img src="https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/image-20200825155205168.png" alt="image-20200825155205168" style="zoom:50%;"></p><p>此时需要重新执行前面所做的计算吗？不需要。别忘了，动态规划逐步计算最大价值。到目前为止，计算出的最大价值如下：</p><p><img src="https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/image-20200825155224625.png" alt="image-20200825155224625" style="zoom:80%;"></p><p>这意味着背包容量为4磅时，你最多可偷价值3500美元的商品。但这是以前的情况，下面再添加表示iPhone的行。</p><p><img src="https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/image-20200825155240955.png" alt="image-20200825155240955" style="zoom: 67%;"></p><p>我们还是从第一个单元格开始。iPhone可装入容量为1磅的背包。之前的最大价值为1500美元，但iPhone价值2000美元，因此该偷iPhone而不是吉他。</p><p><img src="https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/image-20200825155256914.png" alt="image-20200825155256914" style="zoom: 80%;"></p><p>在下一个单元格中，你可装入iPhone和吉他。</p><p><img src="https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/image-20200825155312307.png" alt="image-20200825155312307" style="zoom:80%;"></p><p>对于第三个单元格，也没有比装入iPhone和吉他更好的选择了。</p><p>对于最后一个单元格，情况比较有趣。当前的最大价值为3500美元，但你可以偷iPhone，这将余下3磅的容量。</p><p><img src="https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/image-20200825155337598.png" alt="image-20200825155337598" style="zoom: 50%;"></p><p>3磅容量的最大价值为2000美元！再加上iPhone价值2000美元，总价值为4000美元。新的最大价值诞生了！</p><p><strong>最终的网格如下</strong>：</p><p><img src="https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/image-20200825155355312.png" alt="image-20200825155355312" style="zoom: 80%;"></p><hr><p>现在回到问题本身，给定<code>n</code>个重量为<code>w1,w2,w3,....,wn</code>，价值为<code>v1,v2,v3,...,vn</code>的物品和容量为<code>W</code>的背包，问应该如何选择装入背包中的物品，使得装入背包中的物品的总价值最大？<strong>每个物品只能使用一次</strong>(01背包特点)</p><p>依然用上文的3个物品为例，物品的重量<code>weight[]={1,3,1}</code>，对应的价值为<code>value[]={15,30,20}</code>，现挑选物品放入背包中，假定背包的最大重量<code>W=4</code></p><p>令 <strong><code>dp[i][w]</code> 表示前 i 件物品放入容量为 w 的背包中可获得的最大价值</strong>。为了方便处理，我们约定下标从 1 开始。初始时，网格如下：</p><p><img src="https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/image-20200825161832802.png" alt="image-20200825161832802" style="zoom:80%;"></p><p>根据之前已经引出的状态转移方程，我们再来理解一遍，对于编号为 i 的物品：</p><ul><li>如果选择它，那么，当前背包的最大价值等于” i 号物品的价值“ 加上 ”减去 i 号物品占用的空间后剩余的背包空间所能存放的最大价值“，即<code>dp[i][k] = value[i] + dp[i-1][k-weight[i]]</code>；</li><li>如果不选择它，那么，当前背包的价值就等于前 i-1 个物品存放在背包中的最大价值，即<code>dp[i][k] = dp[i-1][k]</code></li></ul><p><code>dp[i][k]</code>的结果取两者的较大值，即：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][k] = max(value[i] + dp[i-<span class="number">1</span>][k-weight[i]], dp[i-<span class="number">1</span>][k])</span><br></pre></td></tr></table></figure><h3 id="DP代码实现如下"><a href="#DP代码实现如下" class="headerlink" title="DP代码实现如下"></a>DP代码实现如下</h3><p><strong>动态规划+二维数组：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Package_01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] weights = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] value = &#123;<span class="number">1500</span>, <span class="number">3000</span>, <span class="number">2000</span>, <span class="number">2000</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> W = <span class="number">4</span>;</span><br><span class="line">        System.out.println(maxValue(weights, value, W));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[] weight, <span class="keyword">int</span>[] value, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = weight.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][W + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 先初始化第 0 行，也就是尝试把 0 号物品放入容量为 k 的背包中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= W; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k &gt;= weight[<span class="number">0</span>]) dp[<span class="number">0</span>][k] = value[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= W; k++) &#123;</span><br><span class="line">                <span class="comment">// 存放 i 号物品（前提是放得下这件物品）</span></span><br><span class="line">                <span class="keyword">int</span> valueWith_i = (k-weight[i] &gt;= <span class="number">0</span>) ? (value[i] + dp[i-<span class="number">1</span>][k-weight[i]]) : <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 不存放 i 号物品</span></span><br><span class="line">                <span class="keyword">int</span> valueWithout_i = dp[i-<span class="number">1</span>][k];</span><br><span class="line">                dp[i][k] = Math.max(valueWith_i, valueWithout_i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][W];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(nW)；空间复杂度O(nW)</p><p><strong>动态规划+压缩空间：</strong></p><p>观察上面的代码，会发现，<strong>当更新<code>dp[i][..]</code>时，只与<code>dp[i-1][..]</code>有关</strong>，也就是说，我们没有必要使用O(n*W)的空间，而是只使用O(W)的空间即可。下面先给出代码，再结合图例进行说明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[] weight, <span class="keyword">int</span>[] value, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = weight.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 辅助空间只需要O(W)即可</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[W + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 注意这里必须从后向前！！！</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = W; k &gt;= <span class="number">1</span>; k--) &#123;</span><br><span class="line">            <span class="keyword">int</span> valueWith_i = (k - weight[i] &gt;= <span class="number">0</span>) ? (dp[k - weight[i]] + value[i]) : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> valueWithout_i = dp[k];</span><br><span class="line">            dp[k] = Math.max(valueWith_i, valueWithout_i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的状态转移方程变成了：<code>dp[k](新值) = max(value[i]+dp[k-weight[i]](旧值), dp[k](旧值))</code></p><p>为什么说这里<strong>必须反向遍历来更新dp[]数组的值</strong>呢？原因是索引较小的元素可能会被覆盖。我们来看例子，假设我们已经遍历完了第 i=1 个元素（即weight=3, value=30），如下图所示：</p><p><img src="https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/image-20200825163404982.png" alt="image-20200825163404982" style="zoom:80%;"></p><p>现在要更新第 i=2 个元素（即weight=1, value=20），由于我们只申请了一维空间的数组，因此对dp[]数组的修改会覆盖上一轮dp[]数组的值，这里<strong>用浅色代表上一轮的值，深色代表当前这一轮的值</strong>。</p><p><img src="https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/image-20200825163445617.png" alt="image-20200825163445617" style="zoom:80%;"></p><p>鉴于上面出现的问题，因此<strong>必须采用反向遍历来回避这个问题</strong>。仍然假设第 i=1 个元素已经更新完毕，现在更新第 i=2 个元素。示意图如下：</p><p><img src="https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/image-20200825163509043.png" alt="image-20200825163509043" style="zoom: 80%;"></p><p>可以看到，反向遍历就可以避免这个问题了！</p><p>事实上，我们还可以进一步简化上面的代码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[] weight, <span class="keyword">int</span>[] value, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = weight.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[W + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">//只要确保 k&gt;=weight[i] 即可，而不是 k&gt;=1，从而减少遍历的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = W; k &gt;= weight[i]; k--) &#123;</span><br><span class="line">            dp[k] = Math.max(dp[k - weight[i]] + value[i], dp[k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么可以这样简化呢？我们重新看一下这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = W; k &gt;= <span class="number">1</span>; k--) &#123;</span><br><span class="line">    <span class="keyword">int</span> valueWith_i = (k - weight[i] &gt;= <span class="number">0</span>) ? (dp[k - weight[i]] + value[i]) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valueWithout_i = dp[k];</span><br><span class="line">    dp[k] = Math.max(valueWith_i, valueWithout_i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>k&gt;=weight[i]</code> 不成立，则<code>valueWith_i</code> 的值为0，那么显然有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[k] = Math.max(valueWith_i, valueWithout_i) = max(<span class="number">0</span>, dp[k]) = dp[k]</span><br></pre></td></tr></table></figure><p>也就是dp[k]没有更新过，它的值还是上一轮的值，因此就没必要执行了，可以提前退出循环！</p><h3 id="递归代码实现"><a href="#递归代码实现" class="headerlink" title="递归代码实现"></a>递归代码实现</h3><p>这类问题同样可以采用递归的方式来解决</p><p>我们用<code>F(n,W)</code>表示将前<code>n</code>个物品放进容量为<code>W</code>的背包中，得到的最大的价值</p><p>我们用自顶向下的角度来看，假如我们已经进行到了最后一步(即求解将<code>n</code>个物品放到背包里获得的最大价值)，此时我们便有两种选择</p><ol><li>不放第<code>n</code>个物品，此时总价值为<code>F(n-1,W)</code></li><li>放置第<code>n</code>个物品，此时总价值为<code>vn+F(n-1,W-wn)</code></li></ol><p>两种选择中总价值最大的方案就是我们的方案，转移方程为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F(i,W) = max(F(i-<span class="number">1</span>,W),vi+F(i-<span class="number">1</span>,W-wi))</span><br></pre></td></tr></table></figure><p>编程实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] weights = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] value = &#123;<span class="number">1500</span>, <span class="number">3000</span>, <span class="number">2000</span>, <span class="number">2000</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> W = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> index = weights.length - <span class="number">1</span>;</span><br><span class="line">        System.out.println(maxValue3(weights, value, index, W));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxValue3</span><span class="params">(<span class="keyword">int</span>[] weights, <span class="keyword">int</span>[] value, <span class="keyword">int</span> index, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果索引无效或者容量不足，直接返回当前价值0</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || W &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不放第index个物品所得价值</span></span><br><span class="line">        <span class="keyword">int</span> res = maxValue3(weights, value, index - <span class="number">1</span>, W);</span><br><span class="line">        <span class="comment">// 放第index个物品所得价值(前提是：第index个物品可以放得下)</span></span><br><span class="line">        <span class="keyword">if</span> (weights[index] &lt;= W) &#123;</span><br><span class="line">            res = Math.max(res, value[index] + maxValue3(weights, value, index - <span class="number">1</span>, W - weights[index]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h3><p>递归的代码可以很清晰的对照转移方程，不过因为重复计算太多，递归基本上会超时，效率十分低下</p><p>我们可以将已经求得的子问题的结果保存下来，这样对子问题只会求解一次，这便是记忆化搜索。在递归的代码基础上，进行改进</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] memo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] weights = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] value = &#123;<span class="number">1500</span>, <span class="number">3000</span>, <span class="number">2000</span>, <span class="number">2000</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> W = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> index = weights.length - <span class="number">1</span>;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[weights.length][W + <span class="number">1</span>];</span><br><span class="line">        System.out.println(maxValue4(weights, value, index, W));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxValue4</span><span class="params">(<span class="keyword">int</span>[] weights, <span class="keyword">int</span>[] value, <span class="keyword">int</span> index, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果索引无效或者容量不足，直接返回当前价值0</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || W &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果此子问题已经求解过，则直接返回上次求解的结果</span></span><br><span class="line">        <span class="keyword">if</span> (memo[index][W] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[index][W];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不放第index个物品所得价值</span></span><br><span class="line">        <span class="keyword">int</span> res = maxValue4(weights, value, index - <span class="number">1</span>, W);</span><br><span class="line">        <span class="comment">// 放第index个物品所得价值(前提是：第index个物品可以放得下)</span></span><br><span class="line">        <span class="keyword">if</span> (weights[index] &lt;= W) &#123;</span><br><span class="line">            res = Math.max(res, value[index] + maxValue4(weights, value, index - <span class="number">1</span>, W - weights[index]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加子问题的解，便于下次直接使用</span></span><br><span class="line">        memo[index][W] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      01背包问题详解
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="DP" scheme="http://benym.cn/tags/DP/"/>
    
      <category term="背包问题" scheme="http://benym.cn/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-322-零钱兑换</title>
    <link href="http://benym.cn/2020/08/21/LeetCode-322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/"/>
    <id>http://benym.cn/2020/08/21/LeetCode-322-零钱兑换/</id>
    <published>2020-08-21T02:00:46.000Z</published>
    <updated>2020-09-01T06:45:48.807Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-322-零钱兑换"><a href="#LeetCode-322-零钱兑换" class="headerlink" title="LeetCode-322-零钱兑换"></a>LeetCode-322-零钱兑换</h2><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: coins = [1, 2, 5], amount = 11</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: coins = [2], amount = 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure><p><strong>说明</strong>:<br>你可以认为每种硬币的数量是无限的。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>摘自官方题解<a href="https://leetcode-cn.com/problems/coin-change/solution/322-ling-qian-dui-huan-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/coin-change/solution/322-ling-qian-dui-huan-by-leetcode-solution/</a></p><p><strong>方法1、回溯：</strong></p><p>用S代表总金额，ci是第i枚硬币的面值，xi是面值为ci的硬币数量，由于xi*ci不能超过S，可以得出xi的取值范围[0,S/xi]</p><p>一个简单的解决方案是枚举每个硬币数量子集[x0,…,xn-1]。如果满足上述约束条件，计算硬币数量总和并返回所有子集中的最小值</p><p>for循环每一个硬币，选择0个1面值硬币，判断当前选择情况*面值是否小于等于总面值S，进入下层递归选择硬币应该固定1面值，选择2面值，<code>idxCoin+1</code>，总面值应该减去当前选择的硬币个数乘以面值数，即</p><p><code>amount - i * coins[idxCoin]</code>，选择0个2面值硬币，进行判断…依次列推。固定某一面值选择数，深度优先穷举后续面值可能的选择数目，且硬币选择数目范围在<code>[0,S/xi]</code></p><p>由于有重复计算，所以回溯的效率并不是很高</p><p><strong>方法2、动态规划-自上而下：</strong></p><p>利用动态规划，改进上面的指数时间复杂度的解，定义</p><ul><li>F(S)：组成金额S所需的最少硬币数量</li><li>[c0,…,cn-1]：可选的n枚硬币面额值</li></ul><p>这个问题有一个最优的子结构性质，这是解决动态规划问题的关键。最优解可以从其子问题的最优解构造出来。如何将问题分解成子问题？</p><p>假设我们知道F(S)，即组成金额S最少的硬币数，最后一枚硬币的面值是C。那么由于问题的最优子结构，转移方程应为：</p><p><code>F(S)=F(S-C)+1</code></p><p>但我们不知道最后一枚硬币的面值是多少，所以我们需要枚举每个硬币面额值c0,c1,c2,…,cn-1并选择其中的最小值。下列递推关系成立：</p><p><img src="https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/image-20200821132154572.png" alt="image-20200821132154572"></p><p>在上面的递归树中，可以发现有许多子问题被多次计算。例如，F(1)被计算了13次。为了避免重复的计算，我们将每个子问题的答案存在一个数组中进行记忆化，如果下次还要计算这个问题的值直接从数组中去除返回即可，这样能保证每个子问题最多只被计算一次。</p><p><strong>方法3、动态规划-自下而上：</strong></p><p>采用自下而上的方式进行思考，仍定义F(i)为组成金额i所需最少的硬币数量，假设在计算F(i)之前，我们已经计算出F(0)-F(i-1)的答案，则F(i)对应的转移方程为</p><p><img src="https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/image-20200821153508353.png" alt="image-20200821153508353"></p><p>其中cj代表的是第j枚硬币的面值，即我们枚举最后一枚硬币面额是cj，那么需要从i-cj这个金额的状态F(i-cj)转移过来，再算上枚举的这个硬币数量1的贡献，由于要硬币数量最少，所以F(i)为：前面能转移过来的状态的最小值加上枚举的硬币数量1。</p><p>例子1：假设</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coins = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>],amount=<span class="number">11</span></span><br></pre></td></tr></table></figure><p>则，当i==0时无法用硬币组成，为0。当i&lt;0时，忽略F(i)</p><div class="table-container"><table><thead><tr><th>F(i)</th><th>最小硬币数量</th></tr></thead><tbody><tr><td>F(0)</td><td>0 //金额为0不能由硬币组成</td></tr><tr><td>F(1)</td><td>1 //F(1)=min(F(1-1),F(1-2),F(1-5))+1=1</td></tr><tr><td>F(2)</td><td>1 //F(2)=min(F(2-1),F(2-2),F(2-5))+1=1</td></tr><tr><td>F(3)</td><td>2 //F(3)=min(F(3-1),F(3-2),F(3-5))+1=2</td></tr><tr><td>F(4)</td><td>2 //F(4)=min(F(4-1),F(4-2),F(4-5))+1=2</td></tr><tr><td>…</td><td>…</td></tr><tr><td>F(11)</td><td>3 //F(11)=min(F(11-1),F(11-2),F(11-5))+1=3</td></tr></tbody></table></div><p>我们可以看到问题的答案是通过子问题的最优解得到的</p><p>例子2：假设</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coins = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],amount = <span class="number">6</span></span><br></pre></td></tr></table></figure><p><img src="https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/image-20200821155315909.png" alt="image-20200821155315909"></p><h3 id="Java代码1"><a href="#Java代码1" class="headerlink" title="Java代码1"></a>Java代码1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeetCode322</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] coins = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> amount = <span class="number">11</span>;</span><br><span class="line">        System.out.println(coinChange(coins, amount));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> coinChanges(<span class="number">0</span>, coins, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">coinChanges</span><span class="params">(<span class="keyword">int</span> idxCoin, <span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (idxCoin &lt; coins.length &amp;&amp; amount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> maxVal = amount / coins[idxCoin];</span><br><span class="line">            <span class="keyword">int</span> minCost = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxVal; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i * coins[idxCoin] &lt;= amount) &#123;</span><br><span class="line">                    <span class="keyword">int</span> res = coinChanges(idxCoin + <span class="number">1</span>, coins, amount - i * coins[idxCoin]);</span><br><span class="line">                    <span class="comment">// 说明需要更新</span></span><br><span class="line">                    <span class="keyword">if</span> (res != -<span class="number">1</span>) &#123;</span><br><span class="line">                        minCost = Math.min(minCost, res + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (minCost == Integer.MAX_VALUE) ? -<span class="number">1</span> : minCost;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java代码2"><a href="#Java代码2" class="headerlink" title="Java代码2"></a>Java代码2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> coinChanges(amount, coins, <span class="keyword">new</span> <span class="keyword">int</span>[amount]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">coinChanges</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins, <span class="keyword">int</span>[] count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (count[amount - <span class="number">1</span>] != <span class="number">0</span>) <span class="keyword">return</span> count[amount - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="keyword">int</span> res = coinChanges(amount - coin, coins, count);</span><br><span class="line">            <span class="keyword">if</span> (res &gt;= <span class="number">0</span> &amp;&amp; res &lt; min) &#123;</span><br><span class="line">                min = <span class="number">1</span> + res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count[amount - <span class="number">1</span>] = (min == Integer.MAX_VALUE) ? -<span class="number">1</span> : min;</span><br><span class="line">        <span class="keyword">return</span> count[amount - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java代码3"><a href="#Java代码3" class="headerlink" title="Java代码3"></a>Java代码3</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeetCode322_DP</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] coins = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> amount = <span class="number">11</span>;</span><br><span class="line">        System.out.println(coinChange(coins, amount));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = amount + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">        <span class="comment">// 因为需要比较最小，所以初始化数组为最大值</span></span><br><span class="line">        Arrays.fill(dp, max);</span><br><span class="line">        <span class="comment">// 没有数值为0的硬币</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 自底向上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            <span class="comment">// 遍历硬币面值cj</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (coins[j] &lt;= i) &#123;</span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      零钱兑换
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="DP" scheme="http://benym.cn/tags/DP/"/>
    
      <category term="回溯" scheme="http://benym.cn/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>获取满足指数的最长字符串</title>
    <link href="http://benym.cn/2020/08/20/%E8%8E%B7%E5%8F%96%E6%BB%A1%E8%B6%B3%E6%8C%87%E6%95%B0%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://benym.cn/2020/08/20/获取满足指数的最长字符串/</id>
    <published>2020-08-20T11:16:41.000Z</published>
    <updated>2020-08-20T11:59:54.838Z</updated>
    
    <content type="html"><![CDATA[<h2 id="获取满足指数的最长字符串"><a href="#获取满足指数的最长字符串" class="headerlink" title="获取满足指数的最长字符串"></a>获取满足指数的最长字符串</h2><p>字母表的26个字母，每个字母(忽略大小写)按照他们在字母表的顺序，代表一个数，例如：a代表1，h代表8，z代表26</p><p>对于任意由英文字母组成的字符串，我们可以把他们每一位对应的数加起来，便可以计算出这个字符串的<strong>指数</strong>，例如：abc的指数为6。</p><p>现在给你一个<strong>字符串</strong>与一个期望的<strong>指数</strong>，希望可以找出这个字符串的所有满足这个指数子串中，最长子串的长度。</p><p>要求：时间复杂度为O(n)，空间复杂度为O(1)</p><a id="more"></a><p>输入描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入为两行，第一行是字符串，第二行是期望的指数，例如：</span><br><span class="line"></span><br><span class="line">bcdafga</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>输出描述:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输出为最长子串的长度。如果没有合适的子串，则应该返回0，例如，对于示例中的输入，应该输出：</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>方法1、双指针：</strong></p><p>初始化left和right指针，len指针记录最长子串的长度，res记录当前窗口内数值的和</p><p>采用类似滑动窗口的思想</p><ul><li>当[left,right)窗口内的值等于期望值时，说明找到了一个满足期望的子串，更新最长子串长度，因为此时窗口值已经等于期望值，向右扩展必定会使窗口值增加，所以此时应该缩减左窗口，才有可能在后续的子串中找到另外的满足期望值的left和right，res减去缩减左窗口的值，同时使得left++</li><li>当[left,right)窗口内的值大于期望值时，需要缩减左窗口，即left++，同时时res减去左窗口的缩减部分的值</li><li>当[left,right)窗口内的值小于期望值时，需要向右扩展窗口，即right++，同时res加上右窗口增加部分的值</li></ul><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">char</span>[] s = sc.nextLine().toCharArray();</span><br><span class="line">        <span class="keyword">int</span> exNum = Integer.parseInt(sc.nextLine().trim());</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res == exNum) &#123;</span><br><span class="line">                len = Math.max(len, right - left);</span><br><span class="line">                res -= (s[left] - <span class="string">'a'</span> + <span class="number">1</span>);</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res &gt; exNum) &#123;</span><br><span class="line">                res -= (s[left] - <span class="string">'a'</span> + <span class="number">1</span>);</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += (s[right] - <span class="string">'a'</span> + <span class="number">1</span>);</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      笔试题
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-76-最小覆盖字串</title>
    <link href="http://benym.cn/2020/08/19/LeetCode-76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%97%E4%B8%B2/"/>
    <id>http://benym.cn/2020/08/19/LeetCode-76-最小覆盖字串/</id>
    <published>2020-08-19T02:10:37.000Z</published>
    <updated>2020-08-19T06:48:51.879Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-76-最小覆盖字串"><a href="#LeetCode-76-最小覆盖字串" class="headerlink" title="LeetCode-76-最小覆盖字串"></a>LeetCode-76-最小覆盖字串</h2><p>给你一个字符串 S、一个字符串 T 。请你设计一种算法，可以在 O(n) 的时间复杂度内，从字符串 S 里面找出：包含 T 所有字符的最小子串。</p><a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;</span><br><span class="line">输出：&quot;BANC&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>如果 S 中不存这样的子串，则返回空字符串 <code>&quot;&quot;</code>。</li><li>如果 S 中存在这样的子串，我们保证它是唯一的答案。</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>方法1、滑动窗口(数组)：</strong></p><p>示例中只列出了大写字母，但实际测试中含有小写字母，且同一字母可能会出现多次</p><p>用2个128长度的数组存储窗口window和实际需要的数组need</p><ol><li>先将两个字串转为char数组，用need数组存储对应字符的出现次数</li><li>初始化滑动窗口指针，left、right、valid(记录匹配的长度)</li><li>因为需要返回匹配的最短字串，所以使用start和end指针记录子串的首尾位置</li><li>当右边界小于s的长度时，进行窗口滑动，直到包含t中所有字符为止</li><li>当valid长度达到t子串长度时，停止增加右边界，记录当前匹配的串的start和end；之后不断减小左边界，直到窗口中的字符不符合要求</li><li>重复4、5步，直到right达到s长度</li><li>返回子串start,start+end</li></ol><p><strong>方法2、滑动窗口(哈希表)：</strong></p><p>和上面类似，改为哈希表存储</p><h3 id="Java代码1"><a href="#Java代码1" class="headerlink" title="Java代码1"></a>Java代码1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] arrs = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] arrt = t.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] window = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">int</span>[] need = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrt.length; i++) &#123;</span><br><span class="line">            need[arrt[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, valid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; arrs.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> cright = arrs[right];</span><br><span class="line">            right++;</span><br><span class="line">            window[cright]++;</span><br><span class="line">            <span class="keyword">if</span> (window[cright] &lt;= need[cright]) &#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (valid == arrt.length) &#123;</span><br><span class="line">                <span class="keyword">if</span> (right - left &lt; end) &#123;</span><br><span class="line">                    start = left;</span><br><span class="line">                    end = right - left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">char</span> cleft = arrs[left];</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">if</span> (window[cleft] == need[cleft]) &#123;</span><br><span class="line">                    valid--;</span><br><span class="line">                &#125;</span><br><span class="line">                window[cleft]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> end == Integer.MAX_VALUE ? <span class="string">""</span> : s.substring(start, start + end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java代码2"><a href="#Java代码2" class="headerlink" title="Java代码2"></a>Java代码2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character,Integer&gt; need = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Character,Integer&gt; window = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c: t.toCharArray())&#123;</span><br><span class="line">            need.put(c,need.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>,len = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;s.length())&#123;</span><br><span class="line">            <span class="keyword">char</span> cright = s.charAt(right);</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span>(need.containsKey(cright))&#123;</span><br><span class="line">                window.put(cright,window.getOrDefault(cright,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>((<span class="keyword">int</span>)window.get(cright)==(<span class="keyword">int</span>)need.get(cright))&#123;</span><br><span class="line">                    valid++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(valid==need.size())&#123;</span><br><span class="line">                <span class="keyword">if</span>(right-left&lt;len)&#123;</span><br><span class="line">                    start = left;</span><br><span class="line">                    len = right - left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">char</span> dleft = s.charAt(left);</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">if</span>(need.containsKey(dleft))&#123;</span><br><span class="line">                    <span class="keyword">if</span>((<span class="keyword">int</span>)window.get(dleft)==(<span class="keyword">int</span>)need.get(dleft))&#123;</span><br><span class="line">                        valid--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    window.put(dleft,window.get(dleft)-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len==Integer.MAX_VALUE? <span class="string">""</span> : s.substring(start,start+len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      最小覆盖字串
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="字符串" scheme="http://benym.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="Hard" scheme="http://benym.cn/tags/Hard/"/>
    
      <category term="滑动窗口" scheme="http://benym.cn/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-567-字符串的排列</title>
    <link href="http://benym.cn/2020/08/18/LeetCode-567-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <id>http://benym.cn/2020/08/18/LeetCode-567-字符串的排列/</id>
    <published>2020-08-18T07:30:45.000Z</published>
    <updated>2020-08-18T09:32:44.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-567-字符串的排列"><a href="#LeetCode-567-字符串的排列" class="headerlink" title="LeetCode-567-字符串的排列"></a>LeetCode-567-字符串的排列</h2><p>给定两个字符串 <strong>s1</strong> 和 <strong>s2</strong>，写一个函数来判断 <strong>s2</strong> 是否包含 <strong>s1</strong> 的排列。</p><p>换句话说，第一个字符串的排列之一是第二个字符串的子串。</p><a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;</span><br><span class="line">输出: True</span><br><span class="line">解释: s2 包含 s1 的排列之一 (&quot;ba&quot;).</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>输入的字符串只包含小写字母</li><li>两个字符串的长度都在 [1, 10,000] 之间</li></ol><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>方法1、滑动窗口(套模版)：</strong></p><p><a href="https://leetcode-cn.com/problems/permutation-in-string/solution/wo-xie-liao-yi-shou-shi-ba-suo-you-hua-dong-chuang/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutation-in-string/solution/wo-xie-liao-yi-shou-shi-ba-suo-you-hua-dong-chuang/</a></p><p><strong>方法2、滑动窗口(数组优化)：</strong></p><p>由于都是小写字符，所以初始化两个数组作为need和window，剩余步骤依旧按照模版走，详见注释。</p><h3 id="Java代码1"><a href="#Java代码1" class="headerlink" title="Java代码1"></a>Java代码1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character,Integer&gt; need =<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Character,Integer&gt; window =<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:s1.toCharArray()) </span><br><span class="line">            need.put(c,need.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>,len =Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; s2.length())&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s2.charAt(right);</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span>(need.containsKey(c))&#123;</span><br><span class="line">                window.put(c,window.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>((<span class="keyword">int</span>)window.get(c) ==(<span class="keyword">int</span>) need.get(c))&#123;</span><br><span class="line">                    valid++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(right-left == s1.length())&#123;</span><br><span class="line">                <span class="keyword">if</span>(valid == need.size())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">char</span> d = s2.charAt(left);</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">if</span>(need.containsKey(d))&#123;</span><br><span class="line">                    <span class="keyword">if</span>((<span class="keyword">int</span>)window.get(d) == (<span class="keyword">int</span>)need.get(d))&#123;</span><br><span class="line">                        valid--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    window.put(d,window.get(d)-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java代码2"><a href="#Java代码2" class="headerlink" title="Java代码2"></a>Java代码2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] arrS1 = s1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] arrS2 = s2.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] needs = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span>[] window = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>]; </span><br><span class="line">        <span class="keyword">int</span> cntChar = <span class="number">0</span>; <span class="comment">// 有效字母个数(不同的字母个数)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c: arrS1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(needs[c-<span class="string">'a'</span>]==<span class="number">0</span>) cntChar++;<span class="comment">// 如果该字母第一次出现，记录下来</span></span><br><span class="line">            needs[c-<span class="string">'a'</span>]+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; arrS2.length)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = arrS2[right];</span><br><span class="line">            <span class="comment">// 对窗口内数据进行一系列更新</span></span><br><span class="line">            window[c-<span class="string">'a'</span>]+=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(window[c-<span class="string">'a'</span>]==needs[c-<span class="string">'a'</span>])&#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当窗口扩散到包含s1时，进行左边界收缩</span></span><br><span class="line">            <span class="keyword">while</span>(cntChar==valid)&#123;</span><br><span class="line">                <span class="comment">// 如果窗口大小为s1的长度，则说明找到了</span></span><br><span class="line">                <span class="keyword">if</span>(right-left+<span class="number">1</span>==arrS1.length)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">char</span> d = arrS2[left];</span><br><span class="line">                <span class="comment">// 窗口缩小，对应字符出现次数-1</span></span><br><span class="line">                window[d-<span class="string">'a'</span>]-=<span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 当字符次数小于s1中字符出现次数时，则说明窗口达到包含s1字符的最小窗口</span></span><br><span class="line">                <span class="keyword">if</span>(window[d-<span class="string">'a'</span>]&lt;needs[d-<span class="string">'a'</span>])&#123;</span><br><span class="line">                    valid--;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      字符串的排列
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="字符串" scheme="http://benym.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="滑动窗口" scheme="http://benym.cn/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-438-找到字符串中所有字母异位词</title>
    <link href="http://benym.cn/2020/08/18/LeetCode-438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/"/>
    <id>http://benym.cn/2020/08/18/LeetCode-438-找到字符串中所有字母异位词/</id>
    <published>2020-08-18T01:57:26.000Z</published>
    <updated>2020-08-18T07:31:32.377Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-438-找到字符串中所有字母异位词"><a href="#LeetCode-438-找到字符串中所有字母异位词" class="headerlink" title="LeetCode-438-找到字符串中所有字母异位词"></a>LeetCode-438-找到字符串中所有字母异位词</h2><p>给定一个字符串 <strong>s</strong> 和一个非空字符串 <strong>p</strong>，找到 <strong>s</strong> 中所有是 <strong>p</strong> 的字母异位词的子串，返回这些子串的起始索引。</p><p>字符串只包含小写英文字母，并且字符串 <strong>s</strong> 和 <strong>p</strong> 的长度都不超过 20100。</p><p>说明：</p><ul><li>字母异位词指字母相同，但排列不同的字符串。</li><li>不考虑答案输出的顺序。</li></ul><a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s: &quot;cbaebabacd&quot; p: &quot;abc&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[0, 6]</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的字母异位词。</span><br><span class="line">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的字母异位词。</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s: &quot;abab&quot; p: &quot;ab&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[0, 1, 2]</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的字母异位词。</span><br><span class="line">起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的字母异位词。</span><br><span class="line">起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的字母异位词。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>方法1、哈希表+滑动窗口：</strong></p><p>详见注释</p><p><strong>方法2、数组+滑动窗口：</strong></p><p>详见<a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/solution/20200321438median-by-jasion_han-r/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/solution/20200321438median-by-jasion_han-r/</a></p><ul><li><p>一开始还是先将字符串转换为字符数组，定义一个ans来接收结果</p></li><li><p>这里使用了两个数组needs和window来分别记录<strong>需要得到的元素</strong>和<strong>滑动窗口遍历到的元素</strong></p></li><li><p>首先把目标数组arrP中有的元素都放入needs中，然后通过不断移动滑动窗口将目标元素的个数保存到window中</p></li><li><p>如果window数组中记录的元素个数超过了needs数组的元素个数，则开始移动左窗口慢慢减少多余的个数</p></li><li><p>最后把整个遍历过程中所有符合要求的左窗口索引放到ans中并返回即可。</p></li></ul><h3 id="Java代码1"><a href="#Java代码1" class="headerlink" title="Java代码1"></a>Java代码1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; smap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Character, Integer&gt; pmap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : p.toCharArray()) &#123;</span><br><span class="line">            pmap.put(ch, pmap.getOrDefault(ch, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 候选字符的个数</span></span><br><span class="line">        <span class="keyword">int</span> len = p.length();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(right);</span><br><span class="line">            smap.put(ch, smap.getOrDefault(ch, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 如果p中包含当前字符，且s的窗口中该字符出现次数不足，则该字符可以作为一个候选字符串，count++</span></span><br><span class="line">            <span class="keyword">if</span> (pmap.containsKey(ch) &amp;&amp; smap.get(ch) &lt;= pmap.get(ch)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当候选字符个数等于p长度，此时left为起始索引</span></span><br><span class="line">            <span class="keyword">if</span> (count == len) &#123;</span><br><span class="line">                res.add(left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当窗口大小大于等于p长度时，窗口左边需要收缩一个字符</span></span><br><span class="line">            <span class="keyword">if</span> (right - left + <span class="number">1</span> &gt;= len) &#123;</span><br><span class="line">                <span class="keyword">char</span> leftChar = s.charAt(left);</span><br><span class="line">                <span class="comment">// 判断收缩的这个字符是否是候选字符</span></span><br><span class="line">                <span class="keyword">if</span> (pmap.containsKey(leftChar) &amp;&amp; smap.get(leftChar) &lt;= pmap.get(leftChar)) &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 窗口收缩一个字符</span></span><br><span class="line">                smap.put(leftChar, smap.getOrDefault(leftChar, <span class="number">1</span>) - <span class="number">1</span>);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java代码2"><a href="#Java代码2" class="headerlink" title="Java代码2"></a>Java代码2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] arrS = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] arrP = p.toCharArray();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接收最后返回的结果</span></span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义一个 needs 数组来看 arrP 中包含元素的个数</span></span><br><span class="line">        <span class="keyword">int</span>[] needs = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="comment">// 定义一个 window 数组来看滑动窗口中是否有 arrP 中的元素，并记录出现的个数</span></span><br><span class="line">        <span class="keyword">int</span>[] window = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>]; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先将 arrP 中的元素保存到 needs 数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrP.length; i++) &#123;</span><br><span class="line">            needs[arrP[i] - <span class="string">'a'</span>] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义滑动窗口的两端</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 右窗口开始不断向右移动</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; arrS.length) &#123;</span><br><span class="line">            <span class="keyword">int</span> curR = arrS[right] - <span class="string">'a'</span>;</span><br><span class="line">            right++;</span><br><span class="line">            <span class="comment">// 将右窗口当前访问到的元素 curR 个数加 1 </span></span><br><span class="line">            window[curR] += <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 当 window 数组中 curR 比 needs 数组中对应元素的个数要多的时候就该移动左窗口指针 </span></span><br><span class="line">            <span class="keyword">while</span> (window[curR] &gt; needs[curR]) &#123;</span><br><span class="line">                <span class="keyword">int</span> curL = arrS[left] - <span class="string">'a'</span>;</span><br><span class="line">                left++;</span><br><span class="line">                <span class="comment">// 将左窗口当前访问到的元素 curL 个数减 1 </span></span><br><span class="line">                window[curL] -= <span class="number">1</span>;            </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 这里将所有符合要求的左窗口索引放入到了接收结果的 List 中</span></span><br><span class="line">            <span class="keyword">if</span> (right - left == arrP.length) &#123;</span><br><span class="line">                ans.add(left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      找到字符串中所有字母异位词
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="字符串" scheme="http://benym.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="滑动窗口" scheme="http://benym.cn/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-279-完全平方数</title>
    <link href="http://benym.cn/2020/08/14/LeetCode-279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"/>
    <id>http://benym.cn/2020/08/14/LeetCode-279-完全平方数/</id>
    <published>2020-08-14T05:38:52.000Z</published>
    <updated>2020-08-14T08:44:29.595Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-279-完全平方数"><a href="#LeetCode-279-完全平方数" class="headerlink" title="LeetCode-279-完全平方数"></a>LeetCode-279-完全平方数</h2><p>给定正整数 <em>n</em>，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于 <em>n</em>。你需要让组成和的完全平方数的个数最少。</p><a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 12</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 12 = 4 + 4 + 4.</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 13</span><br><span class="line">输出: 2</span><br><span class="line">解释: 13 = 4 + 9.</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>方法1、动态规划：</strong></p><p>详见<a href="https://leetcode-cn.com/problems/perfect-squares/solution/hua-jie-suan-fa-279-wan-quan-ping-fang-shu-by-guan/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/perfect-squares/solution/hua-jie-suan-fa-279-wan-quan-ping-fang-shu-by-guan/</a></p><p>首先初始化长度为n+1的数组dp，每个位置都为0<br>如果n为0，则结果为0<br>对数组进行遍历，下标为i，每次都将当前数字先更新为最大的结果，即dp[i]=i，比如i=4，最坏结果为4=1+1+1+1即为4个数字<br>动态转移方程为：dp[i] = MIN(dp[i], dp[i - j <em> j] + 1)，i表示当前数字，`j</em>j`表示平方数</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>]; <span class="comment">// 默认初始化值都为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = i; <span class="comment">// 最坏的情况就是每次+1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; i - j * j &gt;= <span class="number">0</span>; j++) &#123; </span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i - j * j] + <span class="number">1</span>); <span class="comment">// 动态转移方程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      完全平方数
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="DP" scheme="http://benym.cn/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-1143-最长公共子序列</title>
    <link href="http://benym.cn/2020/08/14/LeetCode-1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://benym.cn/2020/08/14/LeetCode-1143-最长公共子序列/</id>
    <published>2020-08-14T02:02:20.000Z</published>
    <updated>2020-08-14T05:35:21.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-1143-最长公共子序列"><a href="#LeetCode-1143-最长公共子序列" class="headerlink" title="LeetCode-1143-最长公共子序列"></a>LeetCode-1143-最长公共子序列</h2><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</p><p>若这两个字符串没有公共子序列，则返回 0。</p><a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：最长公共子序列是 &quot;abc&quot;，它的长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：两个字符串没有公共子序列，返回 0。</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= text1.length &lt;= 1000</code></li><li><code>1 &lt;= text2.length &lt;= 1000</code></li><li>输入的字符串只含有小写英文字符。</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>方法1、动态规划：</strong><br>详见大佬解析<a href="https://leetcode-cn.com/problems/longest-common-subsequence/solution/dong-tai-gui-hua-zhi-zui-chang-gong-gong-zi-xu-lie/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-subsequence/solution/dong-tai-gui-hua-zhi-zui-chang-gong-gong-zi-xu-lie/</a></p><p>初始化DP表</p><p>第0列和第0行均为空串，对应位置为0</p><p>状态<code>dp[i][j]</code>表示：对于text1[1…i]和text2[1…j]，他们的LCS的长度为<code>dp[i][j]</code></p><p>状态转移方程：根据DP表得到，是前一列的LCS长度和上一行的LCS长度的最大值</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lenT1 = text1.length();</span><br><span class="line">        <span class="keyword">int</span> lenT2 = text2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[lenT1+<span class="number">1</span>][lenT2+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lenT1;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=lenT2;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(text1.charAt(i-<span class="number">1</span>)==text2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[text1.length()][text2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      最长公共子序列
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="字符串" scheme="http://benym.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="DP" scheme="http://benym.cn/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-221-最大正方形</title>
    <link href="http://benym.cn/2020/08/11/LeetCode-221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/"/>
    <id>http://benym.cn/2020/08/11/LeetCode-221-最大正方形/</id>
    <published>2020-08-11T03:22:30.000Z</published>
    <updated>2020-08-11T08:04:13.178Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-221-最大正方形"><a href="#LeetCode-221-最大正方形" class="headerlink" title="LeetCode-221-最大正方形"></a>LeetCode-221-最大正方形</h2><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p><a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>方法1、暴力破解：</strong></p><p>引用链接<a href="https://leetcode-cn.com/problems/maximal-square/solution/zui-da-zheng-fang-xing-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximal-square/solution/zui-da-zheng-fang-xing-by-leetcode-solution/</a></p><p>暴力法是最简单直观的做法，具体做法如下：</p><ul><li><p>遍历矩阵中的每个元素，每次遇到 1，则将该元素作为正方形的左上角；</p></li><li><p>确定正方形的左上角后，根据左上角所在的行和列计算可能的最大正方形的边长（正方形的范围不能超出矩阵的行数和列数），在该边长范围内寻找只包含 1 的最大正方形；</p></li><li><p>每次在下方新增一行以及在右方新增一列，判断新增的行和列是否满足所有元素都是 1。</p></li></ul><p><strong>方法2、动态规划：</strong></p><ul><li>状态<code>dp[i][j]</code>表示以第<code>i</code>行第<code>j</code>列为右下角所能构成的最大正方形边长</li></ul><p>则当<code>i==0</code>或者<code>j==0</code>，最大正方形边长始终为1，则<code>dp[i][j]=1</code></p><p>右下角的正方形的最大边长，最多比它的上方，左方，左上方为右下角的正方形边长+1</p><p>最好的情况是这三个方向的正方形大小都一样，这样加上右下角这个点就可以构成更大的正方形。但是如果其中某一个方向形成的正方形大小不一样，合起来就会缺少某个点，这时候的正方形大小只能取3个正方形中，最小的正方形边长+1了。</p><ul><li>状态转移方程为：<code>dp[i][j] = Math.min(dp[i-1][j-1],Math.min(dp[i-1][j],dp[i][j-1]))+1</code></li></ul><h3 id="Java代码1"><a href="#Java代码1" class="headerlink" title="Java代码1"></a>Java代码1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> maxSide = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> maxSide;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length, columns = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    <span class="comment">// 遇到一个 1 作为正方形的左上角</span></span><br><span class="line">                    maxSide = Math.max(maxSide, <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 计算可能的最大正方形边长</span></span><br><span class="line">                    <span class="keyword">int</span> currentMaxSide = Math.min(rows - i, columns - j);</span><br><span class="line">                    <span class="comment">// 遍历可能的最大正方形内的每个元素</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; currentMaxSide; k++) &#123;</span><br><span class="line">                        <span class="comment">// 判断新增的一行一列是否均为 1</span></span><br><span class="line">                        <span class="comment">// 先判断对角线是否为0</span></span><br><span class="line">                        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (matrix[i + k][j + k] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 再判断左上角点的右边和下边是否为0</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; k; m++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (matrix[i + k][j + m] == <span class="string">'0'</span> || matrix[i + m][j + k] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                                flag = <span class="keyword">false</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果flag仍然为true则说明矩阵中全部是1，更新最大边长</span></span><br><span class="line">                        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                            maxSide = Math.max(maxSide, k + <span class="number">1</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSide * maxSide;</span><br></pre></td></tr></table></figure><h3 id="Java代码2"><a href="#Java代码2" class="headerlink" title="Java代码2"></a>Java代码2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> matLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>)&#123;</span><br><span class="line">                        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>],Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]))+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    matLen = Math.max(dp[i][j],matLen);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matLen*matLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      最大正方形
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="DP" scheme="http://benym.cn/tags/DP/"/>
    
      <category term="矩阵" scheme="http://benym.cn/tags/%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-1247-交换字符使得字符串相同</title>
    <link href="http://benym.cn/2020/08/11/LeetCode-1247-%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%BD%BF%E5%BE%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%90%8C/"/>
    <id>http://benym.cn/2020/08/11/LeetCode-1247-交换字符使得字符串相同/</id>
    <published>2020-08-11T01:43:28.000Z</published>
    <updated>2020-08-11T03:21:34.119Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-1247-交换字符使得字符串相同"><a href="#LeetCode-1247-交换字符使得字符串相同" class="headerlink" title="LeetCode-1247-交换字符使得字符串相同"></a>LeetCode-1247-交换字符使得字符串相同</h2><p>有两个长度相同的字符串 s1 和 s2，且它们其中 只含有 字符 “x” 和 “y”，你需要通过「交换字符」的方式使这两个字符串相同。</p><p>每次「交换字符」的时候，你都可以在两个字符串中各选一个字符进行交换。</p><p>交换只能发生在两个不同的字符串之间，绝对不能发生在同一个字符串内部。也就是说，我们可以交换 s1[i] 和 s2[j]，但不能交换 s1[i] 和 s1[j]。</p><p>最后，请你返回使 s1 和 s2 相同的最小交换次数，如果没有方法能够使得这两个字符串相同，则返回 -1 。</p><a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s1 = &quot;xx&quot;, s2 = &quot;yy&quot;</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">交换 s1[0] 和 s2[1]，得到 s1 = &quot;yx&quot;，s2 = &quot;yx&quot;。</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s1 = &quot;xy&quot;, s2 = &quot;yx&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">交换 s1[0] 和 s2[0]，得到 s1 = &quot;yy&quot;，s2 = &quot;xx&quot; 。</span><br><span class="line">交换 s1[0] 和 s2[1]，得到 s1 = &quot;xy&quot;，s2 = &quot;xy&quot; 。</span><br><span class="line">注意，你不能交换 s1[0] 和 s1[1] 使得 s1 变成 &quot;yx&quot;，因为我们只能交换属于两个不同字符串的字符。</span><br></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s1 = &quot;xx&quot;, s2 = &quot;xy&quot;</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>示例4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s1 = &quot;xxyyxyxyxx&quot;, s2 = &quot;xyyxyxxxyx&quot;</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s1.length, s2.length &lt;= 1000</code></li><li><code>s1, s2</code> 只包含 <code>&#39;x&#39;</code> 或 <code>&#39;y&#39;</code>。</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>根据示例1和示例2可知，</p><ul><li>当满足’xx’和’yy’、’yy’和’xx’的时候，只需要1步就可以完成交换</li><li>当满足’xy’和’yx’、’yx’和’xy’的时候，只需要2步就可以完成交换</li></ul><p>以上两种情况可以总结为，当s1=x、s2=y时，记录位x++；当s1=y、s2=x时，记录位y++</p><p>通过判断x和y的个数，计算最少交换字符的次数</p><p>如果x+y是奇数，则返回-1，因为这说明最后还剩下一对，x和y，单字符无法进行交换</p><p>如果x+y是偶数，则分为以下两种情况：</p><ul><li>奇数x+奇数y：每两个x和y对应移动1次，剩下一对x和y对应移动2次</li><li>偶数x+偶数y：每两个x和y对应移动1次</li></ul><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumSwap</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s1.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1.charAt(i)==<span class="string">'x'</span>&amp;&amp;s2.charAt(i)==<span class="string">'y'</span>)&#123;</span><br><span class="line">                x++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s1.charAt(i)==<span class="string">'y'</span>&amp;&amp;s2.charAt(i)==<span class="string">'x'</span>)&#123;</span><br><span class="line">                y++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((x+y)%<span class="number">2</span>==<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// x是奇数</span></span><br><span class="line">        <span class="keyword">if</span>(x%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> x/<span class="number">2</span>+y/<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x/<span class="number">2</span>+y/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      交换字符使得字符串相同
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="字符串" scheme="http://benym.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>网易2021秋招-最小字典序字符串</title>
    <link href="http://benym.cn/2020/08/10/%E7%BD%91%E6%98%932021%E7%A7%8B%E6%8B%9B-%E6%9C%80%E5%B0%8F%E5%AD%97%E5%85%B8%E5%BA%8F%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://benym.cn/2020/08/10/网易2021秋招-最小字典序字符串/</id>
    <published>2020-08-10T02:22:22.000Z</published>
    <updated>2020-08-15T01:45:35.129Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网易2021秋招-最小字典序字符串"><a href="#网易2021秋招-最小字典序字符串" class="headerlink" title="网易2021秋招-最小字典序字符串"></a>网易2021秋招-最小字典序字符串</h2><p>第一行输入2个数字</p><p>第一个数字n代表字符串应该扩充为多少位，第二个数字m代表字符串当前有多少个字符</p><p>第二行输入m个数字，代表当前字符串</p><p>第三行为输出，输出需要满足在不改变当前字符串前后位置的情况下，扩充为长度为n的最小字典序的字符串</p><p>每个数字仅可以选择1次</p><a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5 3</span><br><span class="line">2 3 5</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5 2</span><br><span class="line">4 2</span><br><span class="line">1 3 4 2 5</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>观察用例可以输入的n就是扩展后字符的最大数，且每个数字只可以选择1次</p><p>现有的数字的前后顺序不变，想要字典序最小，插入的数字需要和现有的数字进行比较，小的数字优先插入到现有数字之前。</p><p>可以利用一个队列Queue存储当前的字符，保证先后顺序，同时需要一个n+1的数组，用来保存数字是否被选择的状态。</p><p>将原始的字符串在对应位置置为true，表示已经选择，之后的插入数字中不能从中选择这类数字。同时将这些数字加入Queue保证先后顺序</p><p>利用StringBuilder来进行最终答案的拼接</p><ul><li>循环从1开始到n，进行插入数字和队列数字的大小判断：</li><li>当队列不为空且队列的头部小于新选择数字<code>i</code>时，从队列中取出头部原始的数字加入到结果<code>res</code>中</li><li>如果不小于，则说明未选择的数字应该插入到前面，<code>res.append(i + &quot; &quot;);</code></li><li>如果循环完了，队列中还有值，直接把队列中所有数字按顺序加入<code>res</code>即可</li><li>最后去除首尾空格，返回结果</li></ul><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span> m = sc.nextInt();</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = sc.nextInt();</span><br><span class="line">            visited[num] = <span class="keyword">true</span>;</span><br><span class="line">            queue.offer(num);</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; queue.peek() &lt; i) &#123;</span><br><span class="line">                res.append(queue.poll() + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res.append(i + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            res.append(queue.poll() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res.toString().trim());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      最小字典序字符串
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="字符串" scheme="http://benym.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>网易2021秋招-数组的最多素数个数</title>
    <link href="http://benym.cn/2020/08/10/%E7%BD%91%E6%98%932021%E7%A7%8B%E6%8B%9B-%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%9A%E7%B4%A0%E6%95%B0%E4%B8%AA%E6%95%B0/"/>
    <id>http://benym.cn/2020/08/10/网易2021秋招-数组的最多素数个数/</id>
    <published>2020-08-10T01:50:59.000Z</published>
    <updated>2020-08-10T02:20:45.162Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网易2021秋招-数组的最多素数个数"><a href="#网易2021秋招-数组的最多素数个数" class="headerlink" title="网易2021秋招-数组的最多素数个数"></a>网易2021秋招-数组的最多素数个数</h2><p>第一行输入一个数字n</p><p>第二行输入n个数字，求这n个数字最多能够拆解为多少个素数，且数字拆解之后素数之后等于数字本身。如5可以拆解为2，3；3本身为素数；7可以拆解为2，2，3</p><p>第三行输出数组最多能够拆解成的素数个数</p><p>最多1e6个数，每个数字最大为1e9，1不是素数</p><a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">5 3 7</span><br><span class="line">6</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>观察题目可知，当2的数量最多的时候，数组就拥有最多的素数个数。</p><p><strong>考虑数字范围，需要通过long存储结果，因为累加肯定是超过了int范围</strong></p><p>可以通过判断数字的奇数和偶数来分别进行计算：</p><p>偶数情况直接除以2，奇数情况减去3再除以2，再+1个即可</p><p>观察可知，上面的奇数情况可以直接合并为数字除以2即可，因为减去3也是减去的一个数，这个数最后还是要加回来的。</p><p>所以对每个数字除以2累加即可得到答案。</p><h3 id="Java代码1"><a href="#Java代码1" class="headerlink" title="Java代码1"></a>Java代码1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(sc.nextLine().trim());</span><br><span class="line">        Main main = <span class="keyword">new</span> Main();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = sc.nextInt();</span><br><span class="line">            sum += main.countSu(num);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">countSu</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            sum += num / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum += ((num - <span class="number">3</span>) / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java代码2"><a href="#Java代码2" class="headerlink" title="Java代码2"></a>Java代码2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            res += sc.nextInt() &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      数组的最多素数个数
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-84-柱状图中最大的矩形</title>
    <link href="http://benym.cn/2020/08/07/LeetCode-84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/"/>
    <id>http://benym.cn/2020/08/07/LeetCode-84-柱状图中最大的矩形/</id>
    <published>2020-08-07T02:13:52.000Z</published>
    <updated>2020-08-07T07:16:51.589Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-84-柱状图中最大的矩形"><a href="#LeetCode-84-柱状图中最大的矩形" class="headerlink" title="LeetCode-84-柱状图中最大的矩形"></a>LeetCode-84-柱状图中最大的矩形</h2><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 <code>[2,1,5,6,2,3]</code>。</p><p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 <code>10</code> 个单位。</p><a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,1,5,6,2,3]</span><br><span class="line">输出: 10</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>方法1、暴力破解：</strong></p><p>固定一个柱子的高度，往左和右寻找第一个高度小于当前柱子的柱体，向左和向右走的步数即是宽度</p><p>对于每个柱子，都计算一次以当前柱子为高度，左右寻找位置为宽度围成的矩形面积，最后得到最大的面积即可</p><p><strong>方法2、单调栈：</strong></p><p>我们可以 O(1) 的获取柱体 i 左边第一个比它小的柱体吗？答案就是单调增栈，因为对于栈中的柱体来说，栈中下一个柱体就是左边第一个高度小于自身的柱体。</p><p>视频详解<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhu-zhuang-tu-zhong-zui-da-de-ju-xing-by-leetcode-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhu-zhuang-tu-zhong-zui-da-de-ju-xing-by-leetcode-/</a></p><p><strong>方法3、单调栈+哨兵：</strong></p><p>视频详解<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhu-zhuang-tu-zhong-zui-da-de-ju-xing-by-leetcode-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhu-zhuang-tu-zhong-zui-da-de-ju-xing-by-leetcode-/</a></p><h3 id="Java代码1"><a href="#Java代码1" class="headerlink" title="Java代码1"></a>Java代码1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = heights.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> width = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> height = heights[i];</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span>(--j&gt;=<span class="number">0</span>&amp;&amp;heights[j]&gt;=height)&#123;</span><br><span class="line">                width++;</span><br><span class="line">            &#125;</span><br><span class="line">            j = i;</span><br><span class="line">            <span class="keyword">while</span>(++j&lt;len&amp;&amp;heights[j]&gt;=height)&#123;</span><br><span class="line">                width++;</span><br><span class="line">            &#125;</span><br><span class="line">            area = Math.max(area,width*height);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java代码2"><a href="#Java代码2" class="headerlink" title="Java代码2"></a>Java代码2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = heights.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> heights[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty()&amp;&amp;heights[stack.peekLast()]&gt;heights[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> height = heights[stack.removeLast()];</span><br><span class="line">                <span class="keyword">while</span>(!stack.isEmpty()&amp;&amp;heights[stack.peekLast()]==height)&#123;</span><br><span class="line">                    stack.removeLast();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> width;</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                    width = i;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    width = i-stack.peekLast()-<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                area = Math.max(area,width*height);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> height = heights[stack.removeLast()];</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty()&amp;&amp;heights[stack.peekLast()]==height)&#123;</span><br><span class="line">                stack.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> width;</span><br><span class="line">            <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                width = len;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                width = len-stack.peekLast()-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            area = Math.max(area,width*height);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java代码3"><a href="#Java代码3" class="headerlink" title="Java代码3"></a>Java代码3</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = heights.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> heights[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] newHeights = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            newHeights[i + <span class="number">1</span>] = heights[i];</span><br><span class="line">        &#125;</span><br><span class="line">        len += <span class="number">2</span>;</span><br><span class="line">        heights = newHeights;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;();</span><br><span class="line">        stack.addLast(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (heights[stack.peekLast()] &gt; heights[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> height = heights[stack.removeLast()];</span><br><span class="line">                <span class="keyword">int</span> width = i - stack.peekLast() - <span class="number">1</span>;</span><br><span class="line">                area = Math.max(area, width * height);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      柱状图中最大的矩形
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Hard" scheme="http://benym.cn/tags/Hard/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-543-二叉树的直径</title>
    <link href="http://benym.cn/2020/08/07/LeetCode-543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
    <id>http://benym.cn/2020/08/07/LeetCode-543-二叉树的直径/</id>
    <published>2020-08-07T01:29:27.000Z</published>
    <updated>2020-08-07T02:12:08.480Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-543-二叉树的直径"><a href="#LeetCode-543-二叉树的直径" class="headerlink" title="LeetCode-543-二叉树的直径"></a>LeetCode-543-二叉树的直径</h2><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><a id="more"></a><p><strong>示例1：</strong></p><p>给定二叉树</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \     </span><br><span class="line">4   5</span><br></pre></td></tr></table></figure><p>返回 <strong>3</strong>, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p><p><strong>注意：</strong>两结点之间的路径长度是以它们之间边的数目表示。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>方法1、DFS：</strong></p><ol><li>二叉树的直径是不一定经过root节点的，可能存在于每个子树中，所以需要遍历每个节点的左右子树深度。动态记录最大的直径</li><li>直径 = max(左子树深度+右子树深度)</li><li>某节点子树的深度 = max(某节点左子树深度，某节点右子树深度)+1</li></ol><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        calDepth(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calDepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = calDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = calDepth(root.right);</span><br><span class="line">        res = Math.max(left+right,res);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      二叉树的直径
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="树" scheme="http://benym.cn/tags/%E6%A0%91/"/>
    
      <category term="Easy" scheme="http://benym.cn/tags/Easy/"/>
    
      <category term="DFS" scheme="http://benym.cn/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-62-不同路径</title>
    <link href="http://benym.cn/2020/08/06/LeetCode-62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
    <id>http://benym.cn/2020/08/06/LeetCode-62-不同路径/</id>
    <published>2020-08-06T05:19:12.000Z</published>
    <updated>2020-08-06T07:13:51.401Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-62-不同路径"><a href="#LeetCode-62-不同路径" class="headerlink" title="LeetCode-62-不同路径"></a>LeetCode-62-不同路径</h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: m = 3, n = 2</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line">2. 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: m = 7, n = 3</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= m, n &lt;= 100</code></li><li>题目数据保证答案小于等于 <code>2 * 10 ^ 9</code></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>方法1、动态规划：</strong></p><p>这道题是个经典的动态规划问题，初始化矩阵大小的dp数组保存数字，由于只能往右或者往下走所以第1行和第1列都是1</p><p><code>dp[i][j]</code>状态定义为：有多少条路径到i，j这一格</p><p>状态转移方程：</p><ul><li>当i==0或者j==0时，<code>dp[i][j]=1</code></li><li>其余位置，<code>dp[i][j]</code>的值依赖于左边位置的路径+上边位置的路径，即<code>dp[i - 1][j] + dp[i][j - 1]</code></li></ul><p>最后返回右下角的值即可</p><p><strong>方法2、动态规划(空间优化)：</strong></p><p>由于每格的值仅与左侧和上方的值有关，所以只需要维护一行的值即可，空间复杂度可以降到O(N)</p><h3 id="Java代码1"><a href="#Java代码1" class="headerlink" title="Java代码1"></a>Java代码1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java代码2"><a href="#Java代码2" class="headerlink" title="Java代码2"></a>Java代码2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">                dp[j] += dp[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      不同路径
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="DP" scheme="http://benym.cn/tags/DP/"/>
    
      <category term="矩阵" scheme="http://benym.cn/tags/%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-75-颜色分类</title>
    <link href="http://benym.cn/2020/08/06/LeetCode-75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/"/>
    <id>http://benym.cn/2020/08/06/LeetCode-75-颜色分类/</id>
    <published>2020-08-06T01:47:45.000Z</published>
    <updated>2020-08-06T05:13:51.476Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-75-颜色分类"><a href="#LeetCode-75-颜色分类" class="headerlink" title="LeetCode-75-颜色分类"></a>LeetCode-75-颜色分类</h2><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p><strong>注意:</strong><br>不能使用代码库中的排序函数来解决这道题。</p><a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,0,2,1,1,0]</span><br><span class="line">输出: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure><p><strong>进阶：</strong></p><ul><li>一个直观的解决方案是使用计数排序的两趟扫描算法。<br>首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。</li><li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>方法1、计数排序：</strong></p><p>初始化max+1容量的桶，将数组值为下标的元素放入对应的桶内，并进行计数，如nums[2]=3，则bucket[3]+1。之后从每个桶中取出元素，重新放入原本的数组，实现原地修改。需要多次遍历数组。当然使用快排也可以，但题目要求使用一趟的扫描算法。</p><p><strong>方法2、三指针一次遍历(荷兰国旗问题)：</strong></p><p>我们用三个指针（p0, p2 和curr）来分别追踪0的最右边界，2的最左边界和当前考虑的元素。</p><p>本解法的思路是沿着数组移动 curr 指针，若nums[curr] = 0，则将其与 nums[p0]互换；若 nums[curr] = 2 ，则与 nums[p2]互换。</p><p>算法</p><ul><li><p>初始化0的最右边界：p0 = 0。在整个算法执行过程中 nums[idx &lt; p0] = 0.</p></li><li><p>初始化2的最左边界 ：p2 = n - 1。在整个算法执行过程中 nums[idx &gt; p2] = 2.</p></li><li><p>初始化当前考虑的元素序号 ：curr = 0.</p></li><li><p>While curr &lt;= p2 :</p><ul><li>若 nums[curr] = 0 ：交换第 curr个 和 第p0个 元素，并将指针都向右移。</li><li>若 nums[curr] = 2 ：交换第 curr个和第 p2个元素，并将 p2指针左移 。</li><li>若 nums[curr] = 1 ：将指针curr右移。</li></ul></li></ul><h3 id="Java代码1"><a href="#Java代码1" class="headerlink" title="Java代码1"></a>Java代码1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || len &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            max = Math.max(max, num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            bucket[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucket.length; j++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (bucket[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                nums[index] = j;</span><br><span class="line">                bucket[j] -= <span class="number">1</span>;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java代码2"><a href="#Java代码2" class="headerlink" title="Java代码2"></a>Java代码2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//只有三种数  0 1 2</span></span><br><span class="line">    <span class="comment">// 直接冒泡排序  时间复杂度不符合</span></span><br><span class="line">    <span class="comment">// 双指针  p_0 标注 0元素的最右边   p_2 标注 2元素的最最左边</span></span><br><span class="line">    <span class="comment">// curr 指针，标注当前元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p2 = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">while</span>(curr&lt;=p2)&#123;</span><br><span class="line">            <span class="comment">//如果当前元素等于0，则与P_0互换位置</span></span><br><span class="line">            <span class="keyword">if</span>(nums[curr]==<span class="number">0</span>)&#123;</span><br><span class="line">                temp = nums[p1];</span><br><span class="line">                nums[p1] = nums[curr];</span><br><span class="line">                nums[curr] = temp;</span><br><span class="line">                curr++;</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[curr]==<span class="number">2</span>)&#123;<span class="comment">//如果当前元素等于2，则与P_2互换位置</span></span><br><span class="line">                temp = nums[p2];</span><br><span class="line">                nums[p2] = nums[curr];</span><br><span class="line">                nums[curr] = temp;</span><br><span class="line">                p2--;</span><br><span class="line">            <span class="comment">//因为curr左边的值已经扫描过了，所以curr要++继续扫描下一位，而与p2交换的值，curr未扫描，要停下来扫描一下，所以curr不用++</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curr++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      颜色分类
    
    </summary>
    
      <category term="LeetCode" scheme="http://benym.cn/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://benym.cn/tags/Java/"/>
    
      <category term="Medium" scheme="http://benym.cn/tags/Medium/"/>
    
      <category term="数组" scheme="http://benym.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
</feed>
