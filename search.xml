<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Coursera课后作业——ex1]]></title>
    <url>%2F2018%2F10%2F07%2FCoursera%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E2%80%94%E2%80%94ex1%2F</url>
    <content type="text"><![CDATA[很久以前做的，还是提交一下 线性回归基础（ Linear regression ） Hypothesis: h_{\theta }(x)=\theta _{0}+\theta _{1}x Parameters: \theta _{0},\theta _{1} cost Funcition: J(\theta _{0},\theta _{1})=\frac{1}{2m}\sum_{i=1}^{m}(h_{\theta}(x^{(i)})-y^{(i)})^{2}​ goal: minimize_{\theta _{0},\theta _{1}}J(\theta _{0},\theta _{1})在最小化损失函数的过程中需要用到梯度下降算法（Gradient descent） 梯度下降算法（Gradient descent ） Have some function: J(\theta _{0},\theta _{1}) Want: minimize_{\theta _{0},\theta _{1}}J(\theta _{0},\theta _{1})Outline: start with some $\theta _{0},\theta _{1}$,(一般都取0) keep changing $\theta _{0},\theta _{1}$ to reduce $J(\theta _{0},\theta _{1})$，直到我们找到J的最小值或是局部最小值 repeat until convergence｛ \theta _{j}:=\theta _{j}-\frac{\alpha }{m}(h_{\theta^{(i)} }-y^{(i))})x_{j}^{(i)}(simultaneously update θj for all j) ｝ 代码主函数ex1.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122%% Machine Learning Online Class - Exercise 1: Linear Regression% Instructions% ------------% % This file contains code that helps you get started on the% linear exercise. You will need to complete the following functions % in this exericse:%% warmUpExercise.m% plotData.m% gradientDescent.m% computeCost.m% gradientDescentMulti.m% computeCostMulti.m% featureNormalize.m% normalEqn.m%% For this exercise, you will not need to change any code in this file,% or any other files other than those mentioned above.%% x refers to the population size in 10,000s% y refers to the profit in $10,000s%%% Initializationclear ; close all; clc%% ==================== Part 1: Basic Function ====================% Complete warmUpExercise.m fprintf('Running warmUpExercise ... \n');fprintf('5x5 Identity Matrix: \n');warmUpExercise()fprintf('Program paused. Press enter to continue.\n');pause;%% ======================= Part 2: Plotting =======================fprintf('Plotting Data ...\n')data = load('ex1data1.txt');X = data(:, 1); y = data(:, 2);%第一列数据给X，第二列数据给ym = length(y); % 训练样本的个数% Plot Data% Note: You have to complete the code in plotData.mplotData(X, y); %传入X和y进行画图fprintf('Program paused. Press enter to continue.\n');pause;%% =================== Part 3: Gradient descent ===================fprintf('Running Gradient Descent ...\n')X = [ones(m, 1), data(:,1)]; % Add a column of ones to x 考虑到截取项theta0，为X增加额外的一列theta = zeros(2, 1); % initialize fitting parameters 定义一个2行1列值为0的向量% Some gradient descent settingsiterations = 1500; %迭代次数alpha = 0.01; %学习率% compute and display initial costcomputeCost(X, y, theta) %计算代价函数J（theta）% run gradient descenttheta = gradientDescent(X, y, theta, alpha, iterations); %获得theta0和theta1% print theta to screenfprintf('Theta found by gradient descent: ');fprintf('%f %f \n', theta(1), theta(2));% Plot the linear fithold on; % keep previous plot visibleplot(X(:,2), X*theta, '-') %以X的第2列为横坐标，X*theta为纵坐标，横线为标记画图legend('Training data', 'Linear regression')hold off % don't overlay any more plots on this figure% Predict values for population sizes of 35,000 and 70,000predict1 = [1, 3.5] *theta; %预测人口为35000的时候的利润fprintf('For population = 35,000, we predict a profit of %f\n',... predict1*10000);predict2 = [1, 7] * theta; %预测人口为70000的时候的利润fprintf('For population = 70,000, we predict a profit of %f\n',... predict2*10000);fprintf('Program paused. Press enter to continue.\n');pause;%% ============= Part 4: Visualizing J(theta_0, theta_1) ============= 可视化J（theta）fprintf('Visualizing J(theta_0, theta_1) ...\n')% Grid over which we will calculate Jtheta0_vals = linspace(-10, 10, 100);% 生成-10到10之间，间距为（10-（-10)）/（100-1）的长度为100的数组（即间距为0.2020）theta1_vals = linspace(-1, 4, 100); % 生成-1到4，间距为0.051的长度为100的数组% initialize J_vals to a matrix of 0'sJ_vals = zeros(length(theta0_vals), length(theta1_vals));% Fill out J_valsfor i = 1:length(theta0_vals) for j = 1:length(theta1_vals) t = [theta0_vals(i); theta1_vals(j)]; J_vals(i,j) = computeCost(X, y, t); endend% Because of the way meshgrids work in the surf command, we need to % transpose J_vals before calling surf, or else the axes will be flippedJ_vals = J_vals';% Surface plotfigure;surf(theta0_vals, theta1_vals, J_vals) % 三维图xlabel('\theta_0'); ylabel('\theta_1');% Contour plotfigure;% Plot J_vals as 15 contours spaced logarithmically between 0.01 and 100contour(theta0_vals, theta1_vals, J_vals, logspace(-2, 3, 20)) % 等高线xlabel('\theta_0'); ylabel('\theta_1');hold on;plot(theta(1), theta(2), 'rx', 'MarkerSize', 10, 'LineWidth', 2); 计算损失函数部分computeCost.m 123456789101112131415161718192021222324function J = computeCost(X, y, theta)%COMPUTECOST Compute cost for linear regression% J = COMPUTECOST(X, y, theta) computes the cost of using theta as the% parameter for linear regression to fit the data points in X and y% Initialize some useful valuesm = length(y); % number of training examples% You need to return the following variables correctly J = 0;% ====================== YOUR CODE HERE ======================% Instructions: Compute the cost of a particular choice of theta% You should set J to the cost.predictions = X*theta; % h_theta(x)=thetaT*xsqerrors = (predictions - y).^2; J = 1/(2*m)* sum(sqerrors);% =========================================================================end 绘图部分plotData.m 12345678910111213141516171819202122232425262728function plotData(x, y)%PLOTDATA Plots the data points x and y into a new figure % PLOTDATA(x,y) plots the data points and gives the figure axes labels of% population and profit.% ====================== YOUR CODE HERE ======================% Instructions: Plot the training data into a figure using the % "figure" and "plot" commands. Set the axes labels using% the "xlabel" and "ylabel" commands. Assume the % population and revenue data have been passed in% as the x and y arguments of this function.%% Hint: You can use the 'rx' option with plot to have the markers% appear as red crosses. Furthermore, you can make the% markers larger by using plot(..., 'rx', 'MarkerSize', 10);figure; % open a new figure windowplot(x, y, 'rx', 'MarkerSize', 10); % Plot the data 用红色的大小为10的×来进行标记，横坐标是X，纵坐标是yylabel('Profit in $10,000s'); % Set the y axis labelxlabel('Population of City in 10,000s'); % Set the x axis label% ============================================================end 梯度下降gradientDescent.m 12345678910111213141516171819202122232425262728293031323334function [theta, J_history] = gradientDescent(X, y, theta, alpha, num_iters)%GRADIENTDESCENT Performs gradient descent to learn theta% theta = GRADIENTDESENT(X, y, theta, alpha, num_iters) updates theta by % taking num_iters gradient steps with learning rate alpha% Initialize some useful valuesm = length(y); % number of training examplesJ_history = zeros(num_iters, 1);for iter = 1:num_iters % ====================== YOUR CODE HERE ====================== % Instructions: Perform a single gradient step on the parameter vector % theta. % % Hint: While debugging, it can be useful to print out the values % of the cost function (computeCost) and gradient here. % predictions = X * theta; updates = X' * (predictions - y); theta = theta - alpha * (1/m) * updates; %theta = theta - alpha * (1/m) * sum(sqerrors) * X; %theta - (alpha/m) * (X' * (X * theta - y)); %theta = theta - (alpha/m) * (X' * (X * theta - y)); % ============================================================ % Save the cost J in every iteration J_history(iter) = computeCost(X, y, theta);endend 运行结果 线性回归拟合之后 绘制梯度下降等高线 判断梯度下降是否达到最低点 预测结果 上图得到$\theta _{1},\theta _{2}$的数值以及在人口为35000和70000时，分别可以获得的利润]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>matlab</tag>
        <tag>Coursera</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[域名备案成功]]></title>
    <url>%2F2018%2F09%2F17%2F%E5%9F%9F%E5%90%8D%E5%A4%87%E6%A1%88%E6%88%90%E5%8A%9F%2F</url>
    <content type="text"><![CDATA[经历十几天的备案流程，域名备案总算成功了，博客恢复更新（ps:最近比较忙，空了写= =）]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Face</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将hexo自定义域名升级https]]></title>
    <url>%2F2018%2F08%2F29%2F%E5%B0%86hexo%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%8D%87%E7%BA%A7https%2F</url>
    <content type="text"><![CDATA[前言Tips:有什么问题可以在下方留言板留言哦，留下自己的邮箱，可以保证快速回复 最近在折腾博客，发现github上很多人说个人博客支持https很重要，原本的github.io域名本来支持https协议，但是在自定义域名之后，协议变成了http。这使得网站变得不够安全，容易被劫持。 但是网上的支持https很多都是反向代理，以及SSL证书等，涉及到备案还有一些配置操作，算是比较麻烦，期间如果不对还会出现各种bug。所以针对简单想支持全站https的站长而言，我们可以选择如下操作： 对于github解析的用户 打开Github Pages页面的强制HTTPS 在此之前，请确认上图中的Custom domain已经写为你的自定义域名 然后再勾选Enforce HTTPS即可 对于coding解析的用户 打开Coding Pages服务的强制HTTPS访问 对于没有引用外部链接的同学来说，你已经获得了https认证，在谷歌浏览器中可见网站的小绿锁，但是对于大部分站长来说都有自己的云存储来保存自己的图片或者文件，于是我们需要一个图床或者云对象存储并且它支持https协议。 云存储对象的选择（腾讯云）在百度中想要支持https外链的图床有不少，如简单图床、SM.MS、imgur、路过图床等，读者如果仅仅需要引用图片文件，那么这些图床完全满足你的要求，并可以保证全站https。但是笔者需要存储的不仅仅是图片，有事还会存储文件，而这些图床只能存储图片，不能存储其他文件，这就无法保证我其他文件的https链接，笔者偶然间发现，腾讯云的对象存储具有不错的空间，并且支持https协议的外链，而且免费，于是把整个云存储搬去腾讯云，更换外链后完成了全站https。 腾讯云对象存储添加1、在云产品中选择对象存储 2、创建存储桶 2.1关于存储的容量问题：每个存储桶中的对象不限 每月免费存储额度50GB，下行流量10GB，对于一个个人博客流量还不大的情况下完全足够了 3、创建存储桶后上传自己的文件，然后点击详情，可以看到他的https外部链接 4、更换自己的md文件的外部链接即可，然后重新部署hexo，就可以看到效果了]]></content>
      <categories>
        <category>HTTPS</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将下载下来的MNIST手写数字数据集转化成为图片]]></title>
    <url>%2F2018%2F08%2F26%2F%E5%B0%86%E4%B8%8B%E8%BD%BD%E4%B8%8B%E6%9D%A5%E7%9A%84MNIST%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E6%95%B0%E6%8D%AE%E9%9B%86%E8%BD%AC%E5%8C%96%E6%88%90%E4%B8%BA%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[解析源文件下载（总共包含60000个训练数据和10000个测试数据） 训练集解析 测试集解析 对于训练集的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import numpy as npimport structfrom PIL import Imageimport osdata_file = 'MNIST_data\\train-images.idx3-ubyte' # 需要修改的路径# It's 47040016B, but we should set to 47040000Bdata_file_size = 47040016data_file_size = str(data_file_size - 16) + 'B'data_buf = open(data_file, 'rb').read()magic, numImages, numRows, numColumns = struct.unpack_from( '&gt;IIII', data_buf, 0)datas = struct.unpack_from( '&gt;' + data_file_size, data_buf, struct.calcsize('&gt;IIII'))datas = np.array(datas).astype(np.uint8).reshape( numImages, 1, numRows, numColumns)label_file = 'MNIST_data\\train-labels.idx1-ubyte' # 需要修改的路径# It's 60008B, but we should set to 60000Blabel_file_size = 60008label_file_size = str(label_file_size - 8) + 'B'label_buf = open(label_file, 'rb').read()magic, numLabels = struct.unpack_from('&gt;II', label_buf, 0)labels = struct.unpack_from( '&gt;' + label_file_size, label_buf, struct.calcsize('&gt;II'))labels = np.array(labels).astype(np.int64)datas_root = 'MNIST_data\\' # 需要修改的路径if not os.path.exists(datas_root): os.mkdir(datas_root)for i in range(10): file_name = datas_root + os.sep + str(i) if not os.path.exists(file_name): os.mkdir(file_name)for ii in range(numLabels): img = Image.fromarray(datas[ii, 0, 0:28, 0:28]) label = labels[ii] file_name = datas_root + os.sep + str(label) + os.sep + \ 'mnist_train_' + str(ii) + '.png' img.save(file_name) 对于测试集的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import numpy as npimport structfrom PIL import Imageimport osdata_file = 'MNIST_data\\t10k-images.idx3-ubyte' # 需要修改的路径# It's 7840016B, but we should set to 7840000Bdata_file_size = 7840016data_file_size = str(data_file_size - 16) + 'B'data_buf = open(data_file, 'rb').read()magic, numImages, numRows, numColumns = struct.unpack_from( '&gt;IIII', data_buf, 0)datas = struct.unpack_from( '&gt;' + data_file_size, data_buf, struct.calcsize('&gt;IIII'))datas = np.array(datas).astype(np.uint8).reshape( numImages, 1, numRows, numColumns)label_file = 'MNIST_data\\t10k-labels.idx1-ubyte' # 需要修改的路径# It's 10008B, but we should set to 10000Blabel_file_size = 10008label_file_size = str(label_file_size - 8) + 'B'label_buf = open(label_file, 'rb').read()magic, numLabels = struct.unpack_from('&gt;II', label_buf, 0)labels = struct.unpack_from( '&gt;' + label_file_size, label_buf, struct.calcsize('&gt;II'))labels = np.array(labels).astype(np.int64)datas_root = 'MNIST_data\\test_dataset' # 需要修改的路径if not os.path.exists(datas_root): os.mkdir(datas_root)for i in range(10): file_name = datas_root + os.sep + str(i) if not os.path.exists(file_name): os.mkdir(file_name)for ii in range(numLabels): img = Image.fromarray(datas[ii, 0, 0:28, 0:28]) label = labels[ii] file_name = datas_root + os.sep + str(label) + os.sep + \ 'mnist_test_' + str(ii) + '.png' img.save(file_name)]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>机器学习</tag>
        <tag>MNIST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些TensorFlow的基本操作]]></title>
    <url>%2F2018%2F08%2F26%2F%E4%B8%80%E4%BA%9BTensorFlow%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[简单用代码说明Tensor,变量,Fetch,Feed的使用 TensorTensorFlow 程序使用 tensor 数据结构来代表所有的数据, 计算图中, 操作间传递的数据都是 tensor. 你可以把 TensorFlow tensor 看作是一个 n 维的数组或列表. 一个 tensor 包含一个静态类型 rank, 和 一个 shape. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# @Time : 2018/8/26 16:08# @Author : YuanMing# @File : 变量.py# @Software: PyCharmimport tensorflow as tf# 创建一个变量，初始化变量0state = tf.Variable(0, name="counter")# 创建一个op，其作用是使state增加1one = tf.constant(1)new_value = tf.add(state, one)'''代码中 assign() 操作是图所描绘的表达式的一部分, 正如 add() 操作一样. 所以在调用 run() 执行表达式之前, 它并不会真正执行赋值操作.'''update = tf.assign(state, new_value)# 启动图后，变量必须先经过'初始化'（init）op初始化# 首先必须增加一个'初始化'op到图中init_op = tf.initialize_all_variables()# 启动图，运行opwith tf.Session() as sess: # 运行'init' op sess.run(init_op) # 打印'state'的初始值 print(sess.run(state)) # 运行op,更新'state'，并打印'state' for _ in range(3): sess.run(update) print(sess.run(state))'''Fetch为了取回操作的输出内容, 可以在使用 Session 对象的 run() 调用 执行图时, 传入一些 tensor, 这些 tensor 会帮助你取回结果. 在之前的例子里, 我们只取回了单个节点 state, 但是你也可以取回多tensor:'''input1 = tf.constant(3.0)input2 = tf.constant(2.0)input3 = tf.constant(5.0)intermed = tf.add(input2, input3)mul = tf.multiply(input1, intermed)with tf.Session() as sess: result = sess.run([mul, intermed]) print(result)'''Feedfeed 机制, 该机制 可以临时替代图中的任意操作中的 tensor可以对图中任何操作提交补丁, 直接插入一个 tensor.最常见的用例是将某些特殊的操作指定为 "feed" 操作, 标记的方法是使用 tf.placeholder() 为这些操作创建占位符.'''input1 = tf.placeholder(tf.float32)input2 = tf.placeholder(tf.float32)output = tf.multiply(input1, input2)with tf.Session() as sess: print(sess.run([output], feed_dict=&#123;input1:[7.], input2:[2.]&#125;)) 运行结果1234560123[21.0, 7.0][array([14.], dtype=float32)]]]></content>
      <categories>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>机器学习</tag>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[交互式使用]]></title>
    <url>%2F2018%2F08%2F26%2F%E4%BA%A4%E4%BA%92%E5%BC%8F%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[文档中的 Python 示例使用一个会话 Session 来 启动图, 并调用 Session.run() 方法执行操作. 为了便于使用诸如 IPython 之类的 Python 交互环境, 可以使用 InteractiveSession代替 Session 类, 使用 Tensor.eval() 和 Operation.run() 方法代替Session.run(). 这样可以避免使用一个变量来持有会话. 代码12345678910111213# 进入一个交互式TensorFlow会话import tensorflow as tfsess = tf.InteractiveSession()x = tf.Variable([1.0,2.0])a = tf.constant([3.0,3.0])# 使用初始化器 initializer op 的run()方法初始化'x'x.initializer.run()# 增加一个减法subtract op，从'x'减去'a'，运行减法op，输出结果sub = tf.subtract(x,a)print(sub.eval()) 运行结果1[-2. -1.]]]></content>
      <categories>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>机器学习</tag>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划问题——最长上升子序列(LIS)(三)]]></title>
    <url>%2F2018%2F08%2F26%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97(LIS)(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[推荐链接： 动态规划问题——最长上升子序列(LIS)(一) 动态规划问题——最长上升子序列(LIS)(二) 大佬给的思路，宝石叔叔博客里面有更多精彩！ 上一个版本用二分法优化了时间复杂度，但其实根据数据的样本观察可知，后面的数据都是重复的，我们只需要当列表遍历到一小时数据的最后时将后面数据的最大数加入到列表即可，这样可以快速跳出循环，避免后面不必要的查找 以下代码略有区别，一种是计算数目，一种是使用新列表存储，但大致思路类似。 写完之后发现可以考虑的情况还是有的，还可以继续优化，不过优化到这里应该也差不多了，列表的append方法性能上是非常好的。两个版本Java耗时0.000196s，Python耗时0.000050s Java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); while (true) &#123; int k = scan.nextInt(); int t = scan.nextInt(); int[] arr = new int[k]; for (int i = 0; i &lt; arr.length; ++i) arr[i] = scan.nextInt(); System.out.println(new Main().lengthOfLIS(arr, t)); &#125; &#125; public int lengthOfLIS(int[] nums, int count) &#123; int[] dp = new int[nums.length]; dp[0] = -1; // 获取nums数组里面的最大数字 int[] maxCount = getMaxCount(nums); int maxLen = 0, t = 1; boolean flag = true; for (; t &lt;= count; t++) &#123; int count2 = 0; if (flag) &#123; for (int i = 0; i &lt; nums.length; i++) &#123; if (maxLen == 0) &#123; dp[maxLen++] = nums[i]; &#125; else &#123; if (nums[i] &gt;= dp[maxLen - 1]) &#123; if (nums[i] == maxCount[0]) count2++; dp[maxLen++] = nums[i]; if (maxLen - 1 == nums.length - 1) &#123; flag = false; maxLen += maxCount[1] - count2; break; &#125; &#125; else &#123; int index = binarySearch(dp, maxLen - 1, nums[i]); dp[index] = nums[i]; &#125; &#125; &#125; if (!flag) break; &#125; &#125; return maxLen + (count - t) * maxCount[1]; &#125; public int binarySearch(int[] dp, int len, int target) &#123; int start = 0, end = len - 1; while (start &lt;= end) &#123; int mid = (start + end) / 2; if (dp[mid] &gt; target) end = mid - 1; else if (dp[mid] &gt; target) start = mid + 1; else return mid; &#125; return start; &#125; public int[] getMaxCount(int[] nums) &#123; int max = Integer.MIN_VALUE, count = 0; for (int i = 0; i &lt; nums.length; i++) max = Math.max(max, nums[i]); for (int i = 0; i &lt; nums.length; i++) &#123; if (max == nums[i]) count++; &#125; return new int[]&#123;max, count&#125;; &#125;&#125; Python代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162def longestIncreasingSubsequence(nums, n, m): if nums == None or len(nums) == 0: return 0 testarray = list() maxNum = max(nums) minNum = min(nums) count = 0 for i in range(len(nums)): if i == n: for j in range(m - 1): testarray.append(maxNum) break # 如果是第一个位置就直接添加进新的列表里面，如果后一个元素比新列表的最后一个元素大或者等于，则添加该元素到新列表末尾 if len(testarray) == 0 or nums[i] &gt;= testarray[len(testarray) - 1]: testarray.append(nums[i]) # 这一行的目的是保证新列表中的数据全部都是顺序递增的，不让后面的小的数据插入到前面，防止数列个数对了，但是实际上数据不是正序的情况 # 1、如果是一小时采样点的最后一个，比如8 6 7 4， 4就是一小时中最后一个采样点，而且这个数是最小值，就跳过本次循环 # 2、如果是一小时采样点的最后一个，比如10 3 7 5， 5就是一小时中最后一个采样点，而且这个数比之前数列的最后一个值小，就跳过本次循环 elif nums[i] == minNum and (i % (n - 1) == 0) or nums[i] &lt; testarray[len(testarray) - 1] and (i % (n - 1) == 0): continue else: # 如果这个新元素不大于等于最后一个元素的时候，利用二分查找找到他在新列表中应该插入的位置 index = findFirstLargeEqual(testarray, nums[i]) # 将新元素替换对应位置的列表里面的元素 testarray[index] = nums[i] return len(testarray)# 利用二分查找法def findFirstLargeEqual(testarray, target): left = 0 right = len(testarray) - 1 if testarray[0] == target: return 0 while left &lt;= right: # 双斜杠整除 mid = (left + right) // 2 if testarray[mid] &gt; target: right = mid - 1 elif testarray[mid] &lt; target: left = mid + 1 else: return mid return leftif __name__ == "__main__": a = list() # 输入n m n, m = input().split() # 输入采样点 n = int(n) a = input().split() # 截取输入的前n个（控制输入） a = a[:n] # 全部转化为整形 for i in range(n): a[i] = int(a[i]) # 按照小时数重复 a = a * int(m) count = longestIncreasingSubsequence(a, n, int(m)) print(count) 运行结果1235 105 6 7 9 113]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>算法</tag>
        <tag>Java</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划问题——最长上升子序列(LIS)(二)]]></title>
    <url>%2F2018%2F08%2F25%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97(LIS)(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[推荐链接： 动态规划问题——最长上升子序列(LIS)(一) 动态规划问题——最长上升子序列(LIS)(三) 题目描述一天，小凯同学震惊的发现，自己无内的PM2.5指标是有规律的！小凯采样了PM2.5数值，发现PM2.5数值以小时为周期循环，即任意时刻的PM2.5总是和一小时前相等！他的室友小文同学提出了这样一个问题，在t小时内的所有采样点中，选取若干采样点的数值，能否找到一个PM2.5不曾下降过的序列？这个序列最长是多少？ 输入描述第一行有两个整数n和t，表示每小时的采样点个数，和询问多少个小时的结果。第二行有n个整数，以空格分割，表示一小时内，每个采样点观测到的PM2.5数值 输出描述一个整数，表示T小时内，最长的PM2.5不曾下降过的序列的长度 输入124 310 3 7 5 输出14 说明3小时内的所有采样点为 10 3 7 5 10 3 7 5 10 3 7 5 选取第2，3，5，9个采样点，可以得到一个不曾下降过的序列 3 7 10 10 使用其他的方法也可以得到长为4的满足条件的序列，但无法得到长度超过4的结果。 备注12345对于20%的数据，t=1对于50%的数据，t&lt;=1000对于80%的数据，PM2.5数值不超过200对于100%的数据，1&lt;=n&lt;=1000,1&lt;=t&lt;=1000000，PM2.5数值为正整数，且不超过1000000000 优化时间复杂度(外层为n，内层为logn) 这里是定义一个testarray数组，存储这个升序子序列，对于新来的元素，通过二分查找，插入到这个testarray数组中，当大于或者等于testarray数组最后一个元素的时候直接在最后插入，如果在testarray数组中间位置，就直接在中间位置插入,(Tips：说明中间位置额那个数比需要插入的数字大，我们找的是最长的升序子序列，比他大的当然需要被小的替代了)，由于testarray数组是动态变化的，最后testarray数组的大小就是最长升序子序列，并且其存储的数就是这个升序子序列。 Java代码1234567891011121314151617181920212223242526272829303132public class Solution &#123; public int longestIncreasingSubsequence(int[] nums) &#123; int len = nums.length; if(nums == null || len ==0) return 0; ArrayList&lt;Integer&gt; dp = new ArrayList&lt;Integer&gt;(); for(int i=0;i&lt;len ;i++)&#123; if(dp.isEmpty() || dp.get(dp.size() - 1) &lt;= nums[i]) dp.add(nums[i]); else&#123; int index = findFirstLargeEqual(dp,nums[i]); dp.set(index,nums[i]);// 用指定的元素替代此列表中指定位置上的元素。 &#125; &#125; return dp.size(); &#125; public int findFirstLargeEqual(ArrayList&lt;Integer&gt; list,int num)&#123; int left = 0; int right = list.size() - 1; while(left &lt;=right)&#123; int mid = (left + right)/2; if(list.get(mid) &gt; num) right = mid -1; else if(list.get(mid) &lt; num) left = mid + 1; else return mid; &#125; return left; &#125;&#125; Python代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950def longestIncreasingSubsequence(nums): if nums == None or len(nums) == 0: return 0 testarray = list() for i in range(len(nums)): # 如果是第一个位置就直接添加进新的列表里面，如果后一个元素比新列表的最后一个元素大或者等于，则添加该元素到新列表末尾 if len(testarray) == 0 or nums[i] &gt;= testarray[len(testarray) - 1]: testarray.append(nums[i]) else: # 如果这个新元素不大于等于最后一个元素的时候，利用二分查找找到他在新列表中应该插入的位置 index = findFirstLargeEqual(testarray, nums[i]) # 将新元素替换对应位置的列表里面的元素 testarray[index] = nums[i] return len(testarray)# 利用二分查找法def findFirstLargeEqual(testarray, target): left = 0 right = len(testarray) - 1 if testarray[0] == target: return 0 while left &lt;= right: # 双斜杠整除 mid = (left + right) // 2 if testarray[mid] &gt; target: right = mid - 1 elif testarray[mid] &lt; target: left = mid + 1 else: return mid return leftif __name__ == "__main__": a = list() # 输入n m n, m = input().split() # 输入采样点 n = int(n) a = input().split() # 截取输入的前n个（控制输入） a = a[:n] # 全部转化为整形 for i in range(n): a[i] = int(a[i]) # 按照小时数重复 a = a * int(m) count = longestIncreasingSubsequence(a) print(count) 运行结果1234 310 3 7 54]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>算法</tag>
        <tag>Java</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划问题——最长上升子序列(LIS)(一)]]></title>
    <url>%2F2018%2F08%2F25%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97(LIS)(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[推荐链接： 动态规划问题——最长上升子序列(LIS)(二) 动态规划问题——最长上升子序列(LIS)(三) 如：求 2 7 1 5 6 4 3 8 9 的最长上升子序列。我们定义d(i) (i∈[1,n])来表示前i个数以A[i]结尾的最长上升子序列长度。 前1个数 d(1)=1 子序列为2； 前2个数 7前面有2小于7 d(2)=d(1)+1=2 子序列为2 7 前3个数 在1前面没有比1更小的，1自身组成长度为1的子序列 d(3)=1 子序列为1 前4个数 5前面有2小于5 d(4)=d(1)+1=2 子序列为2 5 前5个数 6前面有2 5小于6 d(5)=d(4)+1=3 子序列为2 5 6 前6个数 4前面有2小于4 d(6)=d(1)+1=2 子序列为2 4 前7个数 3前面有2小于3 d(3)=d(1)+1=2 子序列为2 3 前8个数 8前面有2 5 6小于8 d(8)=d(5)+1=4 子序列为2 5 6 8 前9个数 9前面有2 5 6 8小于9 d(9)=d(8)+1=5 子序列为2 5 6 8 9 d(i)=max{d(1),d(2),……,d(i)} 我们可以看出这9个数的LIS为d(9)=5 Java代码1234567891011121314151617181920212223242526272829public class Main &#123; int LIS(int A[], int n) &#123; int d[] = new int[n]; int len = 1; int i, j; for (i = 0; i &lt; n; i++) &#123; d[i] = 1; for (j = 0; j &lt; i; j++) &#123; // 当前的位置的数与之前的数比较，如果数列是上升的，且序列长度+1比当前序列长度大或相等 if (A[j] &lt;= A[i] &amp;&amp; (d[j] + 1) &gt;= d[i]) //使这个数之前的最大长度加1（最长上升序列加上这个数） d[i] = d[j] + 1; &#125; // 把当前d[i]的最大长度赋值给len if (d[i] &gt; len) len = d[i]; &#125; // 返回最长上升子序列的长度 return len; &#125; public static void main(String[] args) &#123; int A[] = &#123;2, 7, 1, 5, 6, 4, 3, 8, 9&#125;; int n = A.length; Main test = new Main(); int count = test.LIS(A, n); System.out.println(count); &#125;&#125; 运行结果15 Python代码1234567891011121314151617181920212223242526272829303132333435363738394041# 第一种写法def longestIncreasingSubsequence(nums, length): # 如果列表为空或者列表长度为0就直接返回0 if nums == None or len(nums) == 0: return 0 # 初始化列表为length个0，用来记录到当前位置的最长升序序列的长度 sublongest = [0 for i in range(length)] sublongest[0] = 1 longest = 0 for i in range(1, length): sublong = 0 for j in range(0, i): # 如果当前元素比前面的元素大 if nums[j] &lt;= nums[i]: # 则将前面元素的最长序列和当前的最长序列比较大小，把大的赋值给sublong sublong = max(sublongest[j], sublong) # 加上到自身位置那个元素 sublongest[i] = sublong + 1 # 比较长度列表末尾的元素和longest的大小，把两者大的赋值给longest longest = max(sublongest[i], longest) return longest# 第二种写法def longestIncreasingSubsequence2(Testarray, num): d = [0 for i in range(num)] longest = 1 for i in range(num): d[i] = 1 for j in range(i): if (Testarray[j] &lt;= Testarray[i]) and (d[j] + 1) &gt;= d[i]: d[i] = d[j] + 1 if d[i] &gt; longest: longest = d[i] return longestif '__name__ = __main__': a = [2, 7, 1, 5, 6, 4, 3, 8, 9] # count = longestIncreasingSubsequence(a,len(a)) count = longestIncreasingSubsequence2(a, len(a)) print(count) 运行结果15]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>算法</tag>
        <tag>Java</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一个使用Tensorflow的程序]]></title>
    <url>%2F2018%2F08%2F24%2F%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%BD%BF%E7%94%A8Tensorflow%E7%9A%84%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[构建图构建图的第一步, 是创建源 op (source op). 源 op 不需要任何输入, 例如 常量 (Constant). 源 op 的输出被传递给其它 op 做运算. Python 库中, op 构造器的返回值代表被构造出的 op 的输出, 这些返回值可以传递给其它 op 构造器作为输入. TensorFlow Python 库有一个默认图 (default graph), op 构造器可以为其增加节点 默认图现在有三个节点, 两个 constant() op, 和一个matmul() op. 为了真正进行矩阵相乘运算, 并得到矩阵乘法的 结果, 你必须在会话里启动这个图. 在一个会话中启动图构造阶段完成后, 才能启动图. 启动图的第一步是创建一个 Session 对象, 如果无任何创建参数, 会话构造器将启动默认图. 代码123456789101112131415161718192021222324252627282930313233343536import tensorflow as tf# op称为图的节点# 创建一个常量op，产生一个1x2矩阵，这个op被作为一个节点# 加到默认图中# 构造器的返回值代表该常量op的返回值matrix1 = tf.constant([[3., 3.]])# 创建另一个常量op，产生一个 2x1矩阵matrix2 = tf.constant([[2.], [2.]])# 创建一个矩阵乘法 matmul op , 把 'matrix1' 和 'matrix2' 作为输入.# 返回值 'product' 代表矩阵乘法的结果.'''默认图现在有三个节点, 两个 constant() op, 和一个matmul() op. 为了真正进行矩阵相乘运算, 并得到矩阵乘法的 结果, 你必须在会话里启动这个图.'''product = tf.matmul(matrix1, matrix2)# 启动默认图.sess = tf.Session()# 调用 sess 的 'run()' 方法来执行矩阵乘法 op, 传入 'product' 作为该方法的参数.# 上面提到, 'product' 代表了矩阵乘法 op 的输出, 传入它是向方法表明, 我们希望取回# 矩阵乘法 op 的输出.## 整个执行过程是自动化的, 会话负责传递 op 所需的全部输入. op 通常是并发执行的.## 函数调用 'run(product)' 触发了图中三个 op (两个常量 op 和一个矩阵乘法 op) 的执行.## 返回值 'result' 是一个 numpy `ndarray` 对象.result = sess.run(product)print(result)# ==&gt; [[ 12.]]# 任务完成, 关闭会话.sess.close() 运行结果1[[12.]]]]></content>
      <categories>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>机器学习</tag>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Numpy中的数组维度]]></title>
    <url>%2F2018%2F08%2F22%2FNumpy%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E7%BB%B4%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[在对 np.arange(24)(0, 1, 2, 3, …, 23) 进行重新的排列时，在多维数组的多个轴的方向上，先分配最后一个轴（对于二维数组，即先分配行的方向，对于三维数组即先分配平面的方向） 代码123456789101112131415import numpy as np# 一维数组a = np.arange(24)print("a的维度:\n",a.ndim)# 现在调整其大小,2行3列4个平面b = np.reshape(np.arange(24), (2, 3, 4))# b 现在拥有三个维度print("b(也是三维数组):\n",b)# 分别看看每一个平面的构成print("b的每一个平面的构成：\n")print(b[:, :, 0])print(b[:, :, 1])print(b[:, :, 2])print(b[:, :, 3]) 运行结果1234567891011121314151617181920a的维度: 1b(也是三维数组): [[[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] [[12 13 14 15] [16 17 18 19] [20 21 22 23]]]b的每一个平面的构成：[[ 0 4 8] [12 16 20]][[ 1 5 9] [13 17 21]][[ 2 6 10] [14 18 22]][[ 3 7 11] [15 19 23]]]]></content>
      <categories>
        <category>Numpy</category>
      </categories>
      <tags>
        <tag>Numpy</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ndarray对象]]></title>
    <url>%2F2018%2F08%2F22%2FNdarray%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[NumPy 中定义的最重要的对象是称为 ndarray 的 N 维数组类型。 它描述相同类型的元素集合。 可以使用基于零的索引访问集合中的项目。ndarray 中的每个元素在内存中使用相同大小的块。基本的 ndarray 是使用 NumPy 中的数组函数创建的，如：numpy.array 它从任何暴露数组接口的对象，或从返回数组的任何方法创建一个ndarray。 numpy.array(object,dtype=None,copy=True,order=None,subok=False,ndmin=0 上面的构造器接受以下参数： 序号 参数及描述 1. object 任何暴露数组接口方法的对象都会返回一个数组或任何（嵌套）序列。 2. dtype 数组的所需数据类型，可选。 3. copy 可选，默认为true，对象是否被复制。 4. order C（按行）、F（按列）或A（任意，默认）。 5. subok 默认情况下，返回的数组被强制为基类数组。 如果为true，则返回子类。 6. ndimin 指定返回数组的最小维数。 代码1234567891011121314151617import numpy as npa = np.array([1,2,3])print(a,"\n")# 当维度比一维高时b = np.array([[1,2],[3,4]])print(b,"\n")# zeros(shape)将创建一个用指定形状用0填充的数组print(np.zeros((2,3)),"\n")# ones(shape)将创建一个用1填充的数组print(np.ones((3,3)),"\n")# 最小维度c = np.array([1,2,3,4,5],ndmin=2)print(c,"\n")# dtype参数a = np.array([1,2,3],dtype=complex)print(a,"\n") 运行结果123456789101112131415[1 2 3] [[1 2] [3 4]] [[0. 0. 0.] [0. 0. 0.]] [[1. 1. 1.] [1. 1. 1.] [1. 1. 1.]] [[1 2 3 4 5]] [1.+0.j 2.+0.j 3.+0.j]]]></content>
      <categories>
        <category>Numpy</category>
      </categories>
      <tags>
        <tag>Numpy</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型和arange方法、astype方法的使用]]></title>
    <url>%2F2018%2F08%2F22%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8Carange%E6%96%B9%E6%B3%95_astype%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Numpy支持比Python更多的数字类型 数据类型 描述 bool_ 布尔（True或False），存储为一个字节 int_ 默认整数类型（与Clong相同；通常是int64或int32） INTC 与Cint（通常为int32或int64）相同 INTP 用于索引的整数（与Cssize_t相同；通常是int32或int64） INT8 字节（-128至127） INT16 整数（-32768至32767） INT32 整数（-2147483648至2147483647） Int64的 整数（-9223372036854775808至9223372036854775807） UINT8 无符号整数（0到255） UINT16 无符号整数（0到65535） UINT32 无符号整数（0到4294967295） UINT64 无符号整数（0到18446744073709551615） float_ float64的简写。 float16 半精度浮点：符号位，5位指数，10位尾数 FLOAT32 单精度浮点数：符号位，8位指数，23位尾数 float64 双精度浮点：符号位，11位指数，52位尾数 complex_ complex128的简写。 complex64 复数，由两个32位浮点数（实部和虚部） complex128 复数，由两个64位浮点数（实部和虚部） 除了intc之外，还定义了平台相关的C整数类型short，long，longlong。 arange函数用于创建等差数组，使用频率非常高，arange非常类似range函数 ,两者的区别仅仅是arange返回的是一个数据，而range返回的是list 。要转换数组的类型，请使用.astype()方法（首选）或类型本身作为函数 代码12345678910111213141516171819import numpy as npz = np.arange(5)print(z)print(z.dtype)print(50*'*')# 转化数据类型为float64floar_arr = z.astype(np.float64)print(floar_arr)print(floar_arr.dtype)print(50*'*')# 如果将浮点数转换为整数，则小数部分会被截断z2 = np.array([5.1,9.2,8.3,7.4,3.3214])print(z2)print(z2.astype(np.int32))print(50*'*')# arange的用法print(np.arange(1, 5))print(np.arange(0, 10, 2)) 运行结果1234567891011[0 1 2 3 4]int32**************************************************[0. 1. 2. 3. 4.]float64**************************************************[5.1 9.2 8.3 7.4 3.3214][5 9 8 7 3]**************************************************[1 2 3 4][0 2 4 6 8]]]></content>
      <categories>
        <category>Numpy</category>
      </categories>
      <tags>
        <tag>Numpy</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Numpy中花式索引和shape用法]]></title>
    <url>%2F2018%2F08%2F20%2FNumpy%E4%B8%AD%E8%8A%B1%E5%BC%8F%E7%B4%A2%E5%BC%95%E5%92%8Cshape%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[总结一下最近学习中容易出现问题的地方❗️ ❗️ ❗️ 代码1234567891011from numpy import *randMat = random.randint(0, 10, (4, 3))print("原矩阵:\n", randMat)# 索引从0开始计数print("输出第一行的所有数据:\n", randMat[0, :])print("输出第二列的所有数据:\n", randMat[:, 1])print("输出矩阵第1和第3行的所有数据:\n", randMat[[0, 2], :])print("行数:\n",randMat.shape[0])print("列数:\n",randMat.shape[1])print("维数:\n",randMat.shape) 运行结果123456789101112131415161718原矩阵: [[3 5 1] [1 3 0] [0 2 1] [0 2 9]]输出第一行的所有数据: [3 5 1]输出第二列的所有数据: [5 3 2 2]输出矩阵第1和第3行的所有数据: [[3 5 1] [0 2 1]]行数: 4列数: 3维数: (4, 3) 2018年8月22日 21:40:54更新，新增：使用shape和reshape调整数组大小 代码123456import numpy as npa = np.array([[1,2,3],[4,5,6]]) a.shape = (3,2)b = a.reshape(2,3)print(a)print(b) 运行结果12345[[1 2] [3 4] [5 6]][[1 2 3] [4 5 6]]]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Numpy</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kNN识别手写图像]]></title>
    <url>%2F2018%2F08%2F16%2FkNN%E8%AF%86%E5%88%AB%E6%89%8B%E5%86%99%E5%9B%BE%E5%83%8F%2F</url>
    <content type="text"><![CDATA[示例 ：使用k-近邻算法的手写识别系统(1) 收集数据：提供文本文件。(2) 准备数据：编写函数classify0(), 将图像格式转换为分类器使用的list格式。(3) 分析数据：检查数据，确保它符合要求。(4) 训练算法：此步驟不适用于k-近邻算法。(5) 测试算法：编写函数使用提供的部分数据集作为测试样本，测试样本与非测试样本的区别在于测试样本是已经完成分类的数据，如果预测分类与实际类别不同，则标记为一个错误。(6) 使用算法：本例没有完成此步骤，若你感兴趣可以构建完整的应用程序，从图像中提取数字，并完成数字识别，美国的邮件分拣系统就是一个实际运行的类似系统。 注：由于原本数据集已经在0和1之间，所以不需要转化数字特征值。[数据集](http://pd10tty87.bkt.clouddn.com/knn%E8%AF%86%E5%88%AB%E6%89%8B%E5%86%99%E5%9B%BE%E5%83%8F.zip) 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586from numpy import *from os import listdirimport operatordef classify0(inX, dataSet, labels, k): dataSetSize = dataSet.shape[0] # 距离计算 ''' tile(A，rep) 功能：重复A的各个维度 参数类型： A: Array类的都可以 rep：A沿着各个维度重复的次数 ''' diffMat = tile(inX, (dataSetSize, 1)) - dataSet sqDiffMat = diffMat ** 2 # numpy中的 axis=0表示列,向下，axis=1表示行，向右 # 在平时使用的sun默认的是axis=0就是普通的相加，当加入axis=1以后就是将一个矩阵的每一行向量相加 sqDistances = sqDiffMat.sum(axis=1) distances = sqDistances ** 0.5 # argsort函数返回的是数组值从小到大的索引值 sortedDistIndicies = distances.argsort() classCount = &#123;&#125; # 选择距离最小的k个点 for i in range(k): votellabel = labels[sortedDistIndicies[i]] classCount[votellabel] = classCount.get(votellabel, 0) + 1 # 排序 sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse=True) return sortedClassCount[0][0]def img2vector(filename): # 将图像矩阵转化为1x1024的向量 returnVect = zeros((1, 1024)) fr = open(filename) # 循环读出文件的前32行 for i in range(32): lineStr = fr.readline() # 将每行的头32个字符值存储在Numpy数组中 for j in range(32): returnVect[0, 32 * i + j] = int(lineStr[j]) # 返回数组 return returnVectdef handwritingClassTest(): hwLabels = [] # 获取训练数据集下目录的所有文件名的列表 trainingFileList = listdir('trainingDigits') # 得到文件数量 m = len(trainingFileList) # 创建m行1024列的训练矩阵 trainingMat = zeros((m, 1024)) for i in range(m): # 从文件名解析分类数字 # 解析出0_10.txt fileNameStr = trainingFileList[i] # 获得0_10 fileStr = fileNameStr.split('.')[0] # 获得0 classNumStr = int(fileStr.split('_')[0]) hwLabels.append(classNumStr) trainingMat[i, :] = img2vector('trainingDigits/%s' % fileNameStr) # 获得测试数据集下目录的所有文件名的列表 testFileList = listdir('testDigits') errorCount = 0.0 mTest = len(testFileList) for i in range(mTest): fileNameStr = testFileList[i] fileStr = fileNameStr.split('.')[0] classNumStr = int(fileStr.split('_')[0]) vectorUnderTest = img2vector('testDigits/%s' % fileNameStr) classifierResult = classify0(vectorUnderTest, trainingMat, hwLabels, 3) print("the classifier came back with:%d,the real answer is:%d" % (classifierResult, classNumStr)) if (classifierResult != classNumStr): errorCount += 1.0 print("\nthe total number of errors is:%d" % errorCount) print("\nthe total error rate is :%f" % (errorCount / float(mTest)))testVector = img2vector('testDigits/0_13.txt')# X[:, m:n]，即取二维数组中的第m到n-1列的所有数据print("测试输出:\n", testVector[0, 0:31])handwritingClassTest() 运行结果12345678910111213141516171819the classifier came back with:1,the real answer is:1the classifier came back with:1,the real answer is:1.....the classifier came back with:5,the real answer is:5the classifier came back with:5,the real answer is:5the classifier came back with:6,the real answer is:6the classifier came back with:6,the real answer is:6....the classifier came back with:9,the real answer is:9the classifier came back with:9,the real answer is:9the classifier came back with:9,the real answer is:9the total number of errors is:11# 错误率为1.2%the total error rate is :0.011628]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Numpy</tag>
        <tag>python</tag>
        <tag>机器学习</tag>
        <tag>k-近邻算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用k-近邻算法改进约会网站的配对效果]]></title>
    <url>%2F2018%2F08%2F11%2F%E4%BD%BF%E7%94%A8k-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%E6%94%B9%E8%BF%9B%E7%BA%A6%E4%BC%9A%E7%BD%91%E7%AB%99%E7%9A%84%E9%85%8D%E5%AF%B9%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[***实例：在约会网站上使用k-近邻算法*** (1) 收集数据：提供文本文件。(2) 准备数据 : 使用python解析文本文件。(3) 分析数据 使用 Matplotlib画二维扩散图 。(4) 训练算法：此步驟不适用于k-近邻算法。(5) 测试算法：使用海伦提供的部分数据作为测试样本。测试样本和非测试样本的区别在于：测试样本是已经完成分类的数据，如果预测分类与实际类别不同，则标记为一个错误。(6) 使用算法：产生简单的命令行程序，然后可以输入一些特征数据以判断对方是否为自己喜欢的类型。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172from numpy import *import operatorimport matplotlibimport matplotlib.pyplot as pltdef createDateSet(): group = array([[1.0, 1.1], [1.0, 1.0], [0, 0], [0, 0.1]]) labels = ['A', 'A', 'B', 'B'] return group, labels''' 用于分类的输人向量是inX， 输入的训练样本集为dataSet, 标签向量为labels 最后的参数k表示用于选择最近邻居的数目， 其中标签向量的元素数目和矩阵dataSet的行数相同'''def classify0(inX, dataSet, labels, k): dataSetSize = dataSet.shape[0] # 距离计算 diffMat = tile(inX, (dataSetSize, 1)) - dataSet sqDiffMat = diffMat ** 2 sqDistances = sqDiffMat.sum(axis=1) distances = sqDistances ** 0.5 sortedDistIndicies = distances.argsort() classCount = &#123;&#125; # 选择距离最小的k个点 for i in range(k): votellabel = labels[sortedDistIndicies[i]] classCount[votellabel] = classCount.get(votellabel, 0) + 1 # 排序 sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse=True) return sortedClassCount[0][0]# 将文本记录转换到Numpy的解析程序def file2matrix(filename): fr = open(filename) arrayOLines = fr.readlines() # 得到文件行数 numberOfLines = len(arrayOLines) # 创建返回的Numpy矩阵，将该矩阵的另一维度设置为3 returnMat = zeros((numberOfLines, 3)) classLabelVector = [] index = 0 # 解析文件数据到列表，循环处理每行数据 for line in arrayOLines: # 截取掉所有的回车字符 line = line.strip() # 使用tab字符\t将上一步得到的整行数据分割成一个元素列表 listFromLine = line.split('\t') # 选取前3个元素，将他们存储到特征矩阵中 returnMat[index, :] = listFromLine[0:3] # -1表示列表中的最后一列元素，将最后一列元素存储到向量classLabelVector中 classLabelVector.append(int(listFromLine[-1])) index += 1 return returnMat, classLabelVectordatingDataMat, datingLabels = file2matrix('datingTestSet2.txt')print("array:\n", datingDataMat)print("datingLabels[0:20]\n", datingLabels[0:20])# 绘制散点图# 定义figurefig = plt.figure()#add_subplot()返回一个axes对象，里面的参数abc表示在一个figure窗口中，有a行b列个小窗口，然后本次plot在第c个窗口中。ax = fig.add_subplot(111)# 设置颜色和散点图数据ax.scatter(datingDataMat[:, 1], datingDataMat[:, 2], 15.0 * array(datingLabels), 15.0 * array(datingLabels))plt.show() [数据集](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/datingTestSet.txt) 运行结果12345678910array: [[ 4.09200000e+04 8.32697600e+00 9.53952000e-01] [ 1.44880000e+04 7.15346900e+00 1.67390400e+00] [ 2.60520000e+04 1.44187100e+00 8.05124000e-01] ..., [ 2.65750000e+04 1.06501020e+01 8.66627000e-01] [ 4.81110000e+04 9.13452800e+00 7.28045000e-01] [ 4.37570000e+04 7.88260100e+00 1.33244600e+00]]datingLabels[0:20] [3, 2, 1, 1, 1, 1, 3, 3, 1, 3, 1, 1, 2, 1, 1, 1, 1, 1, 2, 3] 散点图结果： 2018年8月11日 16:49:36 新增：归一化特征值，测试代码，预测代码 因为在欧氏距离中数值差值最大的属性对计算结果的影响最大，但其实多个特征都是同等重要的属性，这样如果其中一个占的权重过大，会严重影响到计算的结果 所以在处理不同取值范围的特征值的时候，我们通常采用的方法是将数值归一化，如将取值范围处理为0到1或者-1到1之间。 公式：newValue = （oldValue - min）/（max - min） 其中min和max分别是数据集中的最小特征值和最大特征值。虽然改变数值取值范围增加了分类器的复杂度，但为了得到准确的结果，这样做是必然的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# 将数字特征值转化为0到1的区间def autoNorm(dataSet): # 将每列的最小值放在变量minVals中，dataSet.min(0)中的参数0使得函数可以从列中选取最小值 minVals = dataSet.min(0) # 将每列的最大值放在变量maxVals中 maxVals = dataSet.max(0) ranges = maxVals - minVals normDataSet = zeros(shape(dataSet)) m = dataSet.shape[0] # 为了归一化特征值，必须使用当前值减去最小值，然后除以取值范围 # tile()函数将变量内容复制成输入矩阵同样大小的矩阵 normDataSet = dataSet - tile(minVals, (m, 1)) # 特征值相除 normDataSet = normDataSet / tile(ranges, (m, 1)) return normDataSet, ranges, minVals# 分类器针对约会网站的测试代码def datingClassTest(): hoRatio = 0.10 # 首先使用file2matrix和autoNorm()函数从文件中读取数据并将其转换为归一化特征值 datingDataMat, datingLabels = file2matrix('datingTestSet2.txt') normMat, ranges, minVals = autoNorm(datingDataMat) # 计算测试向量的数量，决定normMat向量中哪些数据用于测试，哪些数据用于分类器的训练样本 m = normMat.shape[0] numTestVecs = int(m * hoRatio) errorCount = 0.0 # 将两部分数据输入到原始分类器函数classify0 for i in range(numTestVecs): classifierResult = classify0(normMat[i, :], normMat[numTestVecs:m, :], \ datingLabels[numTestVecs:m], 3) print("the classifier came back with:&#123;&#125;,the real answer is:&#123;&#125;".format(classifierResult, datingLabels[i])) if (classifierResult != datingLabels[i]): errorCount += 1.0 # 计算错误率并输出结果 print("the total error rate is:&#123;&#125;".format(errorCount / float(numTestVecs)))# 约会网站预测函数def classifyPerson(): resultList = ['not at all', 'in small doses', 'in large doses'] percentTats = float(input( \ "percentage of time spent playing video games?")) ffMiles = float(input("frequent flier miles earned per year?")) iceCream = float(input("liters of ice cream consumed per year?")) datingDataMat, datingLabels = file2matrix('datingTestSet2.txt') normMat, ranges, minVals = autoNorm(datingDataMat) inArr = array([ffMiles, percentTats, iceCream]) classifierResult = classify0((inArr - \ minVals) / ranges, normMat, datingLabels, 3) print("You will probably like this person:", \ resultList[classifierResult - 1]) 测试归一化特征值、分类器、选择喜欢的人： 123456789# 测试归一化特征值normMat, ranges, minVals = autoNorm(datingDataMat)print("array:\n", normMat)print("array:", ranges)print("array:", minVals)# 测试分类器datingClassTest()# 选择喜欢的人classifyPerson() 运行结果123456789101112131415161718192021222324252627# normMatarray: [[ 0.44832535 0.39805139 0.56233353] [ 0.15873259 0.34195467 0.98724416] [ 0.28542943 0.06892523 0.47449629] ..., [ 0.29115949 0.50910294 0.51079493] [ 0.52711097 0.43665451 0.4290048 ] [ 0.47940793 0.3768091 0.78571804]]# rangesarray: [ 9.12730000e+04 2.09193490e+01 1.69436100e+00]# minValsarray: [ 0. 0. 0.001156]# 测试分类器(数据太多了这里截取部分)the classifier came back with:3,the real answer is:3the classifier came back with:2,the real answer is:2......the classifier came back with:2,the real answer is:2the classifier came back with:1,the real answer is:1the classifier came back with:3,the real answer is:1# 分类器处理约会数据集的错误率为5%（书上为2.4%....不知道怎么回事）the total error rate is:0.05# 输入各个属性，得到最佳约会伙伴percentage of time spent playing video games?10frequent flier miles earned per year?10000liters of ice cream consumed per year?0.5You will probably like this person: in small doses]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>机器学习</tag>
        <tag>k-近邻算法</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kNN（k-近邻算法）]]></title>
    <url>%2F2018%2F08%2F09%2FkNN%EF%BC%88k-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[k-近邻算法（kNN），它的工作原理是：存在一个样本数据集合，也称作训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每一数据与所属分类的对应关系。输人没有标签的新数据后，将新数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本集中特征最相似数据（最近邻）的分类标签。一般来说，我们只选择样本数据集中前 k个最相似的数据，这就是 k- 近邻算法中k的出处 , 通常k是不大于 20 的整数。最后，选择k个最相似数据中出现次数最多的分类，作为新数据的分类。 ***k-近邻算法的一般流程*** 收集数据：可以使用任何方法。 准备数据：距离计算所需要的数值，最好是结构化的数据格式。 分析数据：可以使用任何方法。 训练算法：此步驟不适用于k-近邻算法。 测试算法：计算错误率。 使用算法：首先需要输入样本数据和结构化的输出结果，然后运行k-近邻算法判定输入数据分别属于哪个分类，最后应用对计算出的分类执行后续的处理。 使用欧氏距离公式，计算两个向量点xA和xB之间的距离： 例如，点 (0 ,0) 与 (1, 2) 之间的距离计算为： 如果数据集存在 4 个特征值，则点 (1 ,0, 0 ,1) 与 (7, 6, 9 ,4) 之间的距离计算为: 计算完所有点之间的距离后，可以对数据按照从小到大的次序排序。然后，确定前 k 个距离最小元素所在的主要分类 , 输人k总是正整数；最后，将classCount字典分解为元组列表，然后使用程序第二行导入运算符模块的itemgetter方法 ,按照第二个元素的次序对元组进行排序。此处的排序为逆序，即按照从最大到最小次序排序，最后返回发生频率最高的元素标签。 代码123456789101112131415161718192021222324252627282930313233343536373839from numpy import *import operatordef createDateSet(): group = array([[1.0, 1.1], [1.0, 1.0], [0, 0], [0, 0.1]]) labels = ['A', 'A', 'B', 'B'] return group, labels''' 用于分类的输人向量是inX， 输入的训练样本集为dataSet, 标签向量为labels 最后的参数k表示用于选择最近邻居的数目， 其中标签向量的元素数目和矩阵dataSet的行数相同'''def classify0(inX, dataSet, labels, k): dataSetSize = dataSet.shape[0] # 距离计算 diffMat = tile(inX, (dataSetSize, 1)) - dataSet sqDiffMat = diffMat ** 2 sqDistances = sqDiffMat.sum(axis=1) distances = sqDistances ** 0.5 sortedDistIndicies = distances.argsort() classCount = &#123;&#125; # 选择距离最小的k个点 for i in range(k): votellabel = labels[sortedDistIndicies[i]] classCount[votellabel] = classCount.get(votellabel, 0) + 1 # 排序 sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse=True) return sortedClassCount[0][0]group, labels = createDateSet()print(classify0([1.0, 1.1], group, labels, 3)) 运行结果1A]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>机器学习</tag>
        <tag>k-近邻算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Numpy库的首次使用]]></title>
    <url>%2F2018%2F08%2F09%2FNumpy%E5%BA%93%E7%9A%84%E9%A6%96%E6%AC%A1%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在pycharm中的setting安装numpy，或者在cmd里面通过pip install方法安装均可 代码12345678910111213141516from numpy import *# 构造一个4x4的随机数组print("数组:\n",random.rand(4, 4))# 调用mat()函数将数组转化为矩阵randMat = mat(random.rand(4, 4))# .I操作符实现了矩阵求逆的运算print("矩阵求逆:\n",randMat.I)# 矩阵乘以逆矩阵invRandMat = randMat.Iprint("矩阵乘以逆矩阵:\n",randMat*invRandMat)# 函数eye(4)创建一个4x4的单位矩阵，下面是算误差myEye = randMat*invRandMatprint("计算误差:\n",myEye-eye(4)) 运行结果1234567891011121314151617181920数组: [[ 0.46089523 0.94167701 0.76910005 0.96892095] [ 0.38894192 0.88828275 0.28144475 0.91774255] [ 0.13997437 0.7435124 0.89709322 0.68924161] [ 0.41461243 0.19911356 0.64856312 0.49160523]]矩阵求逆: [[-0.45014095 1.92871242 0.28217777 -0.76959459] [ 1.09829851 -0.9829715 -1.78955478 2.70643663] [ 0.95057662 -1.40675696 0.67345673 -0.70029109] [-1.11436955 -0.35496085 1.88297962 -0.76459429]]矩阵乘以逆矩阵: [[ 1.00000000e+00 7.20736257e-17 -3.04329603e-17 -1.66886258e-17] [ -2.27212878e-16 1.00000000e+00 2.93001892e-17 -1.63043911e-16] [ 8.73583235e-18 -3.06881469e-17 1.00000000e+00 -3.50839733e-17] [ -4.04804848e-17 1.45085950e-16 -1.23671214e-16 1.00000000e+00]]计算误差: [[ -1.11022302e-16 7.20736257e-17 -3.04329603e-17 -1.66886258e-17] [ -2.27212878e-16 2.22044605e-16 2.93001892e-17 -1.63043911e-16] [ 8.73583235e-18 -3.06881469e-17 -2.22044605e-16 -3.50839733e-17] [ -4.04804848e-17 1.45085950e-16 -1.23671214e-16 2.22044605e-16]]]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Numpy</tag>
        <tag>机器学习</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例设计模式]]></title>
    <url>%2F2018%2F08%2F08%2F%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[需要全局的对象唯一的时候，使用单例设计模式，几乎是最简单的设计模式……​ ​ ，以下是代码部分 代码12345678910111213141516171819202122232425262728293031323334# object写不写都可以，在python3.X中已经默认继承了，以前区别旧式类和新式类# 单例设计模式class MusicPlayer(object): # 记录第一个被创建对象的引用 instance = None # 记录是否执行过初始化方法 init_flag = False def __new__(cls, *args, **kwargs): # 1. 判断类属性是否是空对象 if cls.instance is None: # 2. 调用父类的方法，为第一个对象分配空间 cls.instance = super().__new__(cls) # 3. 返回类属性保存的对象引用 return cls.instance # 让初始化方法只执行一次 def __init__(self): # 1. 判断是否执行过初始化动作 if MusicPlayer.init_flag: return # 2. 如果没有执行过，执行初始化动作 print("111111111") # 3. 修改类属性的标记 MusicPlayer.init_flag = True# 创建多个对象player1 = MusicPlayer()print(player1)player2 = MusicPlayer()print(player2) 运行结果123111111111&lt;__main__.MusicPlayer object at 0x000000000342D0B8&gt;&lt;__main__.MusicPlayer object at 0x000000000342D0B8&gt; 可以看出2次对象的创建在内存上实际是一个地址]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的__new__方法的重写]]></title>
    <url>%2F2018%2F08%2F08%2Fpython%E4%B8%AD%E7%9A%84__new__%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99%2F</url>
    <content type="text"><![CDATA[new方法重写的步骤比较固定，直接上代码吧 代码123456789101112131415161718class MusicPlayer(object): # new方法的重写，是一个静态方法，必须主动传递cls参数 def __new__(cls, *args, **kwargs): # 1.创建对象时，new方法会被自动调用 print(&quot;创建对象，分配空间&quot;) # 2.为对象分配空间 instance = super().__new__(cls) # 3.返回对象的引用 return instance def __init__(self): print(&quot;111&quot;)player = MusicPlayer()print(player) 运行结果123创建对象，分配空间111&lt;__main__.MusicPlayer object at 0x0000000003A0D128&gt;]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的静态方法、实例方法、类方法的区别]]></title>
    <url>%2F2018%2F08%2F08%2Fpython%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E3%80%81%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E3%80%81%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[实例方法 ​ 定义：第一个参数必须是实例对象，该参数名一般约定为“self”，通过它来传递实例的属性和方法（也可以传类的属性和方法）； ​ 调用：只能由实例对象调用。 类方法 ​ 定义：使用装饰器@classmethod。第一个参数必须是当前类对象，该参数名一般约定为“cls”，通过它来传递类的属性和方法（不能传实例的属性和方法）； ​ 调用：实例对象和类对象都可以调用。 静态方法 ​ 定义：使用装饰器@staticmethod。参数随意，没有“self”和“cls”参数，但是方法体中不能使用类或实例的任何属性和方法； ​ 调用：实例对象和类对象都可以调用。 代码12345678910111213141516171819202122232425262728293031323334353637import timeclass Tool(object): count = 0 def __init__(self, name): self.name = name Tool.count += 1 # 定义一个实例方法，有self参数 def action(self): print("挥动&#123;&#125;".format(self.name)) # 定义一个类方法，有cls参数 @classmethod def shou_tool_count(cls): print("工具对象的数量&#123;&#125;".format(cls.count)) # 定义一个静态方法，初始没有任何参数 @staticmethod def showTime(): print(time.strftime("%H:%M:%S", time.localtime()))# 创建工具对象tool = Tool("斧头")too2 = Tool("榔头")# 调用类方法,逻辑上类方法一般由类自身调用，其实实例对象和类对象都可以调用Tool.shou_tool_count()# 调用实例方法,只能由实例对象调用tool.action()# 调用静态方法,实例对象和类对象均可调用too2.showTime()Tool.showTime() 运行结果1234工具对象的数量2挥动斧头20:30:4620:30:46]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的多态]]></title>
    <url>%2F2018%2F08%2F08%2Fpython%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[当子类和父类都存在相同的 game()方法时，子类的 game() 覆盖了父类的 game()，在代码运行时，会调用子类的 game()。 这样，我们就获得了继承的另一个好处：多态。 多态的好处就是，当我们需要传入更多的子类，例如新增 XX Dog、YY Dog 等时，我们只需要继承 Dog 类型就可以了，而game()方法既可以直不重写（即使用Dog的），也可以重写一个特有的。这就是多态的意思。调用方只管调用，不管细节，而当我们新增一种Dog的子类时，只要确保新方法编写正确，而不用管原来的代码。这就是著名的“开闭”原则： 对扩展开放（Open for extension）：允许子类重写方法函数 对修改封闭（Closed for modification）：不重写，直接继承父类方法函数 代码1234567891011121314151617181920212223242526272829303132333435class Dog(object): def __init__(self, name): self.name = name def game(self): print("&#123;&#125;跳".format(self.name))class XiaoTianDog(Dog): # 方法重写 def game(self): print("&#123;&#125;飞".format(self.name))class Person(object): def __init__(self, name): self.name = name def game_with_dog(self, dog): print("&#123;&#125;和&#123;&#125;玩耍".format(self.name, dog.name))# 创建Dog对象Peter = Dog("皮特")# 创建XiaoTianDog对象wangcai = XiaoTianDog("旺财")# 调用Dog里面的game方法Peter.game()# 调用XiaoTianDog里面的game方法wangcai.game()xiaoming = Person("小明")xiaoming.game_with_dog(wangcai) 运行结果123皮特跳旺财飞小明和旺财玩耍]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[turtle绘图库]]></title>
    <url>%2F2018%2F08%2F08%2Fturtle%E7%BB%98%E5%9B%BE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[大概学习了下turtle库的一个绘图实例= =，估计以后也用不上这个库…. 代码实例1： 绘制一条小蛇 123456789101112131415161718192021222324252627import turtle # 绘图库# 绘制一条小蛇# 设置窗体大小及位置，但并不是必须的，依次长,宽，如果后两项不设置，则默认正中心turtle.setup(650, 350, 200, 200)# 抬起画笔turtle.penup()# turtle.fd表示向海龟的右边走，turtle.bk表示向海龟的左边走turtle.fd(-250)# 下笔turtle.pendown()# 设置画笔宽度turtle.pensize(25)# 设置画笔颜色turtle.pencolor("purple")# 改变当前行径的方向，原地转向的意思，参数为绝对角度# turtle.left和turtle.right表示向左边或右边改变角度turtle.seth(-40)for i in range(4): # circle表示以某一个点为圆心，向左侧运行 turtle.circle(40, 80) turtle.circle(-40, 80)turtle.circle(40, 80 / 2)turtle.fd(40)turtle.circle(16, 100)turtle.fd(40 * 2 / 3)turtle.done() 运行结果 实例2：绘制一个Z 代码123456789import turtleturtle.left(45) # 转角度turtle.fd(150) # 前进turtle.right(135)turtle.fd(300)turtle.left(135)turtle.fd(150)turtle.done() 运行结果]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式中的compile函数(二)]]></title>
    <url>%2F2018%2F08%2F07%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84compile%E5%87%BD%E6%95%B0(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[接着上一篇文章的compile函数实例 代码12345678910111213import repattern = re.compile(r'([a-z]+) ([a-z]+)', re.I) # re.I 表示忽略大小写m = pattern.match('Hello World Wide Web')print(m) # 匹配成功，返回一个Match 对象print(m.group(0)) # 返回匹配成功的整个子串print(m.span(0)) # 返回匹配成功整个子串的索引print(m.group(1)) # 返回第一个分组匹配成功的子串print(m.span(1)) # 返回第一个分组匹配成功的子串的索引print(m.group(2)) # 返回第二个分组匹配成功的子串print(m.span(2)) # 返回第二个分组匹配成功的子串的索引print(m.groups()) # 等价于(m.group(1),m.group(2), ...)print(m.group(3)) # 不存在第三个分组 运行结果123456789101112Traceback (most recent call last):&lt;_sre.SRE_Match object; span=(0, 11), match='Hello World'&gt; File "E:/PythonProject/more/test.py", line 13, in &lt;module&gt;Hello World print(m.group(3)) # 不存在第三个分组(0, 11)IndexError: no such groupHello(0, 5)World(6, 11)('Hello', 'World')]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式中的compile函数]]></title>
    <url>%2F2018%2F08%2F07%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84compile%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。 语法格式为： re.compile(pattern[, flags]) 参数： pattern : 一个字符串形式的正则表达式 flags 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为： re.I 忽略大小写 re.L 表示特殊字符集 \w, \W, \b, \B, \s, \S 依赖于当前环境 re.M 多行模式 re.S 即为’ . ‘并且包括换行符在内的任意字符（’ . ‘不包括换行符） re.U 表示特殊字符集 \w, \W, \b, \B, \d, \D, \s, \S 依赖于 Unicode 字符属性数据库 re.X 为了增加可读性，忽略空格和’ # ‘后面的注释 代码12345678910111213141516171819202122import re# 列子1pattern = re.compile(r'\d+') # 用于匹配至少一个数字m = pattern.match('one12twothree34four') # 查找头部，没有匹配print(m)m = pattern.match('one12twothree34four', 2, 10) # 从'e'的位置开始匹配，没有匹配print(m)m = pattern.match('one12twothree34four', 3, 10) # 从'1'的位置开始匹配，正好匹配print(m) # 返回一个Match对象print(m.group(0)) # 可省略0print(m.start(0)) # 可省略0print(m.end(0)) # 可省略0print(m.span(0)) # 可省略0'''在上面，当匹配成功时返回一个 Match 对象，其中：group([group1, …]) 方法用于获得一个或多个分组匹配的字符串，当要获得整个匹配的子串时，可直接使用 group() 或 group(0)；start([group]) 方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引），参数默认值为 0；end([group]) 方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1），参数默认值为 0；span([group]) 方法返回 (start(group), end(group))。''' 运行结果1234567NoneNone&lt;_sre.SRE_Match object; span=(3, 5), match=&apos;12&apos;&gt;1235(3, 5)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式检索与替换]]></title>
    <url>%2F2018%2F08%2F07%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A3%80%E7%B4%A2%E4%B8%8E%E6%9B%BF%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[re.sub用于替换字符串中的匹配项 re.sub(pattern, repl, string, count=0) 代码123456789101112131415161718192021import rephone = "2004-959-559 # 这是一个电话号码"# 删除注释num = re.sub(r'#.*$', "", phone)print("电话号码:", num)# 移除非数字的内容num = re.sub(r'\D', "", phone)print("电话号码:", num)# 将匹配的数字乘以2def double(matched): value = int(matched.group('value')) return str(value * 2)s = 'A23G4HFD567'print(re.sub('(?P&lt;value&gt;\d+)', double, s)) 运行结果123电话号码: 2004-959-559 电话号码: 2004959559A46G8HFD1134]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中的正则表达式match和search]]></title>
    <url>%2F2018%2F08%2F07%2FPython%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fmatch%E5%92%8Csearch%2F</url>
    <content type="text"><![CDATA[re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配 代码123456789101112131415161718import re'''re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。'''line = "Cats are smarter than dogs";matchObj = re.match(r'dogs', line, re.M | re.I)if matchObj: print("match --&gt; matchObj.group() : ", matchObj.group())else: print("No match!!")matchObj = re.search(r'dogs', line, re.M | re.I)if matchObj: print("search --&gt; matchObj.group() : ", matchObj.group())else: print("No match!!") 运行结果12No match!!search --&gt; matchObj.group() : dogs]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中的正则表达式]]></title>
    <url>%2F2018%2F08%2F07%2FPython%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[主要是一些正则表达式的基本语法和部分实例 re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none re.match(pattern, string, flag=0) 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等 re.search 扫描整个字符串并返回第一个成功的匹配 re.search(pattern, string, flag=0) 代码12345678910111213141516171819202122232425262728293031323334353637import re'''group() 返回被 RE 匹配的字符串start() 返回匹配开始的位置end() 返回匹配结束的位置span() 返回一个元组包含匹配 (开始,结束) 的位置group() 返回re整体匹配的字符串，可以一次输入多个组号，对应组号匹配的字符串'''print(re.match('www', 'www.runoob.com').span()) # 在起始位置匹配print(re.match('com', 'www.runoob.com')) # 不在起始位置匹配# group(num=0) 匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。line = "Cats are smarter than dogs"# match部分matchObj = re.match(r'(.*) are (.*?) .*', line, re.M | re.I)if matchObj: print("matchObj.group():", matchObj.group()) print("matchObj.group(1):", matchObj.group(1)) print("matchObj.group(2):", matchObj.group(2))else: print("No match!!")# search部分searchObj = re.search(r'(.*) are (.*?) .*', line, re.M | re.I)if searchObj: print("searchObj.group() : ", searchObj.group()) print("searchObj.group(1) : ", searchObj.group(1)) print("searchObj.group(2) : ", searchObj.group(2))else: print("Nothing found!!")# re.search 扫描整个字符串并返回第一个成功的匹配。print(re.search('www', 'www.runoob.com').span()) # 在起始位置匹配print(re.search('com', 'www.runoob.com').span()) # 不在起始位置匹配 运行结果12345678910(0, 3)NonematchObj.group(): Cats are smarter than dogsmatchObj.group(1): CatsmatchObj.group(2): smartersearchObj.group() : Cats are smarter than dogssearchObj.group(1) : CatssearchObj.group(2) : smarter(0, 3)(11, 14)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中面向对象比较简单的内部函数]]></title>
    <url>%2F2018%2F08%2F06%2FPython%E4%B8%AD%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%AF%94%E8%BE%83%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E9%83%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[比较简单的内部函数代码部分1234567891011121314151617181920212223class Cat: def __init__(self, new_name): self.name = new_name # 定义一个私有属性 self.__age = 18 print("&#123;&#125;来了".format(self.name)) def __del__(self): print("%s 我去了" % self.name) def __str__(self): # 必须返回一个字符串 # str方法定制变量输出信息，一般用来自定义内容 return "我是小猫&#123;&#125;".format(self.name) # 如果定义为__secret则为私有方法 def secret(self): print("&#123;&#125;的年龄是&#123;&#125;".format(self.name,self.__age))tom = Cat("Tom")tom.secret()print(tom) 运行结果1234Tom来了Tom的年龄是18我是小猫TomTom 我去了]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欢迎来到我的博客]]></title>
    <url>%2F2018%2F08%2F03%2F%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[机器学习持续学习中， 💥😩😤 西瓜书第一轮ing（100%） Coursera Machine Leaning（100%） 《机器学习实战》(emmm刚开始)]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Face</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中对列表和元组的切片操作]]></title>
    <url>%2F2018%2F07%2F28%2Fpython%E4%B8%AD%E5%AF%B9%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84%E7%9A%84%E5%88%87%E7%89%87%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[python中对列表和元组的切片操作代码123456789# 切片方法用于列表、元组,切片方法不能用于字典list_tmp = [0, 1, 2, 3, 4]tuple_tmp = (4, 3, 2, 1, 0)# 列表输出print([0, 1, 2, 3, 4][1:3])print(list_tmp[1:3])# 元组输出print((4, 3, 2, 1, 0)[1:3])print(tuple_tmp[1:3]) 运行结果1234[1, 2][1, 2](3, 2)(3, 2)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中字符串的一些方法回顾(切片回顾)]]></title>
    <url>%2F2018%2F07%2F26%2Fpython%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%E5%9B%9E%E9%A1%BE(%E5%88%87%E7%89%87%E5%9B%9E%E9%A1%BE)%2F</url>
    <content type="text"><![CDATA[python中字符串的一些方法回顾(切片回顾)代码123456789101112131415161718192021222324# 字符串的切片 字符串[开始索引:结束索引:步长]# 如果使用倒序索引的方法，那么最后一位元素是以-1开始，倒数第二位是-2# 切片方法适用于字符串、列表、元组num_str = "0123456789"# 截取2-5的字符串print(num_str[2:6])# 截取2-末尾的字符串print(num_str[2:])# 从起始位置截取到5位置的字符串 num_str[0:6]等价print(num_str[:6])# 生成切片的副本print(num_str[:])# 从开始位置开始，每隔一个字符截取字符串print(num_str[::2])# 从索引1开始，每隔一个取一个print(num_str[1::2])# 截取从2到(末尾-1)的字符串print(num_str[2:-1])# 截取字符串末尾两个字符print(num_str[-2:])# 字符串的逆序 num_str[::-1]等价print(num_str[-1::-1]) 运行结果123456789&gt;&gt;&gt;2345&gt;&gt;&gt;23456789&gt;&gt;&gt;012345&gt;&gt;&gt;0123456789&gt;&gt;&gt;02468&gt;&gt;&gt;13579&gt;&gt;&gt;2345678&gt;&gt;&gt;89&gt;&gt;&gt;9876543210]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中字符串的一些方法回顾(拆分与合并)]]></title>
    <url>%2F2018%2F07%2F26%2Fpython%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%E5%9B%9E%E9%A1%BE(%E6%8B%86%E5%88%86%E4%B8%8E%E5%90%88%E5%B9%B6)%2F</url>
    <content type="text"><![CDATA[python中字符串的一些方法回顾(拆分与合并)字符串中split函数和join函数的使用 代码123456789101112131415# 假设：以下内容是从网络上抓取的# 要求：# 1、将字符串中的空白字符全部去掉# 2、再使用" "作为分隔符，拼接成一个整齐的字符串poem_str = "登鹤鹊楼\t 王之涣 \t 白日依山尽 \t\n 黄河入海流 \t\t 欲穷千里目\t\t更上一层楼"print(poem_str)# 1、拆分字符串 split方法会返回列表poem_list = poem_str.split()print(poem_list)# 2、合并字符串result = " ".join(poem_list)print(result) 运行结果1234567原始字符串： 登鹤鹊楼 王之涣 白日依山尽 黄河入海流 欲穷千里目 更上一层楼拆分字符串后： ['登鹤鹊楼', '王之涣', '白日依山尽', '黄河入海流', '欲穷千里目', '更上一层楼']合并字符串后: 登鹤鹊楼 王之涣 白日依山尽 黄河入海流 欲穷千里目 更上一层楼]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中字符串的一些方法回顾(文本对齐、去除空白)]]></title>
    <url>%2F2018%2F07%2F26%2Fpython%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%E5%9B%9E%E9%A1%BE(%E6%96%87%E6%9C%AC%E5%AF%B9%E9%BD%90%E3%80%81%E5%8E%BB%E9%99%A4%E7%A9%BA%E7%99%BD)%2F</url>
    <content type="text"><![CDATA[python中字符串的一些方法回顾(文本对齐、去除空白)文本对齐的方法，以及用strip函数去除字符串的中空白字符 代码1234567891011121314151617181920# 假设：以下内容是从网络上抓取下来的# 要求：顺序并且居中对齐输出一下内容poem = ["\t\n登鹤鹊楼", "王之涣", "白日依山尽\t\n", "黄河入海流", "欲穷千里目", "更上一层楼"]for poem_str in poem: # 先使用strip方法去除字符串中的空白字符 # 居中对齐 ''' Python center() 返回一个原字符串居中,并使用空格填充至长度 width 的新字符串。默认填充字符为空格。 ''' print("|%s|" % poem_str.strip().center(10, " ")) # 向左对齐 # print("|%s|" % poem_str.ljust(10, " ")) # 向右对齐 # print("|%s|" % poem_str.rjust(10, " ")) 运行结果123456| 登鹤鹊楼 || 王之涣 || 白日依山尽 || 黄河入海流 || 欲穷千里目 || 更上一层楼 |]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中完整for循环的实际运用]]></title>
    <url>%2F2018%2F07%2F26%2Fpython%E4%B8%AD%E5%AE%8C%E6%95%B4for%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[python中完整for循环的实际运用代码1234567891011121314151617181920# 完整的for循环的实际应用 for...else结构students = [ &#123;"name": "xx"&#125;, &#123;"name": "yy"&#125;]# 在学院列表中搜索指定的姓名find_name = "SS"for i in students: print(i) if i["name"] == find_name: print("找到了 &#123;&#125;".format(find_name)) # 如果已经找到，应该直接退出循环，而不再遍历后续的元素 # 如果把这个else写在if语句之后的话，每次没有找到就要输出一次，这是不对的！ breakelse: print("没有找到&#123;&#125;".format(find_name))print("循环结束") 运行结果1234&#123;&apos;name&apos;: &apos;xx&apos;&#125;&#123;&apos;name&apos;: &apos;yy&apos;&#125;没有找到SS循环结束]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中字符串的一些方法回顾]]></title>
    <url>%2F2018%2F07%2F25%2Fpython%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%E5%9B%9E%E9%A1%BE%2F</url>
    <content type="text"><![CDATA[python中字符串的一些方法回顾代码12345678910111213141516171819202122232425hello_str = "hello world"# 1、统计字符串长度print(len(hello_str))# 2、统计某一个小字符串出现的次数print(hello_str.count("llo"))# 3、某一个子字符串出现的位置print(hello_str.index("llo"))# 4、输出数学的平方num_str = "\u00b2"print(num_str)# 5、判断是否以指定字符串开始print(hello_str.startswith("hello"))# 6、判断是否以指定字符串结束print(hello_str.endswith("world"))# 7、查找指定字符串# 在index方法中，如果指定的字符串不存在，会直接报错# 在find方法中，如果指定的字符串不存在，会返回-1print(hello_str.find("llo"))print(hello_str.find("CCC"))# 8、替换字符串# replace方法执行完成之后会返回一个新的字符串，但是不会修改原有字符串的内容hh = hello_str.replace("world", "python")print(hh)print(hello_str) 运行结果123456789101112²TrueTrue2-1hello pythonhello world]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[list(列表)、tuple（元组）、dict（字典）的回顾]]></title>
    <url>%2F2018%2F07%2F25%2Flist(%E5%88%97%E8%A1%A8)%E3%80%81tuple%EF%BC%88%E5%85%83%E7%BB%84%EF%BC%89%E3%80%81dict%EF%BC%88%E5%AD%97%E5%85%B8%EF%BC%89%E7%9A%84%E5%9B%9E%E9%A1%BE%2F</url>
    <content type="text"><![CDATA[list(列表)、tuple（元组）、dict（字典）的回顾代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263list1 = [5, 6, 87, 671, 3, 54, 67, 0, 1, -6, -7]# 升序排序list1.sort()print(list1)# 降序排序list1.sort(reverse=True)print(list1)# 列表和元组之间相互转换print(type(list1))# 1、列表转换成元组num_tuple = tuple(list1)print(type(num_tuple))# 2 、元组转换成列表num2_list = list(num_tuple)print(type(num2_list))# 字典的使用# 1、取值dict_test = &#123;"name": "xxx"&#125;print(dict_test["name"])# 2、增加/修改dict_test["age"] = 18 # 增加dict_test["name"] = "yyy" # 修改print(dict_test)# 3、删除dict_test.pop("name")print(dict_test)# 4、统计键值对的数量print(len(dict_test))# 5、合并字典# 如果被合并的字典中包含已经存在的键值对，会覆盖原有的键值对temp_dict = &#123;"height": 123, "age": 20&#125;dict_test.update(temp_dict)print(dict_test)# 6、清空字典dict_test.clear()print(dict_test)# 7、迭代遍历字典# 变量k是每次循环中，获取到的键值对的值new_dict = &#123;"name": "xxx", "age": 20, "height": 200&#125;for k in new_dict: print("&#123;&#125; - &#123;&#125;".format(k, new_dict[k]))# 8、列表中保存多个字典,并用for循环迭代输出list2 = [ &#123;"name": "qqq", "email": "163", "phone": 119&#125;, &#123;"name": "sss", "email": "cc", "phone": 110&#125;]for i in list2: print(i) 运行结果12345678910111213141516[-7, -6, 0, 1, 3, 5, 6, 54, 67, 87, 671][671, 87, 67, 54, 6, 5, 3, 1, 0, -6, -7]&lt;class &apos;list&apos;&gt;&lt;class &apos;tuple&apos;&gt;&lt;class &apos;list&apos;&gt;xxx&#123;&apos;age&apos;: 18, &apos;name&apos;: &apos;yyy&apos;&#125;&#123;&apos;age&apos;: 18&#125;1&#123;&apos;age&apos;: 20, &apos;height&apos;: 123&#125;&#123;&#125;age - 20name - xxxheight - 200&#123;&apos;phone&apos;: 119, &apos;name&apos;: &apos;qqq&apos;, &apos;email&apos;: &apos;163&apos;&#125;&#123;&apos;phone&apos;: 110, &apos;name&apos;: &apos;sss&apos;, &apos;email&apos;: &apos;cc&apos;&#125; 总结总结： list使用的是方括号，类似与数组结构，tuple元组使用的是圆括号，跟list类似但是数据不能进行修改，所以应用的场景基本上用在需要数据存储，或者是需要保证数据安全无法修改的情况，字典用的是大括号，是key-value结构的, 操作数据的时候，是操作key，而不是索引。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打印九九乘法表]]></title>
    <url>%2F2018%2F07%2F24%2F%E6%89%93%E5%8D%B0%E4%B9%9D%E4%B9%9D%E4%B9%98%E6%B3%95%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[打印九九乘法表主要是练习python下的不同输出方式 代码1234567891011121314151617181920212223242526# 用for循环打印九九乘法表for i in range(1, 10): for j in range(1, 10): # 这里例举四种不同方式的打印方法 # 1、 # print("&#123;0&#125;*&#123;1&#125;=&#123;2&#125;".format(i, j, i * j), end='\t') # 2 、 # print("%d*%d=%2d" % (i, j, i * j), end='\t') # 3、 # print(i, "x", j, "=", i * j, "\t", end="") # 4、 print("&#123;&#125;*&#123;&#125;=&#123;&#125;".format(i, j, i * j), end='\t') if i == j: print("") break# 用while循环打印九九乘法表row = 1while row &lt;= 9: col = 1 while col &lt;= row: print("%d*%d=%2d" % (row, col, row * col), end='\t') col += 1 print("") row += 1 运行结果1234567891011121314151617181*1=1 2*1=2 2*2=4 3*1=3 3*2=6 3*3=9 4*1=4 4*2=8 4*3=12 4*4=16 5*1=5 5*2=10 5*3=15 5*4=20 5*5=25 6*1=6 6*2=12 6*3=18 6*4=24 6*5=30 6*6=36 7*1=7 7*2=14 7*3=21 7*4=28 7*5=35 7*6=42 7*7=49 8*1=8 8*2=16 8*3=24 8*4=32 8*5=40 8*6=48 8*7=56 8*8=64 9*1=9 9*2=18 9*3=27 9*4=36 9*5=45 9*6=54 9*7=63 9*8=72 9*9=81 1*1= 1 2*1= 2 2*2= 4 3*1= 3 3*2= 6 3*3= 9 4*1= 4 4*2= 8 4*3=12 4*4=16 5*1= 5 5*2=10 5*3=15 5*4=20 5*5=25 6*1= 6 6*2=12 6*3=18 6*4=24 6*5=30 6*6=36 7*1= 7 7*2=14 7*3=21 7*4=28 7*5=35 7*6=42 7*7=49 8*1= 8 8*2=16 8*3=24 8*4=32 8*5=40 8*6=48 8*7=56 8*8=64 9*1= 9 9*2=18 9*3=27 9*4=36 9*5=45 9*6=54 9*7=63 9*8=72 9*9=81]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打印直角三角形]]></title>
    <url>%2F2018%2F07%2F24%2F%E6%89%93%E5%8D%B0%E7%9B%B4%E8%A7%92%E4%B8%89%E8%A7%92%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[打印直角三角形做个对比 代码123456789101112# 嵌套循环版本打印直角三角形row = 1while row &lt;= 5: col = 1 while col &lt;= row: print("*", end=' ') col += 1 print() row += 1# python版本打印直角三角形for i in range(1, 6): print('* ' * i) 运行结果两者均为 12345* * * * * * * * * * * * * * *]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰器]]></title>
    <url>%2F2018%2F07%2F24%2F%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[装饰器装饰器（Decorators）是应用包装函数的快捷方式。这有助于将某一功能与一些代码一遍又一遍地“包装”。举个例子，我为自己创建了一个 retry 装饰器，这样我可以将其运用到任何函数之中，如果在一次运行中抛出了任何错误，它就会尝试重新运行，直到最大次数 5 次，并且每次运行期间都会有一定的延迟。这对于你在对一台远程计算机进行网络调用的情况十分有用： 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445# 从time模块引入sleep函数from time import sleepfrom functools import wrapsimport logginglogging.basicConfig()log = logging.getLogger("retry")def retry(f): @wraps(f) def wrapped_f(*args, **kwargs): MAX_ATTEMPTS = 5 for attempt in range(1, MAX_ATTEMPTS + 1): try: return f(*args, **kwargs) except: log.exception("Attempt %s %s failed : %s", attempt, MAX_ATTEMPTS, (args, kwargs)) sleep(10 * attempt) log.critical("All %s attempts failed : %s", MAX_ATTEMPTS, (args, kwargs)) return wrapped_fcounter = 0@retrydef save_to_database(arg): print("Write to a database or make a network call or etc.") print("This will be automatically retried if exception is thrown.") global counter counter += 1 # 这将在第一次调用时抛出异常 # 在第二次运行时正常工作（也就是重试） if counter &lt; 2: raise ValueError(arg)# 让你写的脚本模块既可以导入到别的模块中用，另外该模块自己也可执行。if __name__ == '__main__': save_to_database("Some bad value") 运行结果1234567891011ERROR:retry:Attempt 1 5 failed : (('Some bad value',), &#123;&#125;)Traceback (most recent call last): File "E:/PythonProject/more/more_decorators.py", line 16, in wrapped_f return f(*args, **kwargs) File "E:/PythonProject/more/more_decorators.py", line 40, in save_to_database raise ValueError(arg)ValueError: Some bad valueWrite to a database or make a network call or etc.This will be automatically retried if exception is thrown.Write to a database or make a network call or etc.This will be automatically retried if exception is thrown.]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[assert语句的运用]]></title>
    <url>%2F2018%2F07%2F24%2Fassert%E8%AF%AD%E5%8F%A5%E7%9A%84%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[assert语句的运用代码123456# assert语句# pop() 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值。mylist = ['item']assert len(mylist) &gt;= 1print(mylist.pop())assert len(mylist) &gt;= 1 运行结果12345itemTraceback (most recent call last): File "E:/PythonProject/more/more_assert.py", line 6, in &lt;module&gt; assert len(mylist) &gt;= 1AssertionError]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在函数中接受元组与字典]]></title>
    <url>%2F2018%2F07%2F24%2F%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E6%8E%A5%E5%8F%97%E5%85%83%E7%BB%84%E4%B8%8E%E5%AD%97%E5%85%B8%2F</url>
    <content type="text"><![CDATA[在函数中接受元组与字典 有一种特殊方法，即分别使用 或 * 作为元组或字典的前缀，来使它们作为一个参数为函数所接收。当函数需要一个可变数量的实参时，这将非常有用。 代码12345678910111213141516# 当args变量前面添加了一个*时，函数的所有其他的参数都将传递到args中，并作为一个元组储存# 如果采用的是 ** 前缀，则额外的参数将被视为字典的键值—值配对。def powersum(power, *args): '''Return the sum of each argument raised to the specified power.''' total = 0 # 在for循环中，i每次获取的是args的值，也就是说初值由args而定 for i in args: total += pow(i, power) return total# 这里可以debug一下看下i的变化，在这里一开始的时候power=2，*args=（3，4）# i在初始时为3print(powersum(2, 3, 4))# 这里i初始时为10print(powersum(2, 10)) 运行结果 25100]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[列表推导]]></title>
    <url>%2F2018%2F07%2F24%2F%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[列表推导列表推导（List Comprehension）用于从一份现有的列表中得到一份新列表。想象一下，现在你已经有了一份数字列表，你想得到一个相应的列表，其中的数字在大于 2 的情况下将乘以2。列表推导就是这类情况的理想选择。 代码1234567891011121314151617# 列表推导'''程序理解：当满足了某些条件时（ if i &gt; 2 ），我们进行指定的操作（ 2*i ），以此来获得一份新的列表。要注意到原始列表依旧保持不变。'''listone = [2, 3, 4]listtwo = [2 * i for i in listone if i &gt; 2]print(listtwo)'''列表推导的优点在于，当我们使用循环来处理列表中的每个元素并将其存储到新的列表中时它能够减少代码量''' 运行结果 [6, 8]]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的lambda函数]]></title>
    <url>%2F2018%2F07%2F24%2Fpython%E4%B8%AD%E7%9A%84lambda%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[python中的lambda函数lambda函数相当于定义了一个匿名的函数，减少了代码量 代码1234567891011121314151617181920212223242526272829303132333435# Lambda表格 也是lambda函数points = [&#123;'x': 2, 'y': 3&#125;, &#123;'x': 4, 'y': 1&#125;]points.sort(key=lambda i: i['y'])print(points)'''要注意到一个 list 的 sort 方法可以获得一个 key 参数，用以决定列表的排序方式（通常我们只知道升序与降序）。在我们的案例中，我们希望进行一次自定义排序，为此我们需要编写一个函数，但是又不是为函数编写一个独立的 def 块，只在这一个地方使用，因此我们使用 Lambda 表达式来创建一个新函数。'''# lambda函数的其他使用方法add = lambda x, y: x + yprint(add(1, 2)) # 结果为3# 需求：将列表中的元素按照绝对值大小进行升序排列list1 = [3, 5, -4, -1, 0, -2, -6]print(sorted(list1, key=lambda x: abs(x)))'''等价于def get_abs(x): return abs(x)list1.sort(key=get_abs)print(list1)或者def get_abs(x): return abs(x) print(sorted(list1, key=get_abs))''' 运行结果123[&#123;&apos;y&apos;: 1, &apos;x&apos;: 4&#125;, &#123;&apos;y&apos;: 3, &apos;x&apos;: 2&#125;]3[0, -1, -2, 3, -4, 5, -6]]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的__name__ = '__main__' 的作用]]></title>
    <url>%2F2018%2F07%2F24%2Fpython%E7%9A%84__name__-%3D-__main__%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[python的name = ‘main‘ 的作用12345678__name__ = '__main__' 的作用先写一个模块：#module.pydef main(): print "we are in %s"%__name__if __name__ == '__main__': main() 我们经常看到想上面代码底下的代码，其主要的意义在于： 让你写的脚本即可以导入别的模块中用，另外该模块自己也可以执行这个函数定义了一个main函数，我们执行一下该py文件发现结果是打印出”we are in main“,说明我们的if语句中的内容被执行了，调用了main()： 但是如果我们从另我一个模块导入该模块，并调用一次main()函数会是怎样的结果呢？ 其执行的结果是：we are in module 但是没有显示 1”we are in __main__“ ,也就是说模块 1__name__ = &apos;__main__&apos; 下面的函数没有执行。 这样既可以让“模块”文件运行，也可以被其他模块引入，而且不会执行函数2次。这才是关键。 总结12345678如果我们是直接执行某个.py文件的时候，该文件中那么”__name__ == '__main__'“是True,但是我们如果从另外一个.py文件通过import导入该文件的时候，这时__name__的值就是我们这个py文件的名字而不是__main__。这个功能还有一个用处：调试代码的时候，在”if __name__ == '__main__'“中加入一些我们的调试代码，我们可以让外部模块调用的时候不执行我们的调试代码，但是如果我们想排查问题的时候，直接执行该模块文件，调试代码能够正常运行！]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多种方法快速交换两个变量的值]]></title>
    <url>%2F2018%2F07%2F24%2F%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%B3%95%E5%BF%AB%E9%80%9F%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC%2F</url>
    <content type="text"><![CDATA[使用多种方法快速交换两个变量的值 1、利用元组的快速交换变量值 2、引入新的变量来交换 3、使用加减法交换变量值 4、利用元组从一个函数中返回两个不同的值 代码12345678910111213141516171819202122232425# 1. 利用元组的快速交换变量值a = 5b = 8a, b = b, aprint(a, b)# 2. 引入新的变量来交换c = bb = aa = cprint(a, b)# 3. 使用加减法交换变量值a = a + bb = a - ba = a - bprint(a, b)# 4. 利用元组从一个函数中返回两个不同的值def get_error_details(): return (2, 'details')errnum, errstr = get_error_details()print(errnum)print(errstr) 运行结果123458 55 88 52details]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python日志模块]]></title>
    <url>%2F2018%2F07%2F23%2Fpython%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[日志模块的应用代码123456789101112131415161718192021222324252627# 日志模块import osimport platformimport logging# os.getenv()获取一个环境变量，如果没有返回none# os.path.join()： 将多个路径组合后返回if platform.platform().startswith('Windows'): logging_file = os.path.join(os.getenv('HOMEDRIVE'), os.getenv('HOMEPATH'), 'test.log')else: logging_file = os.path.join(os.getenv('HOME'), 'test.log')print("Logging to", logging_file)logging.basicConfig( level=logging.DEBUG, format='%(asctime)s: %(levelname)s :%(message)s', filename=logging_file, filemode='w',)# 日志文件将存储在电脑上logging.debug("Start of the program")logging.info("Doing something")logging.warning("Dying now") 运行结果12345Logging to C:\Users\dylink\test.log电脑查看该目录文件为2018-07-23 20:03:55,441: DEBUG :Start of the program2018-07-23 20:03:55,441: INFO :Doing something2018-07-23 20:03:55,441: WARNING :Dying now]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户自己引发的异常处理]]></title>
    <url>%2F2018%2F07%2F23%2F%E7%94%A8%E6%88%B7%E8%87%AA%E5%B7%B1%E5%BC%95%E5%8F%91%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[由用户自行定义的异常类处理代码12345678910111213141516171819202122232425# encoding = UTF-8# 用户自己引发异常class ShortInputException(Exception): '''一个由用户定义的异常类''' def __init__(self, length, atleast): Exception.__init__(self) self.length = length self.atleast = atleasttry: text = input('Enter someting --&gt;') if len(text) &lt; 3: raise ShortInputException(len(text), 3) # 其他工作能够在此处正常运行except EOFError: print('Why did you do an EOF on me?')except ShortInputException as ex: print(('ShortInputException: The input was ' + '&#123;0&#125; long,expected at least &#123;1&#125;') .format(ex.length, ex.atleast))else: print('No exception was raised.') 运行结果 1.如果输入超过了3位数，截获错误 12Enter someting --&gt;88888No exception was raised. 2.如果输入没有超过3位数 12Enter someting --&gt;12ShortInputException: The input was 2 long,expected at least 3]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[with open异常处理]]></title>
    <url>%2F2018%2F07%2F23%2Fwith-open%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[with open异常处理代码123456with open("poem.txt") as f: for line in f: print(line, end='')''' with open能够将之前的try..finally最后执行的关闭文件的操作，交给with open自动完成''' 运行结果 poem.txt里面的内容为：12165456478 1&gt;&gt;&gt;12165456478]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[finally异常处理]]></title>
    <url>%2F2018%2F07%2F23%2Ffinally%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[finally异常处理代码123456789101112131415161718192021222324import sysimport timef = Nonetry: f = open("poem.txt") # 我们常用的文件阅读风格 while True: line = f.readline() if len(line) == 0: break print(line, end='') sys.stdout.flush() print("Press ctrl+c now") # 为了确保它能运行一段时间 time.sleep(2) # time.sleep 函数任意在每打印一行后插入两秒休眠except IOError: print("Could not find file poem.txt")except KeyboardInterrupt: print("!! You cancelled the reading from the file.")finally: # 始终执行 if f: f.close() print("(Cleaning up: Closed the file)") 运行结果1212165456478Press ctrl+c now(Cleaning up: Closed the file)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单的异常处理]]></title>
    <url>%2F2018%2F07%2F23%2F%E7%AE%80%E5%8D%95%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[简单的异常处理代码12345678try: text = input('Enter someting --&gt;')except EOFError: # 按ctrl+D print('Why did you do an EOF on me?')except KeyboardInterrupt: # 按ctrl+C print('You cancelled the operation.')else: print('You enterd &#123;&#125;'.format(text)) 运行结果12Enter someting --&gt;^DWhy did you do an EOF on me?]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在打开文件的同时规定编码]]></title>
    <url>%2F2018%2F07%2F23%2F%E5%9C%A8%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E7%9A%84%E5%90%8C%E6%97%B6%E8%A7%84%E5%AE%9A%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[规定编码代码123456789101112131415161718# 在打开文件的同时规定编码'''如果你正在使用 Python 2，我们又希望能够读写其它非英语语言，我们需要使用unicode 类型，它全都以字母 u 开头，例如 u"hello world" 。&gt;&gt;&gt; u"hello world"'hello world''''# encoding = utf-8import iof = io.open("abc.txt", "wt", encoding="utf-8")f.write(u"Imagine non-English language here")f.close()text = io.open("abc.txt", encoding="utf-8").read()print(text) 运行结果 Imagine non-English language here]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的pickle模块]]></title>
    <url>%2F2018%2F07%2F23%2Fpython%E7%9A%84pickle%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[python的pickle模块Python 提供了一个叫作 Pickle 的标准模块，通过它你可以将任何纯 Python 对象存储到一个文件中，并在稍后将其取回。这叫作持久地（Persistently）存储对象。 代码123456789101112131415161718192021222324252627282930313233'''在Pickle模块中有2个常用的函数方法，一个叫做dump()，另一个叫做load()。pickle.dump(对象, 文件，[使用协议])load()方法的作用正好与上面的dump()方法相反，上面是序列化数据，这个方法作用是反序列化。pickle.load(文件)目的主要是为了将一些数据，如字符串、列表、字典等长期的以文件形式保存下来'''import pickle# The name of the file where we will store the objectshoplistfile = 'shoplist.data'# The list of things to buyshoplist = ['apple', 'mango', 'carrot']# Write to the filef = open(shoplistfile, 'wb')# Dump the object to a filepickle.dump(shoplist, f)f.close()# Destroy the shoplist variabledel shoplist# Read back from the storagef = open(shoplistfile, 'rb')# Load the object from the filestoredlist = pickle.load(f)print(storedlist) 运行结果1['apple', 'mango', 'carrot']]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件操作]]></title>
    <url>%2F2018%2F07%2F23%2F%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[文件操作代码12345678910111213141516171819202122232425262728poem = '''Programming is funWhen the work is doneif you wanna make your work also fun: use Python!'''# 打开文件以编辑（'w'riting）f = open('poem.txt', 'w')# 向文件中编写文本f.write(poem)# 关闭文件f.close()# 如果没有特别指定# 将假定启用默认的阅读（'r'ead）模式f = open('poem.txt')while True: line = f.readline() # 零长度指示 EOF , 用来判断文档结尾 if len(line) == 0: break # 每行（'line'）的末尾 # 都已经有了换行符 # 因为它是从一个文件中进行读取的 print(line, end=' ')# 关闭文件f.close() 运行结果1234Programming is funWhen the work is doneif you wanna make your work also fun: use Python!]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[输入输出——回文字串的判断（加强版）]]></title>
    <url>%2F2018%2F07%2F23%2F%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E2%80%94%E2%80%94%E5%9B%9E%E6%96%87%E5%AD%97%E4%B8%B2%E7%9A%84%E5%88%A4%E6%96%AD%EF%BC%88%E5%8A%A0%E5%BC%BA%E7%89%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[输入输出——回文字串的判断（加强版）123456789101112131415161718192021222324252627forbindden_word = (' ', ',', ';', '.', '!', '//', '?')# 样例字符串Rise to vote,sir. 共17长度def ignore_word(text): # 去除忽略的特殊字符 strdemo = list(text.lower()) count = 0 print('长度为:', len(strdemo)) for i in list(range(len(strdemo))): # 遍历从0-16，共17长度 ，debug一下就懂了 if strdemo[i - count] in forbindden_word: del strdemo[i - count] # 删除特殊字符 count += 1 return strdemodef reverse(text): return text[::-1]def is_reverse(text): # 判断是否为回文 return text == reverse(text)something = input('随便输入点什么:')if is_reverse(ignore_word(something)): print('恭喜！他是回文文本')else: print('这好像不是回文文本哦') 运行结果123随便输入点什么:Rise to vote,sir.长度为: 17恭喜！他是回文文本]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[输入输出——简单的回文判断]]></title>
    <url>%2F2018%2F07%2F23%2F%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E7%9A%84%E5%9B%9E%E6%96%87%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[输入输出——简单的回文判断代码123456789101112131415161718192021'''可以通过使用 seq[a:b] 来从位置 a 开始到位置 b 结束来对序列进行切片 。我们同样可以提供第三个参数来确定切片的步长（Step）。默认的步长为 1 ，它会返回一份连续的文本。如果给定一个负数步长，如 -1 ，将返回翻转过的文本。'''def reverse(text): return text[::-1] # 使用切片功能返回倒序def is_palindrome(text): return text == reverse(text) # 如果正序和倒序相等的话，就是回文something = input("Enter text: ")if is_palindrome(something): print("Yes,it is a palidrome") # 是回文else: print("No, it is not a palindrome") # 不是回文 运行结果 如果是回文字串 Enter text: 1221Yes,it is a palidrome 如果不是回文字串 Enter text: 11111555No, it is not a palindrome]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承的运用]]></title>
    <url>%2F2018%2F07%2F23%2F%E7%BB%A7%E6%89%BF%E7%9A%84%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[继承的运用代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 继承的运用# coding = UTF-8class SchoolMember: '''代表学校里的成员。''' def __init__(self, name, age): self.name = name self.age = age print('(Initialized SchoolMember: &#123;&#125;)'.format((self.name))) def tell(self): '''告诉我有关我的细节。''' print('Name:"&#123;&#125;" Age:"&#123;&#125;"'.format(self.name, self.age), end=" ")class Teacher(SchoolMember): '''代表一位老师。''' def __init__(self, name, age, salary): SchoolMember.__init__(self, name, age) self.salary = salary print('(Initialized Teacher: &#123;&#125;)'.format(self.name)) def tell(self): SchoolMember.tell(self) print('Salary: "&#123;:d&#125;"'.format(self.salary))class Student(SchoolMember): '''代表一位学生。''' def __init__(self, name, age, marks): SchoolMember.__init__(self, name, age) self.marks = marks print('(Initialized Student: &#123;&#125;)'.format(self.name)) def tell(self): SchoolMember.tell(self) print('Marks: "&#123;:d&#125;"'.format(self.marks))t = Teacher('Mrs. Shrividya', 40, 30000)s = Student('Swaroop', 25, 75)print()members = [t, s]for member in members: # 对全体师生工作 member.tell() 运行结果 1234567(Initialized SchoolMember: Mrs. Shrividya)(Initialized Teacher: Mrs. Shrividya)(Initialized SchoolMember: Swaroop)(Initialized Student: Swaroop)Name:"Mrs. Shrividya" Age:"40" Salary: "30000"Name:"Swaroop" Age:"25" Marks: "75"]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类变量与对象变量]]></title>
    <url>%2F2018%2F07%2F23%2F%E7%B1%BB%E5%8F%98%E9%87%8F%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[类变量与对象变量代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# coding=UTF-8,类变量与对象变量class Robot: """表示有一个带有名字的机器人。""" # 一个类变量，用来计数机器人的数量 population = 0 # 这是一个类变量，属于Robot类 def __init__(self, name): # name变量属于一个对象（通过self分配），因此它是一个对象变量 """初始化数据""" self.name = name print("(Initializing &#123;&#125;)".format(self.name)) # 当有人被创建时，机器人会增加人口数量 ''' 除了 Robot.popluation ，我们还可以使用 self.__class__.population ，因为每个对象都通过 self.__class__ 属性来引用它的类。 ''' Robot.population += 1 def die(self): """我挂了。""" print("&#123;&#125; is being destroyed!".format(self.name)) Robot.population -= 1 if Robot.population == 0: print("&#123;&#125; was the last one.".format(self.name)) else: print("There are still &#123;:d&#125; robots working.".format(Robot.population)) def say_hi(self): """来自机器人的诚挚问候 没问题，你做得到""" print("Greetings , my masters call me &#123;&#125;".format(self.name)) ''' classmethod 修饰符对应的函数不需要实例化，不需要 self 参数， 但第一个参数需要是表示自身类的 cls 参数，可以来调用类的属性，类的方法，实例化对象等。 ''' # how_many实际上是一个属于类而非属于对象的方法 # classmethod(类方法)或是一个staticmethod(静态方法) @classmethod # 装饰器，等价于how_many = classmethod(how_many) def how_many(cls): """打印出当前的人口数量""" print("We have &#123;:d&#125; robots.".format(cls.population))droid1 = Robot("R2-D2")droid1.say_hi()Robot.how_many()droid2 = Robot("C-3PO")droid2.say_hi()Robot.how_many()print("\nRobots can do some work here.\n")print("Robots have finished their work. So let's destroy them.")droid1.die()droid2.die()Robot.how_many() 运行结果 123456789101112131415(Initializing R2-D2)Greetings , my masters call me R2-D2We have 1 robots.(Initializing C-3PO)Greetings , my masters call me C-3POWe have 2 robots.Robots can do some work here.Robots have finished their work. So let's destroy them.R2-D2 is being destroyed!There are still 1 robots working.C-3PO is being destroyed!C-3PO was the last one.We have 0 robots.]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python对象的实例化]]></title>
    <url>%2F2018%2F07%2F23%2Fpython%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[python对象的实例化代码1234567891011121314'''__init__ 方法会在类的对象被实例化（Instantiated）时立即运行。这一方法可以对任何你想进行操作的目标对象进行初始化（Initialization）操作。'''class Person: def __init__(self, name): self.name = name def say_hi(self): print('Hello,my name is', self.name)p = Person('Swaroop')p.say_hi() 运行结果 Hello,my name is Swaroop]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用python进行文件的自动备份(第三版和第四版)]]></title>
    <url>%2F2018%2F07%2F23%2F%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD(%E7%AC%AC%E4%B8%89%E7%89%88%E5%92%8C%E7%AC%AC%E5%9B%9B%E7%89%88)%2F</url>
    <content type="text"><![CDATA[利用python进行文件的自动备份(第三版和第四版)代码12345678910111213141516171819202122232425262728293031323334353637383940414243import osimport time'''第三版和第四版差别不大整合在一起，用户注释的内容可以添加到文件名中来实现'''source = [r'E:\aaa.txt']target_dir = 'E:\\Backup\\'if not os.path.exists(target_dir): os.mkdir(target_dir)# 子目录名称today = target_dir + os.sep + time.strftime('%Y%m%d')# 将当前时间作为zio文件的文件名now = time.strftime('%H%M%S')# 添加一条来自用户的注释以创建# zip文件的文件名comment = input('Enter a comment --&gt;')# 检查是否有评论键入if len(comment) == 0: target = today + os.sep + now + '.zip'# replace函数中前面的将被替换为后面的else: target = today + os.sep + now + '_' + \ comment.replace(' ', '_') + '.zip'# 如果子目录尚不存在则创建一个if not os.path.exists(today): os.mkdir(today) print('Successfully created directory', today)zip_command = "7z a &#123;0&#125; &#123;1&#125;".format(target, ' '.join(source))# 运行备份print('Zip command is:')print(zip_command)print('Running:')if os.system(zip_command) == 0: print('Successful backup to', target)else: print('Backup FAILED') 运行结果 12345678910111213141516171819Enter a comment --&gt;This is my backupZip command is:7z a E:\Backup\\20180723\185735_This_is_my_backup.zip E:\aaa.txtRunning:7-Zip 18.05 (x64) : Copyright (c) 1999-2018 Igor Pavlov : 2018-04-30Scanning the drive:1 file, 10 bytes (1 KiB)Creating archive: E:\Backup\\20180723\185735_This_is_my_backup.zipAdd new data to archive: 1 file, 10 bytes (1 KiB)Files read from disk: 1Archive size: 158 bytes (1 KiB)Everything is OkSuccessful backup to E:\Backup\\20180723\185735_This_is_my_backup.zip]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用python进行文件的自动备份（第二版）]]></title>
    <url>%2F2018%2F07%2F23%2F%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[利用python进行文件的自动备份（第二版）代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import osimport time'''第二版是第一版的改进，启用一种更好的文件命名机制——使用时间作为文件名，存储在以当前时间为名字的文件夹中，这一文件夹则照常存储在主备份目录下。'''# 例如在 Windows 下：source = [r'E:\aaa.txt']# 在这里要注意到我们必须在字符串中使用双引号# 用以括起其中包含空格的名称。# 2. 备份文件必须存储在一个# 主备份目录中# 例如在 Windows 下：target_dir = 'E:\\Backup\\'# 要记得将这里的目录地址修改至你将使用的路径# 如果目标目录还不存在，则进行创建if not os.path.exists(target_dir): os.mkdir(target_dir) # 创建目录# 3.备份文件将打包压缩成zip文件# 4.zip压缩文件的文件名由当前日期与时间构成# 其中os.sep 表示更改操作系统中的路径分隔符today = target_dir + os.sep + time.strftime('%Y%m%d')# 将当前时间作为zip文件的文件名now = time.strftime('%H%M%S')# zip文件名称格式target = today + os.sep + now + 'zip'# 如果子目录尚不存在则创建一个if not os.path.exists(today): os.mkdir(today) print('Successfully created diectory', today)# 5.原本这里是使用zip命令，但是在windows环境下面这个是不是系统命令，所以解决方案如下：'''1.1.下载7-Zip并安装2.将安装文件中的7z.exe移至‘C:\Windows’目录下3.将程序中的 zip_command = "zip -qr '%s' %s"%(target,''.join(source))改为：zip_command = "7z a %s %s"%(target, ' '.join(source))或者是"7z a &#123;0&#125; &#123;1&#125;".format(target, ' '.join(source))'''zip_command = "7z a &#123;0&#125; &#123;1&#125;".format(target, ' '.join(source))# 运行备份print('Zip command is:')print(zip_command)print('Running:')if os.system(zip_command) == 0: print('Successful backup to', target)else: print('Backup FAILED') 运行结果123456789101112131415161718Zip command is:7z a E:\Backup\\20180723\185035zip E:\aaa.txtRunning:7-Zip 18.05 (x64) : Copyright (c) 1999-2018 Igor Pavlov : 2018-04-30Scanning the drive:1 file, 10 bytes (1 KiB)Creating archive: E:\Backup\\20180723\185035zip.7zAdd new data to archive: 1 file, 10 bytes (1 KiB)Files read from disk: 1Archive size: 136 bytes (1 KiB)Everything is OkSuccessful backup to E:\Backup\\20180723\185035zip]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用python进行文件的自动备份]]></title>
    <url>%2F2018%2F07%2F22%2F%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD%2F</url>
    <content type="text"><![CDATA[利用Python进行文件的自动备份（第一版）os.system 函数的命令，这一函数可以使命令像是从系统中运行的。也就是说，从 shell 中运行的——如果运行成功，它将返回 0 ，如果运行失败，将返回一个错误代码。 针对 Windows 用户的提示除了使用双反斜杠转义序列，你还可以使用原始字符串。例如使用 ‘C:\\Documents’ 或r’C:\Documents’ 。然而，不要使用 ‘C:\Documents’ ，因为它将被识别为你使用了一个未知的转义序列 \D 来结束路径的输入。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243import osimport time# 1. 需要备份的文件与目录将被# 指定在一个列表中。# 例如在 Windows 下：source = [r'E:\aaa.txt']# 在这里要注意到我们必须在字符串中使用双引号# 用以括起其中包含空格的名称。# 2. 备份文件必须存储在一个# 主备份目录中# 例如在 Windows 下：target_dir = 'E:\\Backup\\'# 要记得将这里的目录地址修改至你将使用的路径# 3.备份文件将打包压缩成zip文件# 4.zip压缩文件的文件名由当前日期与时间构成# 其中os.sep 表示更改操作系统中的路径分隔符target = target_dir + os.sep + \ time.strftime('%Y%m%d%H%M%S') + '.zip'# 如果目标目录还不存在，则进行创建if not os.path.exists(target_dir): os.mkdir(target_dir) # 创建目录# 5.原本这里是使用zip命令，但是在windows环境下面这个是不是系统命令，所以解决方案如下：'''1.1.下载7-Zip并安装2.将安装文件中的7z.exe移至‘C:\Windows’目录下3.将程序中的 zip_command = "zip -qr '%s' %s"%(target,''.join(source))改为：zip_command = "7z a %s %s"%(target, ' '.join(source))'''zip_command = "7z a %s %s" % (target, ' '.join(source))# 运行备份print('Zip command is:')print(zip_command)print('Running:')if os.system(zip_command) == 0: print('Successful backup to', target)else: print('Backup FAILED') 输出结果 1 file, 10 bytes (1 KiB) Creating archive: E:\Backup\\20180722160831.zip Add new data to archive: 1 file, 10 bytes (1 KiB) Files read from disk: 1 Archive size: 158 bytes (1 KiB) Everything is Ok Successful backup to E:\Backup\\20180722160831.zip]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的集合]]></title>
    <url>%2F2018%2F07%2F07%2Fpython%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[集合集合（Set）是简单对象的无序集合（Collection）。当集合中的项目存在与否比起次序或其出现次数更加重要时，我们就会使用集合。通过使用集合，你可以测试某些对象的资格或情况，检查它们是否是其它集合的子集，找到两个集合的交集，等等。 代码12345678910111213# 集合 判断子集bri = set(['brazil', 'russia', 'india'])if 'india' in bri: print('True')if 'usa' in bri: print('False')bric = bri.copy()bric.add('china')print(bric.issuperset(bri))bri.remove('russia')print(bri &amp; bric) 输出结果TrueTrue{‘india’, ‘brazil’}]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中字典（key-value）]]></title>
    <url>%2F2018%2F07%2F07%2Fpython%E4%B8%AD%E5%AD%97%E5%85%B8%EF%BC%88key-value%EF%BC%89%2F</url>
    <content type="text"><![CDATA[字典（key-value）字典就像一本地址簿，如果你知道了他或她的姓名，你就可以在这里找到其地址或是能够联系上对方的更多详细信息，换言之，我们将键值（Keys）（即姓名）与值（Values）（即地址等详细信息）联立到一起。在这里要注意到键值必须是唯一的，正如在现实中面对两个完全同名的人你没办法找出有关他们的正确信息。 代码123456789101112131415161718192021222324252627# 字典# "ab"是地址（Address）薄(Book)的缩写ab = &#123; 'Swaroop': 'swaroop@swaroopch.com', 'Larry': 'larry@wall.org', 'Matsumoto': 'matz@ruby-lang.org', 'Spammer': 'spammer@hptmail.com'&#125;print("Swaroop's address is", ab['Swaroop'])# 删除一对键值-值配对del ab['Spammer']print('\nThere are &#123;&#125; contacts in the address-book\n'.format(len(ab)))#我们通过使用字典的 item 方法来访问字典中的每一对键值—值配对信息，这一操作将返回一份包含元组的列表for name, address in ab.items(): print('Contact &#123;&#125; at &#123;&#125;'.format(name, address))# 添加一对键值-值配对ab['Guido'] = 'guido@python.org'if 'Guido' in ab: print("\nGuido's address is", ab['Guido'])]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的列表]]></title>
    <url>%2F2018%2F07%2F07%2Fpython%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[列表列表 是一种用于保存一系列有序项目的集合，也就是说，你可以利用列表保存一串项目的序列。想象起来也不难，你可以想象你有一张购物清单，上面列出了需要购买的商品，除开在购物清单上你可能为每件物品都单独列一行，在 Python 中你需要在它们之间多加上一个逗号。 代码123456789101112131415161718192021222324252627# 列表# This is my shopping list'''在这里要注意在调用 print 函数时我们使用 end 参数，这样就能通过一个空格来结束输出工作，而不是通常的换行。'''shoplist = ['apple', 'mango', 'carrot', 'banana']print('I have', len(shoplist), 'items to purchase')print('These item are:', end=' ')for item in shoplist: print(item, end=' ')print('\nI also have to buy rice.')shoplist.append('rice')print('My shopping list is now', shoplist)print('I will sort my list now')shoplist.sort()print('Sorted shopping list is', shoplist)print('The first item I will buy is', shoplist[0])olditem = shoplist[0]del shoplist[0]print('I bought the', olditem)print('My shopping list is now', shoplist)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的元组]]></title>
    <url>%2F2018%2F07%2F07%2Fpython%E4%B8%AD%E7%9A%84%E5%85%83%E7%BB%84%2F</url>
    <content type="text"><![CDATA[元组元组（Tuple）用于将多个对象保存到一起。你可以将它们近似地看作列表，但是元组不能提供列表类能够提供给你的广泛的功能。元组的一大特征类似于字符串，它们是不可变的，也就是说，你不能编辑或更改元组。元组是通过特别指定项目来定义的，在指定项目时，你可以给它们加上括号，并在括号内部用逗号进行分隔。元组通常用于保证某一语句或某一用户定义的函数可以安全地采用一组数值，意即元组内的数值不会改变。 代码123456789101112131415# 元组'''推荐使用括号来指明元组的开始和结束尽管括号是一个可选选项明了胜过晦涩，显式优于隐式'''zoo = ('python', 'elephant', 'penguin')print('Number of animals in the zoo is', len(zoo))new_zoo = 'monkey', 'camel', zooprint('Number of animals in the zoo is', len(new_zoo))print('All animals in new zoo are', new_zoo)print('Animals brought from old zoo are', new_zoo[2])print('Last animal brought from old zoo is', new_zoo[2][2])print('Number of animals in the new zoo is', len(new_zoo) - 1 + len(new_zoo[2]))]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的序列以及切片的解释]]></title>
    <url>%2F2018%2F07%2F07%2Fpython%E4%B8%AD%E7%9A%84%E5%BA%8F%E5%88%97%E4%BB%A5%E5%8F%8A%E5%88%87%E7%89%87%E7%9A%84%E8%A7%A3%E9%87%8A%2F</url>
    <content type="text"><![CDATA[python中的序列以及切片的解释切片：有一种切片（Slicing）运算符，它能够允许我们序列中的某段切片——也就是序列之中的一部分。 序列1234567891011121314151617181920212223242526272829303132333435# 序列 跑一下看看shoplist = ['apple', 'mango', 'carrot', 'banana']name = 'swaroop'# Indexing or 'Subscription' operation ## 索引或“下标（Subcription）”操作符 #print('Item 0 is', shoplist[0])print('Item 1 is', shoplist[1])print('Item 2 is', shoplist[2])print('Item 3 is', shoplist[3])print('Item -1 is', shoplist[-1])print('Item -2 is', shoplist[-2])print('Character 0 is', name[0])# Slicing on a list #print('Item 1 to 3 is', shoplist[1:3])print('Item 2 to end is', shoplist[2:])print('Item 1 to -1 is', shoplist[1:-1])print('Item start to end is', shoplist[:])# 从某一字符串中切片 #print('characters 1 to 3 is', name[1:3])print('characters 2 to end is', name[2:])print('characters 1 to -1 is', name[1:-1])print('characters start to end is', name[:])'''你会注意到当步长为 2 时，我们得到的是第 0、2、4…… 位项目。当步长为 3 时，我们得到的是第 0、3……位项目。'''print(shoplist[::1])print(shoplist[::2])print(shoplist[::3])print(shoplist[::-1])]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中字符串的一些基本操作]]></title>
    <url>%2F2018%2F07%2F07%2Fpython%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[python字符串的一些基本操作在这里，我们会看见一此操作中包含了好多字符串方法。 startwith 方法用于查找字符串是否以给定的字符串内容开头。 in 运算符用以检查给定的字符串是否是查询的字符串中的一部分。find 方法用于定位字符串中给定的子字符串的位置。如果找不到相应的子字符串， find会返回 -1。 str 类同样还拥有一个简洁的方法用以 联结（Join） 序列中的项目，其中字符串将会作为每一项目之间的分隔符，并以此生成并返回一串更大的字符串。 123456789101112131415# 这是一个字符串对象name = 'Swaroop'if name.startswith('Swa'): print('Yes, the string starts with "Swa"')if 'a' in name: print('Yes, it contains the string "a"')if name.find('war') != -1: print('Yes,it contains the string "war"')delimiter = '_*_'mylist = ['Brazil', 'Russia', 'India', 'China']print(delimiter.join(mylist))]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的引用和切片]]></title>
    <url>%2F2018%2F07%2F07%2Fpython%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8%E5%92%8C%E5%88%87%E7%89%87%2F</url>
    <content type="text"><![CDATA[引用和切片造成的不同影响当你创建了一个对象并将其分配给某个变量时，变量只会查阅（Refer）某个对象，并且它也不会代表对象本身。也就是说，变量名只是指向你计算机内存中存储了相应对象的那一部分。这叫作将名称绑定（Binding）给那一个对象。一般来说，你不需要去关心这个，不过由于这一引用操作困难会产生某些微妙的效果，这是需要你注意的： 123456789101112131415161718192021222324252627'''如果直接引用对象的话，对mylist操作也会影响到原本的shoplist如果想要不影响原本的，必须引用的是对象的切片，切片即为副本'''print('Simple Assignment')shoplist = ['apple', 'mango', 'carrot', 'banana']# mylist 只是指向同一对象的另一种名称mylist = shoplist# 我购买了第一项项目，所以我将其从列表中删除del shoplist[0]print('shoplist is', shoplist)print('mylist is', mylist)# 注意到 shoplist 和 mylist 二者都# 打印出了其中都没有 apple 的同样的列表，以此我们确认# 它们指向的是同一个对象print('Copy by making a full slice')# 通过生成一份完整的切片制作一份列表的副本mylist = shoplist[:]# 删除第一个项目del mylist[0]print('shoplist is', shoplist)print('mylist is', mylist)# 注意到现在两份列表已出现不同]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的Docstring]]></title>
    <url>%2F2018%2F06%2F27%2Fpython%E4%B8%AD%E7%9A%84Docstring%2F</url>
    <content type="text"><![CDATA[基本教程1234567891011121314151617181920212223242526'''文档字符串的应用该文档字符串所约定的是一串多行字符串，其中第一行以某一大写字母开始，以句号结束。第二行为空行，后跟的第三行开始是任何详细的解释说明。 在此强烈建议你在有关你所有非凡功能的文档字符串中都遵循这一约定。'''def print_max(x, y): '''Prints the maximum of two numbers.打印两个数值中的最大数。 The two values must be integers.这两个数都应该是整数 ''' # 如果可能，将其转换至整数类型 x = int(x) y = int(y) if x &gt; y: print(x, 'is maximum') else: print(y, 'is maximum')print_max(3, 5)print(print_max.__doc__)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大公约数和最小公倍数]]></title>
    <url>%2F2018%2F04%2F10%2F%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[使用的辗转相除法辗转相除法：辗转相除法是求两个自然数的最大公约数的一种方法，也叫欧几里德算法。 例如，求（319，377）： ∵ 319÷377=0（余319） ∴（319，377）=（377，319）； ∵ 377÷319=1（余58） ∴（377，319）=（319，58）； ∵ 319÷58=5（余29） ∴ （319，58）=（58，29）； ∵ 58÷29=2（余0） ∴ （58，29）= 29； ∴ （319，377）=29。 可以写成右边的格式。 用辗转相除法求几个数的最大公约数，可以先求出其中任意两个数的最大公约数，再求这个最大公约数与第三个数的最大公约数，依次求下去，直到最后一个数为止。最后所得的那个最大公约数，就是所有这些数的最大公约数。 代码 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;int main() &#123; int maxgongyue(int x,int y); int mingongbei(int num,int finax); int x,y,num; printf("请输入俩个数:\n"); scanf("%d %d",&amp;x,&amp;y); num=x*y; printf("最大公约数是:%d\n",maxgongyue(x,y)); printf("最小公倍数是:%d\n",mingongbei(num,maxgongyue(x,y))); return 0;&#125;int maxgongyue(int x,int y)&#123; int temp,yushu; if(x&lt;y) &#123; //交换成大的在前，小的在后 temp=x; x=y; y=temp; &#125; while(y!=0) &#123; //辗转相除法，如果余数不为0，则循环 yushu=x%y; //求余数 x=y; //将小的赋值给大的 y=yushu; //将余数赋值给小的 &#125;//一直除到余数为0时，这时候的x就是最大公约数 return(x);&#125;int mingongbei(int num,int finax)&#123; return(num/finax);&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折半查找]]></title>
    <url>%2F2018%2F04%2F10%2F%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[折半查找定义二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列 查找过程首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。 比较次数 当顺序表有n个关键字时： 查找失败时，至少比较a次关键字；查找成功时，最多比较关键字次数是b。 注意：a,b,n均为正整数。 算法复杂度折半查找法也称为二分查找法，它充分利用了元素间的次序关系，采用分治策略，可在最坏的情况下用O(log n)完成搜索任务。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;stdio.h&gt;#define N 5//折半查找算法int main() &#123; int a[N],i,j,low=0,high=N-1,mid,flag,num; printf("请输入5个数:\n"); scanf("%d",&amp;a[0]); i=1; //升序输入 while(i&lt;N) &#123; scanf("%d",&amp;a[i]); if(a[i]&gt;=a[i-1]) &#123; i++; &#125; else &#123; printf("重新输入数据:\n"); &#125; &#125; printf("\n"); for(i=0; i&lt;N; i++) &#123; printf("%5d",a[i]); &#125; printf("\n请输入你要查询的数字:\n"); scanf("%d",&amp;num); if((num&lt;a[0])||(num&gt;a[N-1])) &#123; printf("该数不在区间范围内\n"); &#125; while(low&lt;=high) &#123; mid = (low + high)/2; if(num==a[mid])&#123; flag=mid; //记录这个数的位置 printf("找到了%d,这个数在第%d号位置",num,flag+1); break; &#125; else if (num &gt; a[mid]) &#123; low = mid+1; &#125; else if (num &lt; a[mid]) &#123; high = mid - 1; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[任意行数的杨辉三角形（动态分配）]]></title>
    <url>%2F2018%2F04%2F10%2F%E4%BB%BB%E6%84%8F%E8%A1%8C%E6%95%B0%E7%9A%84%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%88%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%EF%BC%89%2F</url>
    <content type="text"><![CDATA[杨辉三角形金字塔型和直角三角形 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main() &#123; int i,j,num; int **a; printf("请输入你想打印的杨辉三角形行数:\n"); scanf("%d",&amp;num); a=(int **)malloc(num*sizeof(int *)); for (i = 0; i &lt; num; ++i) &#123; //为每列分配num个大小空间 a[i] = (int*)malloc(sizeof(int)*num); &#125; //书上分开打印// for(i=0; i&lt;num; i++) &#123;// a[i][i]=1;// a[i][0]=1;// &#125;// for(i=2; i&lt;num; i++) &#123;// for(j=1; j&lt;=i-1; j++) &#123;// a[i][j]=a[i-1][j-1]+a[i-1][j];// &#125;// &#125;// for(i=0;i&lt;num;i++)&#123;// for(j=0;j&lt;=i;j++)&#123;// printf("%4d",a[i][j]);// &#125;// printf("\n");// &#125;// printf("\n"); //优化 for(i=0; i&lt;num; i++) &#123; for(j=0; j&lt;=i; j++) &#123;// if(i==0||j==0||j==i) &#123;// a[i][j]=1;// &#125; else &#123;// a[i][j]=a[i-1][j-1]+a[i-1][j];// &#125; printf("%4d",(a[i][j])=(i==0||j==0||j==i)?1:a[i-1][j-1]+a[i-1][j]); &#125; printf("\n"); &#125;// for(i=0; i&lt;num; i++) &#123;// for(j=0; j&lt;=i; j++) &#123;// printf("%4d",a[i][j]);// &#125;// printf("\n");// &#125; for (i = 0; i &lt; num; i++) &#123; free(a[i]); &#125; free(a); printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F2018%2F04%2F10%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序概念冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。 它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名“冒泡排序”。 算法原理冒泡排序算法的运作如下：（从后往前） 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 时间复杂度冒泡排序总的平均时间复杂度为 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;int main()&#123; void sort(int *x,int n); int i,*p,a[10]; p=a; printf("请输入10个整数:\n"); for(i=0;i&lt;10;i++)&#123; scanf("%d",p++); &#125; p=a; sort(p,10); for(p=a,i=0;i&lt;10;i++)&#123; printf("%d ",*p++); &#125; printf("\n"); return 0;&#125;//数组形式 void sort(int x[],int n)&#123; int i,j,temp; for(i=0;i&lt;n-1;i++) for(j=0;j&lt;n-1-i;j++)&#123; if(x[j]&lt;x[j+1])&#123; temp=x[j]; x[j]=x[j+1]; x[j+1]=temp; &#125; &#125;&#125;//指针形式 void sort(int *x,int n)&#123; int i,j,temp; for(i=0;i&lt;n-1;i++) for(j=0;j&lt;n-1-i;j++)&#123; if(*(x+j)&lt;*(x+j+1))&#123; //*(x+j)就是x[j] temp=*(x+j); *(x+j)=*(x+j+1); *(x+j+1)=temp; &#125; &#125;&#125; ​]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[整合建立输出增删改查的链表]]></title>
    <url>%2F2018%2F04%2F08%2F%E6%95%B4%E5%90%88%E5%BB%BA%E7%AB%8B%E8%BE%93%E5%87%BA%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E7%9A%84%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[简单贴一下链表的建立等常用操作 链表定义链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define LEN sizeof(struct Student)//输入格式 1 89// 2 99// 0 0struct Student &#123; long num; float score; struct Student *next;&#125;;int n;struct Student *creat();struct Student *del(struct Student *head,long num);struct Student *insert(struct Student *head,struct Student *stu);void print(struct Student *head);int main() &#123; struct Student *head,*stu; long del_num; printf("请输入数据:\n"); head=creat(); print(head); printf("请输入要删除的数字:\n"); scanf("%ld",&amp;del_num); while(del_num!=0) &#123; //当输入的学号为0时结束循环 head=del(head,del_num); //删除结点后返回链表的头地址 print(head); //输出全部结点 printf("请输入要删除的数字:\n"); scanf("%ld",&amp;del_num); &#125; printf("请输入要添加的数据:\n"); stu=(struct Student *)malloc(LEN); //开辟一个新结点 scanf("%ld %f",&amp;stu-&gt;num,&amp;stu-&gt;score); while(stu-&gt;num!=0) &#123; //当输入的学号为0时结束循环 head=insert(head,stu); //返回链表的头地址，赋值给head print(head); //输出全部结点 printf("请输入要添加的数据:\n"); stu=(struct Student *)malloc(LEN); //开辟一个新结点 scanf("%ld %f",&amp;stu-&gt;num,&amp;stu-&gt;score); &#125; return 0;&#125;struct Student *creat(void) &#123; //返回一个指向链表头的指针 struct Student *head; struct Student *p1,*p2; n=0; p1=p2=(struct Student *)malloc(LEN);//开辟一个新的结点使p1，p2指向它 scanf("%ld %f",&amp;p1-&gt;num,&amp;p1-&gt;score);//输入第1个学生的学号和成绩 head=NULL; while(p1-&gt;num!=0) &#123; n=n+1; if(n==1) &#123; //如果这个结点是头结点，那么就把head指向p1 head=p1; &#125; else &#123; p2-&gt;next=p1; //如果不是，则使这个结点的next指向新开辟结点 &#125; p2=p1; //使p2指向刚才建立的结点 p1=(struct Student *)malloc(LEN);//生成新的结点 ，使p1指向它 scanf("%ld %f",&amp;p1-&gt;num,&amp;p1-&gt;score); &#125; p2-&gt;next=NULL; //当p2是表尾时，把NULL赋值给next，结束链表建立 return(head);&#125;void print(struct Student *head) &#123; struct Student *p; printf("\nNow,These %d records are:\n",n); p=head; if(head!=NULL) &#123; do &#123; printf("%ld %5.1f\n",p-&gt;num,p-&gt;score); p=p-&gt;next; &#125; while(p!=NULL); &#125;&#125;struct Student *insert(struct Student *head,struct Student *stu) &#123; struct Student *p0,*p1,*p2; p1=head; //使p1指向头结点 p0=stu; //指向要插入的结点 if(head==NULL) &#123; //原来的链表是空表 head=p0; p0-&gt;next=NULL; &#125; else &#123; while((p0-&gt;num&gt;p1-&gt;num)&amp;&amp;(p1-&gt;next!=NULL)) &#123; p2=p1; //使p2指向刚才p1指向的结点 p1=p1-&gt;next;//p1后移一个结点 &#125; if(p0-&gt;num&lt;p1-&gt;num) &#123; if(head==p1) &#123; head=p0; //插到原来第1个结点之前 &#125; else &#123; p2-&gt;next=p0;//插到p2指向的结点之后 p0-&gt;next=p1; &#125; &#125; else &#123; p1-&gt;next=p0; p0-&gt;next=NULL; //插到最后的结点之后 &#125; &#125; n=n+1; return(head); //结点数+1&#125;struct Student *del(struct Student *head,long num) &#123; struct Student *p1,*p2; if(head==NULL) &#123; printf("这是一张空表\n"); return(head); &#125; p1=head; //使p1指向第1个结点 while(num!=p1-&gt;num&amp;&amp;p1-&gt;next!=NULL) &#123; //p1指向的不是所要找的结点且后面还有结点 p2=p1; p1=p1-&gt;next; //p1向后移一个结点 &#125; if(num==p1-&gt;num) &#123; //找到了 if(p1==head) &#123; //若p1指向的是首结点，把第2个结点地址赋予head head=p1-&gt;next; &#125; else &#123; //否则将下一个结点地址赋给前一结点地址 p2-&gt;next=p1-&gt;next; &#125; printf("删除:%ld\n",num); n=n-1; &#125; else &#123; printf("%ld没有找到\n",num);//找不到该结点 &#125; return(head);&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择排序]]></title>
    <url>%2F2018%2F04%2F08%2F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[简单的写一下选择排序的源代码定义选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法（比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，导致第一个5挪动到第二个5后面）。 时间复杂度选择排序的交换操作介于 0 和 (n - 1） 次之间。选择排序的比较操作为 n (n - 1） / 2 次之间。选择排序的赋值操作介于 0 和 3 (n - 1） 次之间。 比较次数O(n^2），比较次数与关键字的初始状态无关，总的比较次数N=(n-1）+(n-2）+…+1=n*(n-1）/2。交换次数O(n），最好情况是，已经有序，交换0次；最坏情况交换n-1次，逆序交换n/2次。交换次数比冒泡排序少多了，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快 参考代码 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;//选择排序 int main() &#123; void selectsort(int array[],int n); int a[10],i; printf("输入10个数:\n"); for(i=0; i&lt;10; i++) &#123; scanf("%d",&amp;a[i]); &#125; selectsort(a,10); printf("选择排序之后:\n"); for(i=0; i&lt;10; i++) &#123; printf("%d ",a[i]); &#125; printf("\n"); return 0;&#125;void selectsort(int array[],int n) &#123; int i,j,min,temp; for(i=0; i&lt;n-1; i++) &#123; min=i; for(j=i+1; j&lt;n; j++)&#123; if(array[j]&lt;array[min]) min=j; &#125; temp=array[min]; array[min]=array[i]; array[i]=temp; &#125;&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博客测试]]></title>
    <url>%2F2018%2F04%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[这是我的第一篇博客= =，成功搭建了本网站地址 第一级标题生成一个hexo博客1$ hexo new "My New Post" 更多的信息: Writing 在本地跑起来1$ hexo server 更多的信息: Server 生成静态文件（保存） 1$ hexo generate 更多的信息: Generating 上传到github1$ hexo deploy 更多的信息: Deployment]]></content>
      <categories>
        <category>博客测试文件</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
</search>
