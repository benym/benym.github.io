<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[利用python进行文件的自动备份]]></title>
    <url>%2F2018%2F07%2F22%2F%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD%2F</url>
    <content type="text"><![CDATA[利用Python进行文件的自动备份os.system 函数的命令，这一函数可以使命令像是从系统中运行的。也就是说，从 shell 中运行的——如果运行成功，它将返回 0 ，如果运行失败，将返回一个错误代码。 针对 Windows 用户的提示除了使用双反斜杠转义序列，你还可以使用原始字符串。例如使用 ‘C:\Documents’ 或r’C:\Documents’ 。然而，不要使用 ‘C:\Documents’ ，因为它将被识别为你使用了一个未知的转义序列 \D 来结束路径的输入。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243import osimport time# 1. 需要备份的文件与目录将被# 指定在一个列表中。# 例如在 Windows 下：source = [r'E:\aaa.txt']# 在这里要注意到我们必须在字符串中使用双引号# 用以括起其中包含空格的名称。# 2. 备份文件必须存储在一个# 主备份目录中# 例如在 Windows 下：target_dir = 'E:\\Backup\\'# 要记得将这里的目录地址修改至你将使用的路径# 3.备份文件将打包压缩成zip文件# 4.zip压缩文件的文件名由当前日期与时间构成# 其中os.sep 表示更改操作系统中的路径分隔符target = target_dir + os.sep + \ time.strftime('%Y%m%d%H%M%S') + '.zip'# 如果目标目录还不存在，则进行创建if not os.path.exists(target_dir): os.mkdir(target_dir) # 创建目录# 5.原本这里是使用zip命令，但是在windows环境下面这个是不是系统命令，所以解决方案如下：'''1.1.下载7-Zip并安装2.将安装文件中的7z.exe移至‘C:\Windows’目录下3.将程序中的 zip_command = "zip -qr '%s' %s"%(target,''.join(source))改为：zip_command = "7z a %s %s"%(target, ' '.join(source))'''zip_command = "7z a %s %s" % (target, ' '.join(source))# 运行备份print('Zip command is:')print(zip_command)print('Running:')if os.system(zip_command) == 0: print('Successful backup to', target)else: print('Backup FAILED') 输出结果 1 file, 10 bytes (1 KiB) Creating archive: E:\Backup\20180722160831.zip Add new data to archive: 1 file, 10 bytes (1 KiB) Files read from disk: 1 Archive size: 158 bytes (1 KiB) Everything is Ok Successful backup to E:\Backup\20180722160831.zip]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择排序]]></title>
    <url>%2F2018%2F07%2F22%2F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[简单的写一下选择排序的源代码定义选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法（比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，导致第一个5挪动到第二个5后面）。 时间复杂度选择排序的交换操作介于 0 和 (n - 1） 次之间。选择排序的比较操作为 n (n - 1） / 2 次之间。选择排序的赋值操作介于 0 和 3 (n - 1） 次之间。 比较次数O(n^2），比较次数与关键字的初始状态无关，总的比较次数N=(n-1）+(n-2）+…+1=n*(n-1）/2。交换次数O(n），最好情况是，已经有序，交换0次；最坏情况交换n-1次，逆序交换n/2次。交换次数比冒泡排序少多了，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快 参考代码 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;//选择排序 int main() &#123; void selectsort(int array[],int n); int a[10],i; printf("输入10个数:\n"); for(i=0; i&lt;10; i++) &#123; scanf("%d",&amp;a[i]); &#125; selectsort(a,10); printf("选择排序之后:\n"); for(i=0; i&lt;10; i++) &#123; printf("%d ",a[i]); &#125; printf("\n"); return 0;&#125;void selectsort(int array[],int n) &#123; int i,j,min,temp; for(i=0; i&lt;n-1; i++) &#123; min=i; for(j=i+1; j&lt;n; j++)&#123; if(array[j]&lt;array[min]) min=j; &#125; temp=array[min]; array[min]=array[i]; array[i]=temp; &#125;&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大公约数和最小公倍数]]></title>
    <url>%2F2018%2F07%2F22%2F%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[使用的辗转相除法辗转相除法：辗转相除法是求两个自然数的最大公约数的一种方法，也叫欧几里德算法。 例如，求（319，377）： ∵ 319÷377=0（余319） ∴（319，377）=（377，319）； ∵ 377÷319=1（余58） ∴（377，319）=（319，58）； ∵ 319÷58=5（余29） ∴ （319，58）=（58，29）； ∵ 58÷29=2（余0） ∴ （58，29）= 29； ∴ （319，377）=29。 可以写成右边的格式。 用辗转相除法求几个数的最大公约数，可以先求出其中任意两个数的最大公约数，再求这个最大公约数与第三个数的最大公约数，依次求下去，直到最后一个数为止。最后所得的那个最大公约数，就是所有这些数的最大公约数。 代码 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;int main() &#123; int maxgongyue(int x,int y); int mingongbei(int num,int finax); int x,y,num; printf("请输入俩个数:\n"); scanf("%d %d",&amp;x,&amp;y); num=x*y; printf("最大公约数是:%d\n",maxgongyue(x,y)); printf("最小公倍数是:%d\n",mingongbei(num,maxgongyue(x,y))); return 0;&#125;int maxgongyue(int x,int y)&#123; int temp,yushu; if(x&lt;y) &#123; //交换成大的在前，小的在后 temp=x; x=y; y=temp; &#125; while(y!=0) &#123; //辗转相除法，如果余数不为0，则循环 yushu=x%y; //求余数 x=y; //将小的赋值给大的 y=yushu; //将余数赋值给小的 &#125;//一直除到余数为0时，这时候的x就是最大公约数 return(x);&#125;int mingongbei(int num,int finax)&#123; return(num/finax);&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>经典算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[整合建立输出增删改查的链表]]></title>
    <url>%2F2018%2F07%2F22%2F%E6%95%B4%E5%90%88%E5%BB%BA%E7%AB%8B%E8%BE%93%E5%87%BA%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E7%9A%84%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[简单贴一下链表的建立等常用操作 链表定义链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define LEN sizeof(struct Student)//输入格式 1 89// 2 99// 0 0struct Student &#123; long num; float score; struct Student *next;&#125;;int n;struct Student *creat();struct Student *del(struct Student *head,long num);struct Student *insert(struct Student *head,struct Student *stu);void print(struct Student *head);int main() &#123; struct Student *head,*stu; long del_num; printf("请输入数据:\n"); head=creat(); print(head); printf("请输入要删除的数字:\n"); scanf("%ld",&amp;del_num); while(del_num!=0) &#123; //当输入的学号为0时结束循环 head=del(head,del_num); //删除结点后返回链表的头地址 print(head); //输出全部结点 printf("请输入要删除的数字:\n"); scanf("%ld",&amp;del_num); &#125; printf("请输入要添加的数据:\n"); stu=(struct Student *)malloc(LEN); //开辟一个新结点 scanf("%ld %f",&amp;stu-&gt;num,&amp;stu-&gt;score); while(stu-&gt;num!=0) &#123; //当输入的学号为0时结束循环 head=insert(head,stu); //返回链表的头地址，赋值给head print(head); //输出全部结点 printf("请输入要添加的数据:\n"); stu=(struct Student *)malloc(LEN); //开辟一个新结点 scanf("%ld %f",&amp;stu-&gt;num,&amp;stu-&gt;score); &#125; return 0;&#125;struct Student *creat(void) &#123; //返回一个指向链表头的指针 struct Student *head; struct Student *p1,*p2; n=0; p1=p2=(struct Student *)malloc(LEN);//开辟一个新的结点使p1，p2指向它 scanf("%ld %f",&amp;p1-&gt;num,&amp;p1-&gt;score);//输入第1个学生的学号和成绩 head=NULL; while(p1-&gt;num!=0) &#123; n=n+1; if(n==1) &#123; //如果这个结点是头结点，那么就把head指向p1 head=p1; &#125; else &#123; p2-&gt;next=p1; //如果不是，则使这个结点的next指向新开辟结点 &#125; p2=p1; //使p2指向刚才建立的结点 p1=(struct Student *)malloc(LEN);//生成新的结点 ，使p1指向它 scanf("%ld %f",&amp;p1-&gt;num,&amp;p1-&gt;score); &#125; p2-&gt;next=NULL; //当p2是表尾时，把NULL赋值给next，结束链表建立 return(head);&#125;void print(struct Student *head) &#123; struct Student *p; printf("\nNow,These %d records are:\n",n); p=head; if(head!=NULL) &#123; do &#123; printf("%ld %5.1f\n",p-&gt;num,p-&gt;score); p=p-&gt;next; &#125; while(p!=NULL); &#125;&#125;struct Student *insert(struct Student *head,struct Student *stu) &#123; struct Student *p0,*p1,*p2; p1=head; //使p1指向头结点 p0=stu; //指向要插入的结点 if(head==NULL) &#123; //原来的链表是空表 head=p0; p0-&gt;next=NULL; &#125; else &#123; while((p0-&gt;num&gt;p1-&gt;num)&amp;&amp;(p1-&gt;next!=NULL)) &#123; p2=p1; //使p2指向刚才p1指向的结点 p1=p1-&gt;next;//p1后移一个结点 &#125; if(p0-&gt;num&lt;p1-&gt;num) &#123; if(head==p1) &#123; head=p0; //插到原来第1个结点之前 &#125; else &#123; p2-&gt;next=p0;//插到p2指向的结点之后 p0-&gt;next=p1; &#125; &#125; else &#123; p1-&gt;next=p0; p0-&gt;next=NULL; //插到最后的结点之后 &#125; &#125; n=n+1; return(head); //结点数+1&#125;struct Student *del(struct Student *head,long num) &#123; struct Student *p1,*p2; if(head==NULL) &#123; printf("这是一张空表\n"); return(head); &#125; p1=head; //使p1指向第1个结点 while(num!=p1-&gt;num&amp;&amp;p1-&gt;next!=NULL) &#123; //p1指向的不是所要找的结点且后面还有结点 p2=p1; p1=p1-&gt;next; //p1向后移一个结点 &#125; if(num==p1-&gt;num) &#123; //找到了 if(p1==head) &#123; //若p1指向的是首结点，把第2个结点地址赋予head head=p1-&gt;next; &#125; else &#123; //否则将下一个结点地址赋给前一结点地址 p2-&gt;next=p1-&gt;next; &#125; printf("删除:%ld\n",num); n=n-1; &#125; else &#123; printf("%ld没有找到\n",num);//找不到该结点 &#125; return(head);&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>链表算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折半查找]]></title>
    <url>%2F2018%2F07%2F22%2F%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[折半查找定义二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列 查找过程首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。 比较次数 当顺序表有n个关键字时： 查找失败时，至少比较a次关键字；查找成功时，最多比较关键字次数是b。 注意：a,b,n均为正整数。 算法复杂度折半查找法也称为二分查找法，它充分利用了元素间的次序关系，采用分治策略，可在最坏的情况下用O(log n)完成搜索任务。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;stdio.h&gt;#define N 5//折半查找算法int main() &#123; int a[N],i,j,low=0,high=N-1,mid,flag,num; printf("请输入5个数:\n"); scanf("%d",&amp;a[0]); i=1; //升序输入 while(i&lt;N) &#123; scanf("%d",&amp;a[i]); if(a[i]&gt;=a[i-1]) &#123; i++; &#125; else &#123; printf("重新输入数据:\n"); &#125; &#125; printf("\n"); for(i=0; i&lt;N; i++) &#123; printf("%5d",a[i]); &#125; printf("\n请输入你要查询的数字:\n"); scanf("%d",&amp;num); if((num&lt;a[0])||(num&gt;a[N-1])) &#123; printf("该数不在区间范围内\n"); &#125; while(low&lt;=high) &#123; mid = (low + high)/2; if(num==a[mid])&#123; flag=mid; //记录这个数的位置 printf("找到了%d,这个数在第%d号位置",num,flag+1); break; &#125; else if (num &gt; a[mid]) &#123; low = mid+1; &#125; else if (num &lt; a[mid]) &#123; high = mid - 1; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>经典算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F2018%2F07%2F22%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序概念冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。 它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名“冒泡排序”。 算法原理冒泡排序算法的运作如下：（从后往前） 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 时间复杂度冒泡排序总的平均时间复杂度为 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;int main()&#123; void sort(int *x,int n); int i,*p,a[10]; p=a; printf("请输入10个整数:\n"); for(i=0;i&lt;10;i++)&#123; scanf("%d",p++); &#125; p=a; sort(p,10); for(p=a,i=0;i&lt;10;i++)&#123; printf("%d ",*p++); &#125; printf("\n"); return 0;&#125;//数组形式 void sort(int x[],int n)&#123; int i,j,temp; for(i=0;i&lt;n-1;i++) for(j=0;j&lt;n-1-i;j++)&#123; if(x[j]&lt;x[j+1])&#123; temp=x[j]; x[j]=x[j+1]; x[j+1]=temp; &#125; &#125;&#125;//指针形式 void sort(int *x,int n)&#123; int i,j,temp; for(i=0;i&lt;n-1;i++) for(j=0;j&lt;n-1-i;j++)&#123; if(*(x+j)&lt;*(x+j+1))&#123; //*(x+j)就是x[j] temp=*(x+j); *(x+j)=*(x+j+1); *(x+j+1)=temp; &#125; &#125;&#125; ​]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[任意行数的杨辉三角形（动态分配）]]></title>
    <url>%2F2018%2F07%2F22%2F%E4%BB%BB%E6%84%8F%E8%A1%8C%E6%95%B0%E7%9A%84%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%88%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%EF%BC%89%2F</url>
    <content type="text"><![CDATA[杨辉三角形金字塔型和直角三角形 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main() &#123; int i,j,num; int **a; printf("请输入你想打印的杨辉三角形行数:\n"); scanf("%d",&amp;num); a=(int **)malloc(num*sizeof(int *)); for (i = 0; i &lt; num; ++i) &#123; //为每列分配num个大小空间 a[i] = (int*)malloc(sizeof(int)*num); &#125; //书上分开打印// for(i=0; i&lt;num; i++) &#123;// a[i][i]=1;// a[i][0]=1;// &#125;// for(i=2; i&lt;num; i++) &#123;// for(j=1; j&lt;=i-1; j++) &#123;// a[i][j]=a[i-1][j-1]+a[i-1][j];// &#125;// &#125;// for(i=0;i&lt;num;i++)&#123;// for(j=0;j&lt;=i;j++)&#123;// printf("%4d",a[i][j]);// &#125;// printf("\n");// &#125;// printf("\n"); //优化 for(i=0; i&lt;num; i++) &#123; for(j=0; j&lt;=i; j++) &#123;// if(i==0||j==0||j==i) &#123;// a[i][j]=1;// &#125; else &#123;// a[i][j]=a[i-1][j-1]+a[i-1][j];// &#125; printf("%4d",(a[i][j])=(i==0||j==0||j==i)?1:a[i-1][j-1]+a[i-1][j]); &#125; printf("\n"); &#125;// for(i=0; i&lt;num; i++) &#123;// for(j=0; j&lt;=i; j++) &#123;// printf("%4d",a[i][j]);// &#125;// printf("\n");// &#125; for (i = 0; i &lt; num; i++) &#123; free(a[i]); &#125; free(a); printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>经典算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的集合]]></title>
    <url>%2F2018%2F07%2F22%2Fpython%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[集合集合（Set）是简单对象的无序集合（Collection）。当集合中的项目存在与否比起次序或其出现次数更加重要时，我们就会使用集合。通过使用集合，你可以测试某些对象的资格或情况，检查它们是否是其它集合的子集，找到两个集合的交集，等等。 代码12345678910111213# 集合 判断子集bri = set(['brazil', 'russia', 'india'])if 'india' in bri: print('True')if 'usa' in bri: print('False')bric = bri.copy()bric.add('china')print(bric.issuperset(bri))bri.remove('russia')print(bri &amp; bric) 输出结果TrueTrue{‘india’, ‘brazil’}]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的引用和切片]]></title>
    <url>%2F2018%2F07%2F22%2Fpython%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8%E5%92%8C%E5%88%87%E7%89%87%2F</url>
    <content type="text"><![CDATA[引用和切片造成的不同影响当你创建了一个对象并将其分配给某个变量时，变量只会查阅（Refer）某个对象，并且它也不会代表对象本身。也就是说，变量名只是指向你计算机内存中存储了相应对象的那一部分。这叫作将名称绑定（Binding）给那一个对象。一般来说，你不需要去关心这个，不过由于这一引用操作困难会产生某些微妙的效果，这是需要你注意的： 123456789101112131415161718192021222324252627'''如果直接引用对象的话，对mylist操作也会影响到原本的shoplist如果想要不影响原本的，必须引用的是对象的切片，切片即为副本'''print('Simple Assignment')shoplist = ['apple', 'mango', 'carrot', 'banana']# mylist 只是指向同一对象的另一种名称mylist = shoplist# 我购买了第一项项目，所以我将其从列表中删除del shoplist[0]print('shoplist is', shoplist)print('mylist is', mylist)# 注意到 shoplist 和 mylist 二者都# 打印出了其中都没有 apple 的同样的列表，以此我们确认# 它们指向的是同一个对象print('Copy by making a full slice')# 通过生成一份完整的切片制作一份列表的副本mylist = shoplist[:]# 删除第一个项目del mylist[0]print('shoplist is', shoplist)print('mylist is', mylist)# 注意到现在两份列表已出现不同]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的序列以及切片的解释]]></title>
    <url>%2F2018%2F07%2F22%2Fpython%E4%B8%AD%E7%9A%84%E5%BA%8F%E5%88%97%E4%BB%A5%E5%8F%8A%E5%88%87%E7%89%87%E7%9A%84%E8%A7%A3%E9%87%8A%2F</url>
    <content type="text"><![CDATA[python中的序列以及切片的解释切片：有一种切片（Slicing）运算符，它能够允许我们序列中的某段切片——也就是序列之中的一部分。 序列1234567891011121314151617181920212223242526272829303132333435# 序列 跑一下看看shoplist = ['apple', 'mango', 'carrot', 'banana']name = 'swaroop'# Indexing or 'Subscription' operation ## 索引或“下标（Subcription）”操作符 #print('Item 0 is', shoplist[0])print('Item 1 is', shoplist[1])print('Item 2 is', shoplist[2])print('Item 3 is', shoplist[3])print('Item -1 is', shoplist[-1])print('Item -2 is', shoplist[-2])print('Character 0 is', name[0])# Slicing on a list #print('Item 1 to 3 is', shoplist[1:3])print('Item 2 to end is', shoplist[2:])print('Item 1 to -1 is', shoplist[1:-1])print('Item start to end is', shoplist[:])# 从某一字符串中切片 #print('characters 1 to 3 is', name[1:3])print('characters 2 to end is', name[2:])print('characters 1 to -1 is', name[1:-1])print('characters start to end is', name[:])'''你会注意到当步长为 2 时，我们得到的是第 0、2、4…… 位项目。当步长为 3 时，我们得到的是第 0、3……位项目。'''print(shoplist[::1])print(shoplist[::2])print(shoplist[::3])print(shoplist[::-1])]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的列表]]></title>
    <url>%2F2018%2F07%2F22%2Fpython%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[列表列表 是一种用于保存一系列有序项目的集合，也就是说，你可以利用列表保存一串项目的序列。想象起来也不难，你可以想象你有一张购物清单，上面列出了需要购买的商品，除开在购物清单上你可能为每件物品都单独列一行，在 Python 中你需要在它们之间多加上一个逗号。 代码123456789101112131415161718192021222324252627# 列表# This is my shopping list'''在这里要注意在调用 print 函数时我们使用 end 参数，这样就能通过一个空格来结束输出工作，而不是通常的换行。'''shoplist = ['apple', 'mango', 'carrot', 'banana']print('I have', len(shoplist), 'items to purchase')print('These item are:', end=' ')for item in shoplist: print(item, end=' ')print('\nI also have to buy rice.')shoplist.append('rice')print('My shopping list is now', shoplist)print('I will sort my list now')shoplist.sort()print('Sorted shopping list is', shoplist)print('The first item I will buy is', shoplist[0])olditem = shoplist[0]del shoplist[0]print('I bought the', olditem)print('My shopping list is now', shoplist)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的元组]]></title>
    <url>%2F2018%2F07%2F22%2Fpython%E4%B8%AD%E7%9A%84%E5%85%83%E7%BB%84%2F</url>
    <content type="text"><![CDATA[元组元组（Tuple）用于将多个对象保存到一起。你可以将它们近似地看作列表，但是元组不能提供列表类能够提供给你的广泛的功能。元组的一大特征类似于字符串，它们是不可变的，也就是说，你不能编辑或更改元组。元组是通过特别指定项目来定义的，在指定项目时，你可以给它们加上括号，并在括号内部用逗号进行分隔。元组通常用于保证某一语句或某一用户定义的函数可以安全地采用一组数值，意即元组内的数值不会改变。 代码123456789101112131415# 元组'''推荐使用括号来指明元组的开始和结束尽管括号是一个可选选项明了胜过晦涩，显式优于隐式'''zoo = ('python', 'elephant', 'penguin')print('Number of animals in the zoo is', len(zoo))new_zoo = 'monkey', 'camel', zooprint('Number of animals in the zoo is', len(new_zoo))print('All animals in new zoo are', new_zoo)print('Animals brought from old zoo are', new_zoo[2])print('Last animal brought from old zoo is', new_zoo[2][2])print('Number of animals in the new zoo is', len(new_zoo) - 1 + len(new_zoo[2]))]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的Docstring]]></title>
    <url>%2F2018%2F07%2F22%2Fpython%E4%B8%AD%E7%9A%84Docstring%2F</url>
    <content type="text"><![CDATA[基本教程1234567891011121314151617181920212223242526'''文档字符串的应用该文档字符串所约定的是一串多行字符串，其中第一行以某一大写字母开始，以句号结束。第二行为空行，后跟的第三行开始是任何详细的解释说明。 在此强烈建议你在有关你所有非凡功能的文档字符串中都遵循这一约定。'''def print_max(x, y): '''Prints the maximum of two numbers.打印两个数值中的最大数。 The two values must be integers.这两个数都应该是整数 ''' # 如果可能，将其转换至整数类型 x = int(x) y = int(y) if x &gt; y: print(x, 'is maximum') else: print(y, 'is maximum')print_max(3, 5)print(print_max.__doc__)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中字符串的一些基本操作]]></title>
    <url>%2F2018%2F07%2F22%2Fpython%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[python字符串的一些基本操作在这里，我们会看见一此操作中包含了好多字符串方法。 startwith 方法用于查找字符串是否以给定的字符串内容开头。 in 运算符用以检查给定的字符串是否是查询的字符串中的一部分。find 方法用于定位字符串中给定的子字符串的位置。如果找不到相应的子字符串， find会返回 -1。 str 类同样还拥有一个简洁的方法用以 联结（Join） 序列中的项目，其中字符串将会作为每一项目之间的分隔符，并以此生成并返回一串更大的字符串。 123456789101112131415# 这是一个字符串对象name = 'Swaroop'if name.startswith('Swa'): print('Yes, the string starts with "Swa"')if 'a' in name: print('Yes, it contains the string "a"')if name.find('war') != -1: print('Yes,it contains the string "war"')delimiter = '_*_'mylist = ['Brazil', 'Russia', 'India', 'China']print(delimiter.join(mylist))]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中字典（key-value）]]></title>
    <url>%2F2018%2F07%2F22%2Fpython%E4%B8%AD%E5%AD%97%E5%85%B8%EF%BC%88key-value%EF%BC%89%2F</url>
    <content type="text"><![CDATA[字典（key-value）字典就像一本地址簿，如果你知道了他或她的姓名，你就可以在这里找到其地址或是能够联系上对方的更多详细信息，换言之，我们将键值（Keys）（即姓名）与值（Values）（即地址等详细信息）联立到一起。在这里要注意到键值必须是唯一的，正如在现实中面对两个完全同名的人你没办法找出有关他们的正确信息。 代码123456789101112131415161718192021222324252627# 字典# "ab"是地址（Address）薄(Book)的缩写ab = &#123; 'Swaroop': 'swaroop@swaroopch.com', 'Larry': 'larry@wall.org', 'Matsumoto': 'matz@ruby-lang.org', 'Spammer': 'spammer@hptmail.com'&#125;print("Swaroop's address is", ab['Swaroop'])# 删除一对键值-值配对del ab['Spammer']print('\nThere are &#123;&#125; contacts in the address-book\n'.format(len(ab)))#我们通过使用字典的 item 方法来访问字典中的每一对键值—值配对信息，这一操作将返回一份包含元组的列表for name, address in ab.items(): print('Contact &#123;&#125; at &#123;&#125;'.format(name, address))# 添加一对键值-值配对ab['Guido'] = 'guido@python.org'if 'Guido' in ab: print("\nGuido's address is", ab['Guido'])]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博客测试]]></title>
    <url>%2F2018%2F07%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[这是我的第一篇博客= =，成功搭建了本网站地址 第一级标题生成一个hexo博客1$ hexo new "My New Post" 更多的信息: Writing 在本地跑起来1$ hexo server 更多的信息: Server 生成静态文件（保存） 1$ hexo generate 更多的信息: Generating 上传到github1$ hexo deploy 更多的信息: Deployment]]></content>
      <categories>
        <category>博客测试文件</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
</search>
