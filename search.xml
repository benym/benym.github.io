<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用k-近邻算法改进约会网站的配对效果]]></title>
    <url>%2F2018%2F08%2F11%2F%E4%BD%BF%E7%94%A8k-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%E6%94%B9%E8%BF%9B%E7%BA%A6%E4%BC%9A%E7%BD%91%E7%AB%99%E7%9A%84%E9%85%8D%E5%AF%B9%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[实例：在约会网站上使用k-近邻算法 (1) 收集数据：提供文本文件。(2) 准备数据 : 使用python解析文本文件。(3) 分析数据 使用 Matplotlib画二维扩散图 。(4) 训练算法：此步驟不适用于k-近邻算法。(5) 测试算法：使用海伦提供的部分数据作为测试样本。测试样本和非测试样本的区别在于：测试样本是已经完成分类的数据，如果预测分类与实际类别不同，则标记为一个错误。(6) 使用算法：产生简单的命令行程序，然后可以输入一些特征数据以判断对方是否为自己喜欢的类型。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172from numpy import *import operatorimport matplotlibimport matplotlib.pyplot as pltdef createDateSet(): group = array([[1.0, 1.1], [1.0, 1.0], [0, 0], [0, 0.1]]) labels = ['A', 'A', 'B', 'B'] return group, labels''' 用于分类的输人向量是inX， 输入的训练样本集为dataSet, 标签向量为labels 最后的参数k表示用于选择最近邻居的数目， 其中标签向量的元素数目和矩阵dataSet的行数相同'''def classify0(inX, dataSet, labels, k): dataSetSize = dataSet.shape[0] # 距离计算 diffMat = tile(inX, (dataSetSize, 1)) - dataSet sqDiffMat = diffMat ** 2 sqDistances = sqDiffMat.sum(axis=1) distances = sqDistances ** 0.5 sortedDistIndicies = distances.argsort() classCount = &#123;&#125; # 选择距离最小的k个点 for i in range(k): votellabel = labels[sortedDistIndicies[i]] classCount[votellabel] = classCount.get(votellabel, 0) + 1 # 排序 sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse=True) return sortedClassCount[0][0]# 将文本记录转换到Numpy的解析程序def file2matrix(filename): fr = open(filename) arrayOLines = fr.readlines() # 得到文件行数 numberOfLines = len(arrayOLines) # 创建返回的Numpy矩阵，将该矩阵的另一维度设置为3 returnMat = zeros((numberOfLines, 3)) classLabelVector = [] index = 0 # 解析文件数据到列表，循环处理每行数据 for line in arrayOLines: # 截取掉所有的回车字符 line = line.strip() # 使用tab字符\t将上一步得到的整行数据分割成一个元素列表 listFromLine = line.split('\t') # 选取前3个元素，将他们存储到特征矩阵中 returnMat[index, :] = listFromLine[0:3] # -1表示列表中的最后一列元素，将最后一列元素存储到向量classLabelVector中 classLabelVector.append(int(listFromLine[-1])) index += 1 return returnMat, classLabelVectordatingDataMat, datingLabels = file2matrix('datingTestSet2.txt')print("array:\n", datingDataMat)print("datingLabels[0:20]\n", datingLabels[0:20])# 绘制散点图# 定义figurefig = plt.figure()#add_subplot()返回一个axes对象，里面的参数abc表示在一个figure窗口中，有a行b列个小窗口，然后本次plot在第c个窗口中。ax = fig.add_subplot(111)# 设置颜色和散点图数据ax.scatter(datingDataMat[:, 1], datingDataMat[:, 2], 15.0 * array(datingLabels), 15.0 * array(datingLabels))plt.show() 数据集 运行结果12345678910array: [[ 4.09200000e+04 8.32697600e+00 9.53952000e-01] [ 1.44880000e+04 7.15346900e+00 1.67390400e+00] [ 2.60520000e+04 1.44187100e+00 8.05124000e-01] ..., [ 2.65750000e+04 1.06501020e+01 8.66627000e-01] [ 4.81110000e+04 9.13452800e+00 7.28045000e-01] [ 4.37570000e+04 7.88260100e+00 1.33244600e+00]]datingLabels[0:20] [3, 2, 1, 1, 1, 1, 3, 3, 1, 3, 1, 1, 2, 1, 1, 1, 1, 1, 2, 3] 散点图结果： 2018年8月11日 16:49:36 新增：归一化特征值，测试代码，预测代码 因为在欧氏距离中数值差值最大的属性对计算结果的影响最大，但其实多个特征都是同等重要的属性，这样如果其中一个占的权重过大，会严重影响到计算的结果 所以在处理不同取值范围的特征值的时候，我们通常采用的方法是将数值归一化，如将取值范围处理为0到1或者-1到1之间。 公式：newValue = （oldValue - min）/（max - min） 其中min和max分别是数据集中的最小特征值和最大特征值。虽然改变数值取值范围增加了分类器的复杂度，但为了得到准确的结果，这样做是必然的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# 将数字特征值转化为0到1的区间def autoNorm(dataSet): # 将每列的最小值放在变量minVals中，dataSet.min(0)中的参数0使得函数可以从列中选取最小值 minVals = dataSet.min(0) # 将每列的最大值放在变量maxVals中 maxVals = dataSet.max(0) ranges = maxVals - minVals normDataSet = zeros(shape(dataSet)) m = dataSet.shape[0] # 为了归一化特征值，必须使用当前值减去最小值，然后除以取值范围 # tile()函数将变量内容复制成输入矩阵同样大小的矩阵 normDataSet = dataSet - tile(minVals, (m, 1)) # 特征值相除 normDataSet = normDataSet / tile(ranges, (m, 1)) return normDataSet, ranges, minVals# 分类器针对约会网站的测试代码def datingClassTest(): hoRatio = 0.10 # 首先使用file2matrix和autoNorm()函数从文件中读取数据并将其转换为归一化特征值 datingDataMat, datingLabels = file2matrix('datingTestSet2.txt') normMat, ranges, minVals = autoNorm(datingDataMat) # 计算测试向量的数量，决定normMat向量中哪些数据用于测试，哪些数据用于分类器的训练样本 m = normMat.shape[0] numTestVecs = int(m * hoRatio) errorCount = 0.0 # 将两部分数据输入到原始分类器函数classify0 for i in range(numTestVecs): classifierResult = classify0(normMat[i, :], normMat[numTestVecs:m, :], \ datingLabels[numTestVecs:m], 3) print("the classifier came back with:&#123;&#125;,the real answer is:&#123;&#125;".format(classifierResult, datingLabels[i])) if (classifierResult != datingLabels[i]): errorCount += 1.0 # 计算错误率并输出结果 print("the total error rate is:&#123;&#125;".format(errorCount / float(numTestVecs)))# 约会网站预测函数def classifyPerson(): resultList = ['not at all', 'in small doses', 'in large doses'] percentTats = float(input( \ "percentage of time spent playing video games?")) ffMiles = float(input("frequent flier miles earned per year?")) iceCream = float(input("liters of ice cream consumed per year?")) datingDataMat, datingLabels = file2matrix('datingTestSet2.txt') normMat, ranges, minVals = autoNorm(datingDataMat) inArr = array([ffMiles, percentTats, iceCream]) classifierResult = classify0((inArr - \ minVals) / ranges, normMat, datingLabels, 3) print("You will probably like this person:", \ resultList[classifierResult - 1]) 测试归一化特征值、分类器、选择喜欢的人： 123456789# 测试归一化特征值normMat, ranges, minVals = autoNorm(datingDataMat)print("array:\n", normMat)print("array:", ranges)print("array:", minVals)# 测试分类器datingClassTest()# 选择喜欢的人classifyPerson() 运行结果123456789101112131415161718192021222324252627# normMatarray: [[ 0.44832535 0.39805139 0.56233353] [ 0.15873259 0.34195467 0.98724416] [ 0.28542943 0.06892523 0.47449629] ..., [ 0.29115949 0.50910294 0.51079493] [ 0.52711097 0.43665451 0.4290048 ] [ 0.47940793 0.3768091 0.78571804]]# rangesarray: [ 9.12730000e+04 2.09193490e+01 1.69436100e+00]# minValsarray: [ 0. 0. 0.001156]# 测试分类器(数据太多了这里截取部分)the classifier came back with:3,the real answer is:3the classifier came back with:2,the real answer is:2......the classifier came back with:2,the real answer is:2the classifier came back with:1,the real answer is:1the classifier came back with:3,the real answer is:1# 分类器处理约会数据集的错误率为5%（书上为2.4%....不知道怎么回事）the total error rate is:0.05# 输入各个属性，得到最佳约会伙伴percentage of time spent playing video games?10frequent flier miles earned per year?10000liters of ice cream consumed per year?0.5You will probably like this person: in small doses]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>k-近邻算法</tag>
        <tag>python</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kNN（k-近邻算法）]]></title>
    <url>%2F2018%2F08%2F09%2FkNN%EF%BC%88k-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[k-近邻算法（kNN），它的工作原理是：存在一个样本数据集合，也称作训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每一数据与所属分类的对应关系。输人没有标签的新数据后，将新数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本集中特征最相似数据（最近邻）的分类标签。一般来说，我们只选择样本数据集中前 k个最相似的数据，这就是 k- 近邻算法中k的出处 , 通常k是不大于 20 的整数。最后，选择k个最相似数据中出现次数最多的分类，作为新数据的分类。 k-近邻算法的一般流程 收集数据：可以使用任何方法。 准备数据：距离计算所需要的数值，最好是结构化的数据格式。 分析数据：可以使用任何方法。 训练算法：此步驟不适用于k-近邻算法。 测试算法：计算错误率。 使用算法：首先需要输入样本数据和结构化的输出结果，然后运行k-近邻算法判定输入数据分别属于哪个分类，最后应用对计算出的分类执行后续的处理。 使用欧氏距离公式，计算两个向量点xA和xB之间的距离： 例如，点 (0 ,0) 与 (1, 2) 之间的距离计算为： 如果数据集存在 4 个特征值，则点 (1 ,0, 0 ,1) 与 (7, 6, 9 ,4) 之间的距离计算为: 计算完所有点之间的距离后，可以对数据按照从小到大的次序排序。然后，确定前 k 个距离最小元素所在的主要分类 , 输人k总是正整数；最后，将classCount字典分解为元组列表，然后使用程序第二行导入运算符模块的itemgetter方法 ,按照第二个元素的次序对元组进行排序。此处的排序为逆序，即按照从最大到最小次序排序，最后返回发生频率最高的元素标签。 代码123456789101112131415161718192021222324252627282930313233343536373839from numpy import *import operatordef createDateSet(): group = array([[1.0, 1.1], [1.0, 1.0], [0, 0], [0, 0.1]]) labels = ['A', 'A', 'B', 'B'] return group, labels''' 用于分类的输人向量是inX， 输入的训练样本集为dataSet, 标签向量为labels 最后的参数k表示用于选择最近邻居的数目， 其中标签向量的元素数目和矩阵dataSet的行数相同'''def classify0(inX, dataSet, labels, k): dataSetSize = dataSet.shape[0] # 距离计算 diffMat = tile(inX, (dataSetSize, 1)) - dataSet sqDiffMat = diffMat ** 2 sqDistances = sqDiffMat.sum(axis=1) distances = sqDistances ** 0.5 sortedDistIndicies = distances.argsort() classCount = &#123;&#125; # 选择距离最小的k个点 for i in range(k): votellabel = labels[sortedDistIndicies[i]] classCount[votellabel] = classCount.get(votellabel, 0) + 1 # 排序 sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse=True) return sortedClassCount[0][0]group, labels = createDateSet()print(classify0([1.0, 1.1], group, labels, 3)) 运行结果1A]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>k-近邻算法</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Numpy库的首次使用]]></title>
    <url>%2F2018%2F08%2F09%2FNumpy%E5%BA%93%E7%9A%84%E9%A6%96%E6%AC%A1%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在pycharm中的setting安装numpy，或者在cmd里面通过pip install方法安装均可 代码12345678910111213141516from numpy import *# 构造一个4x4的随机数组print("数组:\n",random.rand(4, 4))# 调用mat()函数将数组转化为矩阵randMat = mat(random.rand(4, 4))# .I操作符实现了矩阵求逆的运算print("矩阵求逆:\n",randMat.I)# 矩阵乘以逆矩阵invRandMat = randMat.Iprint("矩阵乘以逆矩阵:\n",randMat*invRandMat)# 函数eye(4)创建一个4x4的单位矩阵，下面是算误差myEye = randMat*invRandMatprint("计算误差:\n",myEye-eye(4)) 运行结果1234567891011121314151617181920数组: [[ 0.46089523 0.94167701 0.76910005 0.96892095] [ 0.38894192 0.88828275 0.28144475 0.91774255] [ 0.13997437 0.7435124 0.89709322 0.68924161] [ 0.41461243 0.19911356 0.64856312 0.49160523]]矩阵求逆: [[-0.45014095 1.92871242 0.28217777 -0.76959459] [ 1.09829851 -0.9829715 -1.78955478 2.70643663] [ 0.95057662 -1.40675696 0.67345673 -0.70029109] [-1.11436955 -0.35496085 1.88297962 -0.76459429]]矩阵乘以逆矩阵: [[ 1.00000000e+00 7.20736257e-17 -3.04329603e-17 -1.66886258e-17] [ -2.27212878e-16 1.00000000e+00 2.93001892e-17 -1.63043911e-16] [ 8.73583235e-18 -3.06881469e-17 1.00000000e+00 -3.50839733e-17] [ -4.04804848e-17 1.45085950e-16 -1.23671214e-16 1.00000000e+00]]计算误差: [[ -1.11022302e-16 7.20736257e-17 -3.04329603e-17 -1.66886258e-17] [ -2.27212878e-16 2.22044605e-16 2.93001892e-17 -1.63043911e-16] [ 8.73583235e-18 -3.06881469e-17 -2.22044605e-16 -3.50839733e-17] [ -4.04804848e-17 1.45085950e-16 -1.23671214e-16 2.22044605e-16]]]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Numpy</tag>
        <tag>机器学习</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例设计模式]]></title>
    <url>%2F2018%2F08%2F08%2F%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[需要全局的对象唯一的时候，使用单例设计模式，几乎是最简单的设计模式……，以下是代码部分 代码12345678910111213141516171819202122232425262728293031323334# object写不写都可以，在python3.X中已经默认继承了，以前区别旧式类和新式类# 单例设计模式class MusicPlayer(object): # 记录第一个被创建对象的引用 instance = None # 记录是否执行过初始化方法 init_flag = False def __new__(cls, *args, **kwargs): # 1. 判断类属性是否是空对象 if cls.instance is None: # 2. 调用父类的方法，为第一个对象分配空间 cls.instance = super().__new__(cls) # 3. 返回类属性保存的对象引用 return cls.instance # 让初始化方法只执行一次 def __init__(self): # 1. 判断是否执行过初始化动作 if MusicPlayer.init_flag: return # 2. 如果没有执行过，执行初始化动作 print("111111111") # 3. 修改类属性的标记 MusicPlayer.init_flag = True# 创建多个对象player1 = MusicPlayer()print(player1)player2 = MusicPlayer()print(player2) 运行结果123111111111&lt;__main__.MusicPlayer object at 0x000000000342D0B8&gt;&lt;__main__.MusicPlayer object at 0x000000000342D0B8&gt; 可以看出2次对象的创建在内存上实际是一个地址]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的__new__方法的重写]]></title>
    <url>%2F2018%2F08%2F08%2Fpython%E4%B8%AD%E7%9A%84__new__%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99%2F</url>
    <content type="text"><![CDATA[new方法重写的步骤比较固定，直接上代码吧 代码123456789101112131415161718class MusicPlayer(object): # new方法的重写，是一个静态方法，必须主动传递cls参数 def __new__(cls, *args, **kwargs): # 1.创建对象时，new方法会被自动调用 print(&quot;创建对象，分配空间&quot;) # 2.为对象分配空间 instance = super().__new__(cls) # 3.返回对象的引用 return instance def __init__(self): print(&quot;111&quot;)player = MusicPlayer()print(player) 运行结果123创建对象，分配空间111&lt;__main__.MusicPlayer object at 0x0000000003A0D128&gt;]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的静态方法、实例方法、类方法的区别]]></title>
    <url>%2F2018%2F08%2F08%2Fpython%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E3%80%81%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E3%80%81%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[实例方法 ​ 定义：第一个参数必须是实例对象，该参数名一般约定为“self”，通过它来传递实例的属性和方法（也可以传类的属性和方法）； ​ 调用：只能由实例对象调用。 类方法 ​ 定义：使用装饰器@classmethod。第一个参数必须是当前类对象，该参数名一般约定为“cls”，通过它来传递类的属性和方法（不能传实例的属性和方法）； ​ 调用：实例对象和类对象都可以调用。 静态方法 ​ 定义：使用装饰器@staticmethod。参数随意，没有“self”和“cls”参数，但是方法体中不能使用类或实例的任何属性和方法； ​ 调用：实例对象和类对象都可以调用。 代码12345678910111213141516171819202122232425262728293031323334353637import timeclass Tool(object): count = 0 def __init__(self, name): self.name = name Tool.count += 1 # 定义一个实例方法，有self参数 def action(self): print("挥动&#123;&#125;".format(self.name)) # 定义一个类方法，有cls参数 @classmethod def shou_tool_count(cls): print("工具对象的数量&#123;&#125;".format(cls.count)) # 定义一个静态方法，初始没有任何参数 @staticmethod def showTime(): print(time.strftime("%H:%M:%S", time.localtime()))# 创建工具对象tool = Tool("斧头")too2 = Tool("榔头")# 调用类方法,逻辑上类方法一般由类自身调用，其实实例对象和类对象都可以调用Tool.shou_tool_count()# 调用实例方法,只能由实例对象调用tool.action()# 调用静态方法,实例对象和类对象均可调用too2.showTime()Tool.showTime() 运行结果1234工具对象的数量2挥动斧头20:30:4620:30:46]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的多态]]></title>
    <url>%2F2018%2F08%2F08%2Fpython%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[当子类和父类都存在相同的 game()方法时，子类的 game() 覆盖了父类的 game()，在代码运行时，会调用子类的 game()。 这样，我们就获得了继承的另一个好处：多态。 多态的好处就是，当我们需要传入更多的子类，例如新增 XX Dog、YY Dog 等时，我们只需要继承 Dog 类型就可以了，而game()方法既可以直不重写（即使用Dog的），也可以重写一个特有的。这就是多态的意思。调用方只管调用，不管细节，而当我们新增一种Dog的子类时，只要确保新方法编写正确，而不用管原来的代码。这就是著名的“开闭”原则： 对扩展开放（Open for extension）：允许子类重写方法函数 对修改封闭（Closed for modification）：不重写，直接继承父类方法函数 代码1234567891011121314151617181920212223242526272829303132333435class Dog(object): def __init__(self, name): self.name = name def game(self): print("&#123;&#125;跳".format(self.name))class XiaoTianDog(Dog): # 方法重写 def game(self): print("&#123;&#125;飞".format(self.name))class Person(object): def __init__(self, name): self.name = name def game_with_dog(self, dog): print("&#123;&#125;和&#123;&#125;玩耍".format(self.name, dog.name))# 创建Dog对象Peter = Dog("皮特")# 创建XiaoTianDog对象wangcai = XiaoTianDog("旺财")# 调用Dog里面的game方法Peter.game()# 调用XiaoTianDog里面的game方法wangcai.game()xiaoming = Person("小明")xiaoming.game_with_dog(wangcai) 运行结果123皮特跳旺财飞小明和旺财玩耍]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[turtle绘图库]]></title>
    <url>%2F2018%2F08%2F08%2Fturtle%E7%BB%98%E5%9B%BE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[大概学习了下turtle库的一个绘图实例= =，估计以后也用不上这个库…. 代码实例1： 绘制一条小蛇 123456789101112131415161718192021222324252627import turtle # 绘图库# 绘制一条小蛇# 设置窗体大小及位置，但并不是必须的，依次长,宽，如果后两项不设置，则默认正中心turtle.setup(650, 350, 200, 200)# 抬起画笔turtle.penup()# turtle.fd表示向海龟的右边走，turtle.bk表示向海龟的左边走turtle.fd(-250)# 下笔turtle.pendown()# 设置画笔宽度turtle.pensize(25)# 设置画笔颜色turtle.pencolor("purple")# 改变当前行径的方向，原地转向的意思，参数为绝对角度# turtle.left和turtle.right表示向左边或右边改变角度turtle.seth(-40)for i in range(4): # circle表示以某一个点为圆心，向左侧运行 turtle.circle(40, 80) turtle.circle(-40, 80)turtle.circle(40, 80 / 2)turtle.fd(40)turtle.circle(16, 100)turtle.fd(40 * 2 / 3)turtle.done() 运行结果 实例2：绘制一个Z 代码123456789import turtleturtle.left(45) # 转角度turtle.fd(150) # 前进turtle.right(135)turtle.fd(300)turtle.left(135)turtle.fd(150)turtle.done() 运行结果]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式中的compile函数(二)]]></title>
    <url>%2F2018%2F08%2F07%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84compile%E5%87%BD%E6%95%B0(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[接着上一篇文章的compile函数实例 代码12345678910111213import repattern = re.compile(r'([a-z]+) ([a-z]+)', re.I) # re.I 表示忽略大小写m = pattern.match('Hello World Wide Web')print(m) # 匹配成功，返回一个Match 对象print(m.group(0)) # 返回匹配成功的整个子串print(m.span(0)) # 返回匹配成功整个子串的索引print(m.group(1)) # 返回第一个分组匹配成功的子串print(m.span(1)) # 返回第一个分组匹配成功的子串的索引print(m.group(2)) # 返回第二个分组匹配成功的子串print(m.span(2)) # 返回第二个分组匹配成功的子串的索引print(m.groups()) # 等价于(m.group(1),m.group(2), ...)print(m.group(3)) # 不存在第三个分组 运行结果123456789101112Traceback (most recent call last):&lt;_sre.SRE_Match object; span=(0, 11), match='Hello World'&gt; File "E:/PythonProject/more/test.py", line 13, in &lt;module&gt;Hello World print(m.group(3)) # 不存在第三个分组(0, 11)IndexError: no such groupHello(0, 5)World(6, 11)('Hello', 'World')]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式中的compile函数]]></title>
    <url>%2F2018%2F08%2F07%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84compile%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。 语法格式为： re.compile(pattern[, flags]) 参数： pattern : 一个字符串形式的正则表达式 flags 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为： re.I 忽略大小写 re.L 表示特殊字符集 \w, \W, \b, \B, \s, \S 依赖于当前环境 re.M 多行模式 re.S 即为’ . ‘并且包括换行符在内的任意字符（’ . ‘不包括换行符） re.U 表示特殊字符集 \w, \W, \b, \B, \d, \D, \s, \S 依赖于 Unicode 字符属性数据库 re.X 为了增加可读性，忽略空格和’ # ‘后面的注释 代码12345678910111213141516171819202122import re# 列子1pattern = re.compile(r'\d+') # 用于匹配至少一个数字m = pattern.match('one12twothree34four') # 查找头部，没有匹配print(m)m = pattern.match('one12twothree34four', 2, 10) # 从'e'的位置开始匹配，没有匹配print(m)m = pattern.match('one12twothree34four', 3, 10) # 从'1'的位置开始匹配，正好匹配print(m) # 返回一个Match对象print(m.group(0)) # 可省略0print(m.start(0)) # 可省略0print(m.end(0)) # 可省略0print(m.span(0)) # 可省略0'''在上面，当匹配成功时返回一个 Match 对象，其中：group([group1, …]) 方法用于获得一个或多个分组匹配的字符串，当要获得整个匹配的子串时，可直接使用 group() 或 group(0)；start([group]) 方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引），参数默认值为 0；end([group]) 方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1），参数默认值为 0；span([group]) 方法返回 (start(group), end(group))。''' 运行结果1234567NoneNone&lt;_sre.SRE_Match object; span=(3, 5), match=&apos;12&apos;&gt;1235(3, 5)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式检索与替换]]></title>
    <url>%2F2018%2F08%2F07%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A3%80%E7%B4%A2%E4%B8%8E%E6%9B%BF%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[re.sub用于替换字符串中的匹配项 re.sub(pattern, repl, string, count=0) 代码123456789101112131415161718192021import rephone = "2004-959-559 # 这是一个电话号码"# 删除注释num = re.sub(r'#.*$', "", phone)print("电话号码:", num)# 移除非数字的内容num = re.sub(r'\D', "", phone)print("电话号码:", num)# 将匹配的数字乘以2def double(matched): value = int(matched.group('value')) return str(value * 2)s = 'A23G4HFD567'print(re.sub('(?P&lt;value&gt;\d+)', double, s)) 运行结果123电话号码: 2004-959-559 电话号码: 2004959559A46G8HFD1134]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中的正则表达式match和search]]></title>
    <url>%2F2018%2F08%2F07%2FPython%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fmatch%E5%92%8Csearch%2F</url>
    <content type="text"><![CDATA[re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配 代码123456789101112131415161718import re'''re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。'''line = "Cats are smarter than dogs";matchObj = re.match(r'dogs', line, re.M | re.I)if matchObj: print("match --&gt; matchObj.group() : ", matchObj.group())else: print("No match!!")matchObj = re.search(r'dogs', line, re.M | re.I)if matchObj: print("search --&gt; matchObj.group() : ", matchObj.group())else: print("No match!!") 运行结果12No match!!search --&gt; matchObj.group() : dogs]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中的正则表达式]]></title>
    <url>%2F2018%2F08%2F07%2FPython%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[主要是一些正则表达式的基本语法和部分实例 re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none re.match(pattern, string, flag=0) 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等 re.search 扫描整个字符串并返回第一个成功的匹配 re.search(pattern, string, flag=0) 代码12345678910111213141516171819202122232425262728293031323334353637import re'''group() 返回被 RE 匹配的字符串start() 返回匹配开始的位置end() 返回匹配结束的位置span() 返回一个元组包含匹配 (开始,结束) 的位置group() 返回re整体匹配的字符串，可以一次输入多个组号，对应组号匹配的字符串'''print(re.match('www', 'www.runoob.com').span()) # 在起始位置匹配print(re.match('com', 'www.runoob.com')) # 不在起始位置匹配# group(num=0) 匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。line = "Cats are smarter than dogs"# match部分matchObj = re.match(r'(.*) are (.*?) .*', line, re.M | re.I)if matchObj: print("matchObj.group():", matchObj.group()) print("matchObj.group(1):", matchObj.group(1)) print("matchObj.group(2):", matchObj.group(2))else: print("No match!!")# search部分searchObj = re.search(r'(.*) are (.*?) .*', line, re.M | re.I)if searchObj: print("searchObj.group() : ", searchObj.group()) print("searchObj.group(1) : ", searchObj.group(1)) print("searchObj.group(2) : ", searchObj.group(2))else: print("Nothing found!!")# re.search 扫描整个字符串并返回第一个成功的匹配。print(re.search('www', 'www.runoob.com').span()) # 在起始位置匹配print(re.search('com', 'www.runoob.com').span()) # 不在起始位置匹配 运行结果12345678910(0, 3)NonematchObj.group(): Cats are smarter than dogsmatchObj.group(1): CatsmatchObj.group(2): smartersearchObj.group() : Cats are smarter than dogssearchObj.group(1) : CatssearchObj.group(2) : smarter(0, 3)(11, 14)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中面向对象比较简单的内部函数]]></title>
    <url>%2F2018%2F08%2F06%2FPython%E4%B8%AD%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%AF%94%E8%BE%83%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E9%83%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[比较简单的内部函数代码部分1234567891011121314151617181920212223class Cat: def __init__(self, new_name): self.name = new_name # 定义一个私有属性 self.__age = 18 print("&#123;&#125;来了".format(self.name)) def __del__(self): print("%s 我去了" % self.name) def __str__(self): # 必须返回一个字符串 # str方法定制变量输出信息，一般用来自定义内容 return "我是小猫&#123;&#125;".format(self.name) # 如果定义为__secret则为私有方法 def secret(self): print("&#123;&#125;的年龄是&#123;&#125;".format(self.name,self.__age))tom = Cat("Tom")tom.secret()print(tom) 运行结果1234Tom来了Tom的年龄是18我是小猫TomTom 我去了]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欢迎来到我的博客]]></title>
    <url>%2F2018%2F08%2F03%2F%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[机器学习持续烧脑中， 💥😩😤 继续为明天奋斗!]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Face</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中对列表和元组的切片操作]]></title>
    <url>%2F2018%2F07%2F28%2Fpython%E4%B8%AD%E5%AF%B9%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84%E7%9A%84%E5%88%87%E7%89%87%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[python中对列表和元组的切片操作代码123456789# 切片方法用于列表、元组,切片方法不能用于字典list_tmp = [0, 1, 2, 3, 4]tuple_tmp = (4, 3, 2, 1, 0)# 列表输出print([0, 1, 2, 3, 4][1:3])print(list_tmp[1:3])# 元组输出print((4, 3, 2, 1, 0)[1:3])print(tuple_tmp[1:3]) 运行结果1234[1, 2][1, 2](3, 2)(3, 2)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中字符串的一些方法回顾(切片回顾)]]></title>
    <url>%2F2018%2F07%2F26%2Fpython%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%E5%9B%9E%E9%A1%BE(%E5%88%87%E7%89%87%E5%9B%9E%E9%A1%BE)%2F</url>
    <content type="text"><![CDATA[python中字符串的一些方法回顾(切片回顾)代码123456789101112131415161718192021222324# 字符串的切片 字符串[开始索引:结束索引:步长]# 如果使用倒序索引的方法，那么最后一位元素是以-1开始，倒数第二位是-2# 切片方法适用于字符串、列表、元组num_str = "0123456789"# 截取2-5的字符串print(num_str[2:6])# 截取2-末尾的字符串print(num_str[2:])# 从起始位置截取到5位置的字符串 num_str[0:6]等价print(num_str[:6])# 生成切片的副本print(num_str[:])# 从开始位置开始，每隔一个字符截取字符串print(num_str[::2])# 从索引1开始，每隔一个取一个print(num_str[1::2])# 截取从2到(末尾-1)的字符串print(num_str[2:-1])# 截取字符串末尾两个字符print(num_str[-2:])# 字符串的逆序 num_str[::-1]等价print(num_str[-1::-1]) 运行结果123456789&gt;&gt;&gt;2345&gt;&gt;&gt;23456789&gt;&gt;&gt;012345&gt;&gt;&gt;0123456789&gt;&gt;&gt;02468&gt;&gt;&gt;13579&gt;&gt;&gt;2345678&gt;&gt;&gt;89&gt;&gt;&gt;9876543210]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中字符串的一些方法回顾(拆分与合并)]]></title>
    <url>%2F2018%2F07%2F26%2Fpython%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%E5%9B%9E%E9%A1%BE(%E6%8B%86%E5%88%86%E4%B8%8E%E5%90%88%E5%B9%B6)%2F</url>
    <content type="text"><![CDATA[python中字符串的一些方法回顾(拆分与合并)字符串中split函数和join函数的使用 代码123456789101112131415# 假设：以下内容是从网络上抓取的# 要求：# 1、将字符串中的空白字符全部去掉# 2、再使用" "作为分隔符，拼接成一个整齐的字符串poem_str = "登鹤鹊楼\t 王之涣 \t 白日依山尽 \t\n 黄河入海流 \t\t 欲穷千里目\t\t更上一层楼"print(poem_str)# 1、拆分字符串 split方法会返回列表poem_list = poem_str.split()print(poem_list)# 2、合并字符串result = " ".join(poem_list)print(result) 运行结果1234567原始字符串： 登鹤鹊楼 王之涣 白日依山尽 黄河入海流 欲穷千里目 更上一层楼拆分字符串后： ['登鹤鹊楼', '王之涣', '白日依山尽', '黄河入海流', '欲穷千里目', '更上一层楼']合并字符串后: 登鹤鹊楼 王之涣 白日依山尽 黄河入海流 欲穷千里目 更上一层楼]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中字符串的一些方法回顾(文本对齐、去除空白)]]></title>
    <url>%2F2018%2F07%2F26%2Fpython%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%E5%9B%9E%E9%A1%BE(%E6%96%87%E6%9C%AC%E5%AF%B9%E9%BD%90%E3%80%81%E5%8E%BB%E9%99%A4%E7%A9%BA%E7%99%BD)%2F</url>
    <content type="text"><![CDATA[python中字符串的一些方法回顾(文本对齐、去除空白)文本对齐的方法，以及用strip函数去除字符串的中空白字符 代码1234567891011121314151617181920# 假设：以下内容是从网络上抓取下来的# 要求：顺序并且居中对齐输出一下内容poem = ["\t\n登鹤鹊楼", "王之涣", "白日依山尽\t\n", "黄河入海流", "欲穷千里目", "更上一层楼"]for poem_str in poem: # 先使用strip方法去除字符串中的空白字符 # 居中对齐 ''' Python center() 返回一个原字符串居中,并使用空格填充至长度 width 的新字符串。默认填充字符为空格。 ''' print("|%s|" % poem_str.strip().center(10, " ")) # 向左对齐 # print("|%s|" % poem_str.ljust(10, " ")) # 向右对齐 # print("|%s|" % poem_str.rjust(10, " ")) 运行结果123456| 登鹤鹊楼 || 王之涣 || 白日依山尽 || 黄河入海流 || 欲穷千里目 || 更上一层楼 |]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中完整for循环的实际运用]]></title>
    <url>%2F2018%2F07%2F26%2Fpython%E4%B8%AD%E5%AE%8C%E6%95%B4for%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[python中完整for循环的实际运用代码1234567891011121314151617181920# 完整的for循环的实际应用 for...else结构students = [ &#123;"name": "xx"&#125;, &#123;"name": "yy"&#125;]# 在学院列表中搜索指定的姓名find_name = "SS"for i in students: print(i) if i["name"] == find_name: print("找到了 &#123;&#125;".format(find_name)) # 如果已经找到，应该直接退出循环，而不再遍历后续的元素 # 如果把这个else写在if语句之后的话，每次没有找到就要输出一次，这是不对的！ breakelse: print("没有找到&#123;&#125;".format(find_name))print("循环结束") 运行结果1234&#123;&apos;name&apos;: &apos;xx&apos;&#125;&#123;&apos;name&apos;: &apos;yy&apos;&#125;没有找到SS循环结束]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中字符串的一些方法回顾]]></title>
    <url>%2F2018%2F07%2F25%2Fpython%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%E5%9B%9E%E9%A1%BE%2F</url>
    <content type="text"><![CDATA[python中字符串的一些方法回顾代码12345678910111213141516171819202122232425hello_str = "hello world"# 1、统计字符串长度print(len(hello_str))# 2、统计某一个小字符串出现的次数print(hello_str.count("llo"))# 3、某一个子字符串出现的位置print(hello_str.index("llo"))# 4、输出数学的平方num_str = "\u00b2"print(num_str)# 5、判断是否以指定字符串开始print(hello_str.startswith("hello"))# 6、判断是否以指定字符串结束print(hello_str.endswith("world"))# 7、查找指定字符串# 在index方法中，如果指定的字符串不存在，会直接报错# 在find方法中，如果指定的字符串不存在，会返回-1print(hello_str.find("llo"))print(hello_str.find("CCC"))# 8、替换字符串# replace方法执行完成之后会返回一个新的字符串，但是不会修改原有字符串的内容hh = hello_str.replace("world", "python")print(hh)print(hello_str) 运行结果123456789101112²TrueTrue2-1hello pythonhello world]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[list(列表)、tuple（元组）、dict（字典）的回顾]]></title>
    <url>%2F2018%2F07%2F25%2Flist(%E5%88%97%E8%A1%A8)%E3%80%81tuple%EF%BC%88%E5%85%83%E7%BB%84%EF%BC%89%E3%80%81dict%EF%BC%88%E5%AD%97%E5%85%B8%EF%BC%89%E7%9A%84%E5%9B%9E%E9%A1%BE%2F</url>
    <content type="text"><![CDATA[list(列表)、tuple（元组）、dict（字典）的回顾代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263list1 = [5, 6, 87, 671, 3, 54, 67, 0, 1, -6, -7]# 升序排序list1.sort()print(list1)# 降序排序list1.sort(reverse=True)print(list1)# 列表和元组之间相互转换print(type(list1))# 1、列表转换成元组num_tuple = tuple(list1)print(type(num_tuple))# 2 、元组转换成列表num2_list = list(num_tuple)print(type(num2_list))# 字典的使用# 1、取值dict_test = &#123;"name": "xxx"&#125;print(dict_test["name"])# 2、增加/修改dict_test["age"] = 18 # 增加dict_test["name"] = "yyy" # 修改print(dict_test)# 3、删除dict_test.pop("name")print(dict_test)# 4、统计键值对的数量print(len(dict_test))# 5、合并字典# 如果被合并的字典中包含已经存在的键值对，会覆盖原有的键值对temp_dict = &#123;"height": 123, "age": 20&#125;dict_test.update(temp_dict)print(dict_test)# 6、清空字典dict_test.clear()print(dict_test)# 7、迭代遍历字典# 变量k是每次循环中，获取到的键值对的值new_dict = &#123;"name": "xxx", "age": 20, "height": 200&#125;for k in new_dict: print("&#123;&#125; - &#123;&#125;".format(k, new_dict[k]))# 8、列表中保存多个字典,并用for循环迭代输出list2 = [ &#123;"name": "qqq", "email": "163", "phone": 119&#125;, &#123;"name": "sss", "email": "cc", "phone": 110&#125;]for i in list2: print(i) 运行结果12345678910111213141516[-7, -6, 0, 1, 3, 5, 6, 54, 67, 87, 671][671, 87, 67, 54, 6, 5, 3, 1, 0, -6, -7]&lt;class &apos;list&apos;&gt;&lt;class &apos;tuple&apos;&gt;&lt;class &apos;list&apos;&gt;xxx&#123;&apos;age&apos;: 18, &apos;name&apos;: &apos;yyy&apos;&#125;&#123;&apos;age&apos;: 18&#125;1&#123;&apos;age&apos;: 20, &apos;height&apos;: 123&#125;&#123;&#125;age - 20name - xxxheight - 200&#123;&apos;phone&apos;: 119, &apos;name&apos;: &apos;qqq&apos;, &apos;email&apos;: &apos;163&apos;&#125;&#123;&apos;phone&apos;: 110, &apos;name&apos;: &apos;sss&apos;, &apos;email&apos;: &apos;cc&apos;&#125; 总结总结： list使用的是方括号，类似与数组结构，tuple元组使用的是圆括号，跟list类似但是数据不能进行修改，所以应用的场景基本上用在需要数据存储，或者是需要保证数据安全无法修改的情况，字典用的是大括号，是key-value结构的, 操作数据的时候，是操作key，而不是索引。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打印九九乘法表]]></title>
    <url>%2F2018%2F07%2F24%2F%E6%89%93%E5%8D%B0%E4%B9%9D%E4%B9%9D%E4%B9%98%E6%B3%95%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[打印九九乘法表主要是练习python下的不同输出方式 代码1234567891011121314151617181920212223242526# 用for循环打印九九乘法表for i in range(1, 10): for j in range(1, 10): # 这里例举四种不同方式的打印方法 # 1、 # print("&#123;0&#125;*&#123;1&#125;=&#123;2&#125;".format(i, j, i * j), end='\t') # 2 、 # print("%d*%d=%2d" % (i, j, i * j), end='\t') # 3、 # print(i, "x", j, "=", i * j, "\t", end="") # 4、 print("&#123;&#125;*&#123;&#125;=&#123;&#125;".format(i, j, i * j), end='\t') if i == j: print("") break# 用while循环打印九九乘法表row = 1while row &lt;= 9: col = 1 while col &lt;= row: print("%d*%d=%2d" % (row, col, row * col), end='\t') col += 1 print("") row += 1 运行结果1234567891011121314151617181*1=1 2*1=2 2*2=4 3*1=3 3*2=6 3*3=9 4*1=4 4*2=8 4*3=12 4*4=16 5*1=5 5*2=10 5*3=15 5*4=20 5*5=25 6*1=6 6*2=12 6*3=18 6*4=24 6*5=30 6*6=36 7*1=7 7*2=14 7*3=21 7*4=28 7*5=35 7*6=42 7*7=49 8*1=8 8*2=16 8*3=24 8*4=32 8*5=40 8*6=48 8*7=56 8*8=64 9*1=9 9*2=18 9*3=27 9*4=36 9*5=45 9*6=54 9*7=63 9*8=72 9*9=81 1*1= 1 2*1= 2 2*2= 4 3*1= 3 3*2= 6 3*3= 9 4*1= 4 4*2= 8 4*3=12 4*4=16 5*1= 5 5*2=10 5*3=15 5*4=20 5*5=25 6*1= 6 6*2=12 6*3=18 6*4=24 6*5=30 6*6=36 7*1= 7 7*2=14 7*3=21 7*4=28 7*5=35 7*6=42 7*7=49 8*1= 8 8*2=16 8*3=24 8*4=32 8*5=40 8*6=48 8*7=56 8*8=64 9*1= 9 9*2=18 9*3=27 9*4=36 9*5=45 9*6=54 9*7=63 9*8=72 9*9=81]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打印直角三角形]]></title>
    <url>%2F2018%2F07%2F24%2F%E6%89%93%E5%8D%B0%E7%9B%B4%E8%A7%92%E4%B8%89%E8%A7%92%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[打印直角三角形做个对比 代码123456789101112# 嵌套循环版本打印直角三角形row = 1while row &lt;= 5: col = 1 while col &lt;= row: print("*", end=' ') col += 1 print() row += 1# python版本打印直角三角形for i in range(1, 6): print('* ' * i) 运行结果两者均为 12345* * * * * * * * * * * * * * *]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰器]]></title>
    <url>%2F2018%2F07%2F24%2F%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[装饰器装饰器（Decorators）是应用包装函数的快捷方式。这有助于将某一功能与一些代码一遍又一遍地“包装”。举个例子，我为自己创建了一个 retry 装饰器，这样我可以将其运用到任何函数之中，如果在一次运行中抛出了任何错误，它就会尝试重新运行，直到最大次数 5 次，并且每次运行期间都会有一定的延迟。这对于你在对一台远程计算机进行网络调用的情况十分有用： 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445# 从time模块引入sleep函数from time import sleepfrom functools import wrapsimport logginglogging.basicConfig()log = logging.getLogger("retry")def retry(f): @wraps(f) def wrapped_f(*args, **kwargs): MAX_ATTEMPTS = 5 for attempt in range(1, MAX_ATTEMPTS + 1): try: return f(*args, **kwargs) except: log.exception("Attempt %s %s failed : %s", attempt, MAX_ATTEMPTS, (args, kwargs)) sleep(10 * attempt) log.critical("All %s attempts failed : %s", MAX_ATTEMPTS, (args, kwargs)) return wrapped_fcounter = 0@retrydef save_to_database(arg): print("Write to a database or make a network call or etc.") print("This will be automatically retried if exception is thrown.") global counter counter += 1 # 这将在第一次调用时抛出异常 # 在第二次运行时正常工作（也就是重试） if counter &lt; 2: raise ValueError(arg)# 让你写的脚本模块既可以导入到别的模块中用，另外该模块自己也可执行。if __name__ == '__main__': save_to_database("Some bad value") 运行结果1234567891011ERROR:retry:Attempt 1 5 failed : (('Some bad value',), &#123;&#125;)Traceback (most recent call last): File "E:/PythonProject/more/more_decorators.py", line 16, in wrapped_f return f(*args, **kwargs) File "E:/PythonProject/more/more_decorators.py", line 40, in save_to_database raise ValueError(arg)ValueError: Some bad valueWrite to a database or make a network call or etc.This will be automatically retried if exception is thrown.Write to a database or make a network call or etc.This will be automatically retried if exception is thrown.]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[assert语句的运用]]></title>
    <url>%2F2018%2F07%2F24%2Fassert%E8%AF%AD%E5%8F%A5%E7%9A%84%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[assert语句的运用代码123456# assert语句# pop() 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值。mylist = ['item']assert len(mylist) &gt;= 1print(mylist.pop())assert len(mylist) &gt;= 1 运行结果12345itemTraceback (most recent call last): File "E:/PythonProject/more/more_assert.py", line 6, in &lt;module&gt; assert len(mylist) &gt;= 1AssertionError]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在函数中接受元组与字典]]></title>
    <url>%2F2018%2F07%2F24%2F%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E6%8E%A5%E5%8F%97%E5%85%83%E7%BB%84%E4%B8%8E%E5%AD%97%E5%85%B8%2F</url>
    <content type="text"><![CDATA[在函数中接受元组与字典 有一种特殊方法，即分别使用 * 或 ** 作为元组或字典的前缀，来使它们作为一个参数为函数所接收。当函数需要一个可变数量的实参时，这将非常有用。 代码12345678910111213141516# 当args变量前面添加了一个*时，函数的所有其他的参数都将传递到args中，并作为一个元组储存# 如果采用的是 ** 前缀，则额外的参数将被视为字典的键值—值配对。def powersum(power, *args): '''Return the sum of each argument raised to the specified power.''' total = 0 # 在for循环中，i每次获取的是args的值，也就是说初值由args而定 for i in args: total += pow(i, power) return total# 这里可以debug一下看下i的变化，在这里一开始的时候power=2，*args=（3，4）# i在初始时为3print(powersum(2, 3, 4))# 这里i初始时为10print(powersum(2, 10)) 运行结果 25100]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[列表推导]]></title>
    <url>%2F2018%2F07%2F24%2F%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[列表推导列表推导（List Comprehension）用于从一份现有的列表中得到一份新列表。想象一下，现在你已经有了一份数字列表，你想得到一个相应的列表，其中的数字在大于 2 的情况下将乘以2。列表推导就是这类情况的理想选择。 代码1234567891011121314151617# 列表推导'''程序理解：当满足了某些条件时（ if i &gt; 2 ），我们进行指定的操作（ 2*i ），以此来获得一份新的列表。要注意到原始列表依旧保持不变。'''listone = [2, 3, 4]listtwo = [2 * i for i in listone if i &gt; 2]print(listtwo)'''列表推导的优点在于，当我们使用循环来处理列表中的每个元素并将其存储到新的列表中时它能够减少代码量''' 运行结果 [6, 8]]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的lambda函数]]></title>
    <url>%2F2018%2F07%2F24%2Fpython%E4%B8%AD%E7%9A%84lambda%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[python中的lambda函数lambda函数相当于定义了一个匿名的函数，减少了代码量 代码1234567891011121314151617181920212223242526272829303132333435# Lambda表格 也是lambda函数points = [&#123;'x': 2, 'y': 3&#125;, &#123;'x': 4, 'y': 1&#125;]points.sort(key=lambda i: i['y'])print(points)'''要注意到一个 list 的 sort 方法可以获得一个 key 参数，用以决定列表的排序方式（通常我们只知道升序与降序）。在我们的案例中，我们希望进行一次自定义排序，为此我们需要编写一个函数，但是又不是为函数编写一个独立的 def 块，只在这一个地方使用，因此我们使用 Lambda 表达式来创建一个新函数。'''# lambda函数的其他使用方法add = lambda x, y: x + yprint(add(1, 2)) # 结果为3# 需求：将列表中的元素按照绝对值大小进行升序排列list1 = [3, 5, -4, -1, 0, -2, -6]print(sorted(list1, key=lambda x: abs(x)))'''等价于def get_abs(x): return abs(x)list1.sort(key=get_abs)print(list1)或者def get_abs(x): return abs(x) print(sorted(list1, key=get_abs))''' 运行结果123[&#123;&apos;y&apos;: 1, &apos;x&apos;: 4&#125;, &#123;&apos;y&apos;: 3, &apos;x&apos;: 2&#125;]3[0, -1, -2, 3, -4, 5, -6]]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的__name__ = '__main__' 的作用]]></title>
    <url>%2F2018%2F07%2F24%2Fpython%E7%9A%84__name__-%3D-__main__%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[python的name = ‘main‘ 的作用12345678__name__ = '__main__' 的作用先写一个模块：#module.pydef main(): print "we are in %s"%__name__if __name__ == '__main__': main() 我们经常看到想上面代码底下的代码，其主要的意义在于： 让你写的脚本即可以导入别的模块中用，另外该模块自己也可以执行这个函数定义了一个main函数，我们执行一下该py文件发现结果是打印出”we are in main“,说明我们的if语句中的内容被执行了，调用了main()： 但是如果我们从另我一个模块导入该模块，并调用一次main()函数会是怎样的结果呢？ 其执行的结果是：we are in module 但是没有显示 1”we are in __main__“ ,也就是说模块 1__name__ = &apos;__main__&apos; 下面的函数没有执行。 这样既可以让“模块”文件运行，也可以被其他模块引入，而且不会执行函数2次。这才是关键。 总结12345678如果我们是直接执行某个.py文件的时候，该文件中那么”__name__ == '__main__'“是True,但是我们如果从另外一个.py文件通过import导入该文件的时候，这时__name__的值就是我们这个py文件的名字而不是__main__。这个功能还有一个用处：调试代码的时候，在”if __name__ == '__main__'“中加入一些我们的调试代码，我们可以让外部模块调用的时候不执行我们的调试代码，但是如果我们想排查问题的时候，直接执行该模块文件，调试代码能够正常运行！]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多种方法快速交换两个变量的值]]></title>
    <url>%2F2018%2F07%2F24%2F%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%B3%95%E5%BF%AB%E9%80%9F%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC%2F</url>
    <content type="text"><![CDATA[使用多种方法快速交换两个变量的值 1、利用元组的快速交换变量值 2、引入新的变量来交换 3、使用加减法交换变量值 4、利用元组从一个函数中返回两个不同的值 代码12345678910111213141516171819202122232425# 1. 利用元组的快速交换变量值a = 5b = 8a, b = b, aprint(a, b)# 2. 引入新的变量来交换c = bb = aa = cprint(a, b)# 3. 使用加减法交换变量值a = a + bb = a - ba = a - bprint(a, b)# 4. 利用元组从一个函数中返回两个不同的值def get_error_details(): return (2, 'details')errnum, errstr = get_error_details()print(errnum)print(errstr) 运行结果123458 55 88 52details]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python日志模块]]></title>
    <url>%2F2018%2F07%2F23%2Fpython%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[日志模块的应用代码123456789101112131415161718192021222324252627# 日志模块import osimport platformimport logging# os.getenv()获取一个环境变量，如果没有返回none# os.path.join()： 将多个路径组合后返回if platform.platform().startswith('Windows'): logging_file = os.path.join(os.getenv('HOMEDRIVE'), os.getenv('HOMEPATH'), 'test.log')else: logging_file = os.path.join(os.getenv('HOME'), 'test.log')print("Logging to", logging_file)logging.basicConfig( level=logging.DEBUG, format='%(asctime)s: %(levelname)s :%(message)s', filename=logging_file, filemode='w',)# 日志文件将存储在电脑上logging.debug("Start of the program")logging.info("Doing something")logging.warning("Dying now") 运行结果12345Logging to C:\Users\dylink\test.log电脑查看该目录文件为2018-07-23 20:03:55,441: DEBUG :Start of the program2018-07-23 20:03:55,441: INFO :Doing something2018-07-23 20:03:55,441: WARNING :Dying now]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户自己引发的异常处理]]></title>
    <url>%2F2018%2F07%2F23%2F%E7%94%A8%E6%88%B7%E8%87%AA%E5%B7%B1%E5%BC%95%E5%8F%91%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[由用户自行定义的异常类处理代码12345678910111213141516171819202122232425# encoding = UTF-8# 用户自己引发异常class ShortInputException(Exception): '''一个由用户定义的异常类''' def __init__(self, length, atleast): Exception.__init__(self) self.length = length self.atleast = atleasttry: text = input('Enter someting --&gt;') if len(text) &lt; 3: raise ShortInputException(len(text), 3) # 其他工作能够在此处正常运行except EOFError: print('Why did you do an EOF on me?')except ShortInputException as ex: print(('ShortInputException: The input was ' + '&#123;0&#125; long,expected at least &#123;1&#125;') .format(ex.length, ex.atleast))else: print('No exception was raised.') 运行结果 1.如果输入超过了3位数，截获错误 12Enter someting --&gt;88888No exception was raised. 2.如果输入没有超过3位数 12Enter someting --&gt;12ShortInputException: The input was 2 long,expected at least 3]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[with open异常处理]]></title>
    <url>%2F2018%2F07%2F23%2Fwith-open%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[with open异常处理代码123456with open("poem.txt") as f: for line in f: print(line, end='')''' with open能够将之前的try..finally最后执行的关闭文件的操作，交给with open自动完成''' 运行结果 poem.txt里面的内容为：12165456478 1&gt;&gt;&gt;12165456478]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[finally异常处理]]></title>
    <url>%2F2018%2F07%2F23%2Ffinally%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[finally异常处理代码123456789101112131415161718192021222324import sysimport timef = Nonetry: f = open("poem.txt") # 我们常用的文件阅读风格 while True: line = f.readline() if len(line) == 0: break print(line, end='') sys.stdout.flush() print("Press ctrl+c now") # 为了确保它能运行一段时间 time.sleep(2) # time.sleep 函数任意在每打印一行后插入两秒休眠except IOError: print("Could not find file poem.txt")except KeyboardInterrupt: print("!! You cancelled the reading from the file.")finally: # 始终执行 if f: f.close() print("(Cleaning up: Closed the file)") 运行结果1212165456478Press ctrl+c now(Cleaning up: Closed the file)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单的异常处理]]></title>
    <url>%2F2018%2F07%2F23%2F%E7%AE%80%E5%8D%95%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[简单的异常处理代码12345678try: text = input('Enter someting --&gt;')except EOFError: # 按ctrl+D print('Why did you do an EOF on me?')except KeyboardInterrupt: # 按ctrl+C print('You cancelled the operation.')else: print('You enterd &#123;&#125;'.format(text)) 运行结果12Enter someting --&gt;^DWhy did you do an EOF on me?]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在打开文件的同时规定编码]]></title>
    <url>%2F2018%2F07%2F23%2F%E5%9C%A8%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E7%9A%84%E5%90%8C%E6%97%B6%E8%A7%84%E5%AE%9A%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[规定编码代码123456789101112131415161718# 在打开文件的同时规定编码'''如果你正在使用 Python 2，我们又希望能够读写其它非英语语言，我们需要使用unicode 类型，它全都以字母 u 开头，例如 u"hello world" 。&gt;&gt;&gt; u"hello world"'hello world''''# encoding = utf-8import iof = io.open("abc.txt", "wt", encoding="utf-8")f.write(u"Imagine non-English language here")f.close()text = io.open("abc.txt", encoding="utf-8").read()print(text) 运行结果 Imagine non-English language here]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的pickle模块]]></title>
    <url>%2F2018%2F07%2F23%2Fpython%E7%9A%84pickle%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[python的pickle模块Python 提供了一个叫作 Pickle 的标准模块，通过它你可以将任何纯 Python 对象存储到一个文件中，并在稍后将其取回。这叫作持久地（Persistently）存储对象。 代码123456789101112131415161718192021222324252627282930313233'''在Pickle模块中有2个常用的函数方法，一个叫做dump()，另一个叫做load()。pickle.dump(对象, 文件，[使用协议])load()方法的作用正好与上面的dump()方法相反，上面是序列化数据，这个方法作用是反序列化。pickle.load(文件)目的主要是为了将一些数据，如字符串、列表、字典等长期的以文件形式保存下来'''import pickle# The name of the file where we will store the objectshoplistfile = 'shoplist.data'# The list of things to buyshoplist = ['apple', 'mango', 'carrot']# Write to the filef = open(shoplistfile, 'wb')# Dump the object to a filepickle.dump(shoplist, f)f.close()# Destroy the shoplist variabledel shoplist# Read back from the storagef = open(shoplistfile, 'rb')# Load the object from the filestoredlist = pickle.load(f)print(storedlist) 运行结果1['apple', 'mango', 'carrot']]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件操作]]></title>
    <url>%2F2018%2F07%2F23%2F%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[文件操作代码12345678910111213141516171819202122232425262728poem = '''Programming is funWhen the work is doneif you wanna make your work also fun: use Python!'''# 打开文件以编辑（'w'riting）f = open('poem.txt', 'w')# 向文件中编写文本f.write(poem)# 关闭文件f.close()# 如果没有特别指定# 将假定启用默认的阅读（'r'ead）模式f = open('poem.txt')while True: line = f.readline() # 零长度指示 EOF , 用来判断文档结尾 if len(line) == 0: break # 每行（'line'）的末尾 # 都已经有了换行符 # 因为它是从一个文件中进行读取的 print(line, end=' ')# 关闭文件f.close() 运行结果1234Programming is funWhen the work is doneif you wanna make your work also fun: use Python!]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[输入输出——回文字串的判断（加强版）]]></title>
    <url>%2F2018%2F07%2F23%2F%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E2%80%94%E2%80%94%E5%9B%9E%E6%96%87%E5%AD%97%E4%B8%B2%E7%9A%84%E5%88%A4%E6%96%AD%EF%BC%88%E5%8A%A0%E5%BC%BA%E7%89%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[输入输出——回文字串的判断（加强版）123456789101112131415161718192021222324252627forbindden_word = (' ', ',', ';', '.', '!', '//', '?')# 样例字符串Rise to vote,sir. 共17长度def ignore_word(text): # 去除忽略的特殊字符 strdemo = list(text.lower()) count = 0 print('长度为:', len(strdemo)) for i in list(range(len(strdemo))): # 遍历从0-16，共17长度 ，debug一下就懂了 if strdemo[i - count] in forbindden_word: del strdemo[i - count] # 删除特殊字符 count += 1 return strdemodef reverse(text): return text[::-1]def is_reverse(text): # 判断是否为回文 return text == reverse(text)something = input('随便输入点什么:')if is_reverse(ignore_word(something)): print('恭喜！他是回文文本')else: print('这好像不是回文文本哦') 运行结果123随便输入点什么:Rise to vote,sir.长度为: 17恭喜！他是回文文本]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[输入输出——简单的回文判断]]></title>
    <url>%2F2018%2F07%2F23%2F%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E7%9A%84%E5%9B%9E%E6%96%87%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[输入输出——简单的回文判断代码123456789101112131415161718192021'''可以通过使用 seq[a:b] 来从位置 a 开始到位置 b 结束来对序列进行切片 。我们同样可以提供第三个参数来确定切片的步长（Step）。默认的步长为 1 ，它会返回一份连续的文本。如果给定一个负数步长，如 -1 ，将返回翻转过的文本。'''def reverse(text): return text[::-1] # 使用切片功能返回倒序def is_palindrome(text): return text == reverse(text) # 如果正序和倒序相等的话，就是回文something = input("Enter text: ")if is_palindrome(something): print("Yes,it is a palidrome") # 是回文else: print("No, it is not a palindrome") # 不是回文 运行结果 如果是回文字串 Enter text: 1221Yes,it is a palidrome 如果不是回文字串 Enter text: 11111555No, it is not a palindrome]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承的运用]]></title>
    <url>%2F2018%2F07%2F23%2F%E7%BB%A7%E6%89%BF%E7%9A%84%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[继承的运用代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 继承的运用# coding = UTF-8class SchoolMember: '''代表学校里的成员。''' def __init__(self, name, age): self.name = name self.age = age print('(Initialized SchoolMember: &#123;&#125;)'.format((self.name))) def tell(self): '''告诉我有关我的细节。''' print('Name:"&#123;&#125;" Age:"&#123;&#125;"'.format(self.name, self.age), end=" ")class Teacher(SchoolMember): '''代表一位老师。''' def __init__(self, name, age, salary): SchoolMember.__init__(self, name, age) self.salary = salary print('(Initialized Teacher: &#123;&#125;)'.format(self.name)) def tell(self): SchoolMember.tell(self) print('Salary: "&#123;:d&#125;"'.format(self.salary))class Student(SchoolMember): '''代表一位学生。''' def __init__(self, name, age, marks): SchoolMember.__init__(self, name, age) self.marks = marks print('(Initialized Student: &#123;&#125;)'.format(self.name)) def tell(self): SchoolMember.tell(self) print('Marks: "&#123;:d&#125;"'.format(self.marks))t = Teacher('Mrs. Shrividya', 40, 30000)s = Student('Swaroop', 25, 75)print()members = [t, s]for member in members: # 对全体师生工作 member.tell() 运行结果 1234567(Initialized SchoolMember: Mrs. Shrividya)(Initialized Teacher: Mrs. Shrividya)(Initialized SchoolMember: Swaroop)(Initialized Student: Swaroop)Name:"Mrs. Shrividya" Age:"40" Salary: "30000"Name:"Swaroop" Age:"25" Marks: "75"]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类变量与对象变量]]></title>
    <url>%2F2018%2F07%2F23%2F%E7%B1%BB%E5%8F%98%E9%87%8F%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[类变量与对象变量代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# coding=UTF-8,类变量与对象变量class Robot: """表示有一个带有名字的机器人。""" # 一个类变量，用来计数机器人的数量 population = 0 # 这是一个类变量，属于Robot类 def __init__(self, name): # name变量属于一个对象（通过self分配），因此它是一个对象变量 """初始化数据""" self.name = name print("(Initializing &#123;&#125;)".format(self.name)) # 当有人被创建时，机器人会增加人口数量 ''' 除了 Robot.popluation ，我们还可以使用 self.__class__.population ，因为每个对象都通过 self.__class__ 属性来引用它的类。 ''' Robot.population += 1 def die(self): """我挂了。""" print("&#123;&#125; is being destroyed!".format(self.name)) Robot.population -= 1 if Robot.population == 0: print("&#123;&#125; was the last one.".format(self.name)) else: print("There are still &#123;:d&#125; robots working.".format(Robot.population)) def say_hi(self): """来自机器人的诚挚问候 没问题，你做得到""" print("Greetings , my masters call me &#123;&#125;".format(self.name)) ''' classmethod 修饰符对应的函数不需要实例化，不需要 self 参数， 但第一个参数需要是表示自身类的 cls 参数，可以来调用类的属性，类的方法，实例化对象等。 ''' # how_many实际上是一个属于类而非属于对象的方法 # classmethod(类方法)或是一个staticmethod(静态方法) @classmethod # 装饰器，等价于how_many = classmethod(how_many) def how_many(cls): """打印出当前的人口数量""" print("We have &#123;:d&#125; robots.".format(cls.population))droid1 = Robot("R2-D2")droid1.say_hi()Robot.how_many()droid2 = Robot("C-3PO")droid2.say_hi()Robot.how_many()print("\nRobots can do some work here.\n")print("Robots have finished their work. So let's destroy them.")droid1.die()droid2.die()Robot.how_many() 运行结果 123456789101112131415(Initializing R2-D2)Greetings , my masters call me R2-D2We have 1 robots.(Initializing C-3PO)Greetings , my masters call me C-3POWe have 2 robots.Robots can do some work here.Robots have finished their work. So let's destroy them.R2-D2 is being destroyed!There are still 1 robots working.C-3PO is being destroyed!C-3PO was the last one.We have 0 robots.]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python对象的实例化]]></title>
    <url>%2F2018%2F07%2F23%2Fpython%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[python对象的实例化代码1234567891011121314'''__init__ 方法会在类的对象被实例化（Instantiated）时立即运行。这一方法可以对任何你想进行操作的目标对象进行初始化（Initialization）操作。'''class Person: def __init__(self, name): self.name = name def say_hi(self): print('Hello,my name is', self.name)p = Person('Swaroop')p.say_hi() 运行结果 Hello,my name is Swaroop]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用python进行文件的自动备份(第三版和第四版)]]></title>
    <url>%2F2018%2F07%2F23%2F%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD(%E7%AC%AC%E4%B8%89%E7%89%88%E5%92%8C%E7%AC%AC%E5%9B%9B%E7%89%88)%2F</url>
    <content type="text"><![CDATA[利用python进行文件的自动备份(第三版和第四版)代码12345678910111213141516171819202122232425262728293031323334353637383940414243import osimport time'''第三版和第四版差别不大整合在一起，用户注释的内容可以添加到文件名中来实现'''source = [r'E:\aaa.txt']target_dir = 'E:\\Backup\\'if not os.path.exists(target_dir): os.mkdir(target_dir)# 子目录名称today = target_dir + os.sep + time.strftime('%Y%m%d')# 将当前时间作为zio文件的文件名now = time.strftime('%H%M%S')# 添加一条来自用户的注释以创建# zip文件的文件名comment = input('Enter a comment --&gt;')# 检查是否有评论键入if len(comment) == 0: target = today + os.sep + now + '.zip'# replace函数中前面的将被替换为后面的else: target = today + os.sep + now + '_' + \ comment.replace(' ', '_') + '.zip'# 如果子目录尚不存在则创建一个if not os.path.exists(today): os.mkdir(today) print('Successfully created directory', today)zip_command = "7z a &#123;0&#125; &#123;1&#125;".format(target, ' '.join(source))# 运行备份print('Zip command is:')print(zip_command)print('Running:')if os.system(zip_command) == 0: print('Successful backup to', target)else: print('Backup FAILED') 运行结果 12345678910111213141516171819Enter a comment --&gt;This is my backupZip command is:7z a E:\Backup\\20180723\185735_This_is_my_backup.zip E:\aaa.txtRunning:7-Zip 18.05 (x64) : Copyright (c) 1999-2018 Igor Pavlov : 2018-04-30Scanning the drive:1 file, 10 bytes (1 KiB)Creating archive: E:\Backup\\20180723\185735_This_is_my_backup.zipAdd new data to archive: 1 file, 10 bytes (1 KiB)Files read from disk: 1Archive size: 158 bytes (1 KiB)Everything is OkSuccessful backup to E:\Backup\\20180723\185735_This_is_my_backup.zip]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用python进行文件的自动备份（第二版）]]></title>
    <url>%2F2018%2F07%2F23%2F%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[利用python进行文件的自动备份（第二版）代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import osimport time'''第二版是第一版的改进，启用一种更好的文件命名机制——使用时间作为文件名，存储在以当前时间为名字的文件夹中，这一文件夹则照常存储在主备份目录下。'''# 例如在 Windows 下：source = [r'E:\aaa.txt']# 在这里要注意到我们必须在字符串中使用双引号# 用以括起其中包含空格的名称。# 2. 备份文件必须存储在一个# 主备份目录中# 例如在 Windows 下：target_dir = 'E:\\Backup\\'# 要记得将这里的目录地址修改至你将使用的路径# 如果目标目录还不存在，则进行创建if not os.path.exists(target_dir): os.mkdir(target_dir) # 创建目录# 3.备份文件将打包压缩成zip文件# 4.zip压缩文件的文件名由当前日期与时间构成# 其中os.sep 表示更改操作系统中的路径分隔符today = target_dir + os.sep + time.strftime('%Y%m%d')# 将当前时间作为zip文件的文件名now = time.strftime('%H%M%S')# zip文件名称格式target = today + os.sep + now + 'zip'# 如果子目录尚不存在则创建一个if not os.path.exists(today): os.mkdir(today) print('Successfully created diectory', today)# 5.原本这里是使用zip命令，但是在windows环境下面这个是不是系统命令，所以解决方案如下：'''1.1.下载7-Zip并安装2.将安装文件中的7z.exe移至‘C:\Windows’目录下3.将程序中的 zip_command = "zip -qr '%s' %s"%(target,''.join(source))改为：zip_command = "7z a %s %s"%(target, ' '.join(source))或者是"7z a &#123;0&#125; &#123;1&#125;".format(target, ' '.join(source))'''zip_command = "7z a &#123;0&#125; &#123;1&#125;".format(target, ' '.join(source))# 运行备份print('Zip command is:')print(zip_command)print('Running:')if os.system(zip_command) == 0: print('Successful backup to', target)else: print('Backup FAILED') 运行结果123456789101112131415161718Zip command is:7z a E:\Backup\\20180723\185035zip E:\aaa.txtRunning:7-Zip 18.05 (x64) : Copyright (c) 1999-2018 Igor Pavlov : 2018-04-30Scanning the drive:1 file, 10 bytes (1 KiB)Creating archive: E:\Backup\\20180723\185035zip.7zAdd new data to archive: 1 file, 10 bytes (1 KiB)Files read from disk: 1Archive size: 136 bytes (1 KiB)Everything is OkSuccessful backup to E:\Backup\\20180723\185035zip]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用python进行文件的自动备份]]></title>
    <url>%2F2018%2F07%2F22%2F%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD%2F</url>
    <content type="text"><![CDATA[利用Python进行文件的自动备份（第一版）os.system 函数的命令，这一函数可以使命令像是从系统中运行的。也就是说，从 shell 中运行的——如果运行成功，它将返回 0 ，如果运行失败，将返回一个错误代码。 针对 Windows 用户的提示除了使用双反斜杠转义序列，你还可以使用原始字符串。例如使用 ‘C:\Documents’ 或r’C:\Documents’ 。然而，不要使用 ‘C:\Documents’ ，因为它将被识别为你使用了一个未知的转义序列 \D 来结束路径的输入。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243import osimport time# 1. 需要备份的文件与目录将被# 指定在一个列表中。# 例如在 Windows 下：source = [r'E:\aaa.txt']# 在这里要注意到我们必须在字符串中使用双引号# 用以括起其中包含空格的名称。# 2. 备份文件必须存储在一个# 主备份目录中# 例如在 Windows 下：target_dir = 'E:\\Backup\\'# 要记得将这里的目录地址修改至你将使用的路径# 3.备份文件将打包压缩成zip文件# 4.zip压缩文件的文件名由当前日期与时间构成# 其中os.sep 表示更改操作系统中的路径分隔符target = target_dir + os.sep + \ time.strftime('%Y%m%d%H%M%S') + '.zip'# 如果目标目录还不存在，则进行创建if not os.path.exists(target_dir): os.mkdir(target_dir) # 创建目录# 5.原本这里是使用zip命令，但是在windows环境下面这个是不是系统命令，所以解决方案如下：'''1.1.下载7-Zip并安装2.将安装文件中的7z.exe移至‘C:\Windows’目录下3.将程序中的 zip_command = "zip -qr '%s' %s"%(target,''.join(source))改为：zip_command = "7z a %s %s"%(target, ' '.join(source))'''zip_command = "7z a %s %s" % (target, ' '.join(source))# 运行备份print('Zip command is:')print(zip_command)print('Running:')if os.system(zip_command) == 0: print('Successful backup to', target)else: print('Backup FAILED') 输出结果 1 file, 10 bytes (1 KiB) Creating archive: E:\Backup\20180722160831.zip Add new data to archive: 1 file, 10 bytes (1 KiB) Files read from disk: 1 Archive size: 158 bytes (1 KiB) Everything is Ok Successful backup to E:\Backup\20180722160831.zip]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的集合]]></title>
    <url>%2F2018%2F07%2F07%2Fpython%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[集合集合（Set）是简单对象的无序集合（Collection）。当集合中的项目存在与否比起次序或其出现次数更加重要时，我们就会使用集合。通过使用集合，你可以测试某些对象的资格或情况，检查它们是否是其它集合的子集，找到两个集合的交集，等等。 代码12345678910111213# 集合 判断子集bri = set(['brazil', 'russia', 'india'])if 'india' in bri: print('True')if 'usa' in bri: print('False')bric = bri.copy()bric.add('china')print(bric.issuperset(bri))bri.remove('russia')print(bri &amp; bric) 输出结果TrueTrue{‘india’, ‘brazil’}]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中字典（key-value）]]></title>
    <url>%2F2018%2F07%2F07%2Fpython%E4%B8%AD%E5%AD%97%E5%85%B8%EF%BC%88key-value%EF%BC%89%2F</url>
    <content type="text"><![CDATA[字典（key-value）字典就像一本地址簿，如果你知道了他或她的姓名，你就可以在这里找到其地址或是能够联系上对方的更多详细信息，换言之，我们将键值（Keys）（即姓名）与值（Values）（即地址等详细信息）联立到一起。在这里要注意到键值必须是唯一的，正如在现实中面对两个完全同名的人你没办法找出有关他们的正确信息。 代码123456789101112131415161718192021222324252627# 字典# "ab"是地址（Address）薄(Book)的缩写ab = &#123; 'Swaroop': 'swaroop@swaroopch.com', 'Larry': 'larry@wall.org', 'Matsumoto': 'matz@ruby-lang.org', 'Spammer': 'spammer@hptmail.com'&#125;print("Swaroop's address is", ab['Swaroop'])# 删除一对键值-值配对del ab['Spammer']print('\nThere are &#123;&#125; contacts in the address-book\n'.format(len(ab)))#我们通过使用字典的 item 方法来访问字典中的每一对键值—值配对信息，这一操作将返回一份包含元组的列表for name, address in ab.items(): print('Contact &#123;&#125; at &#123;&#125;'.format(name, address))# 添加一对键值-值配对ab['Guido'] = 'guido@python.org'if 'Guido' in ab: print("\nGuido's address is", ab['Guido'])]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的列表]]></title>
    <url>%2F2018%2F07%2F07%2Fpython%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[列表列表 是一种用于保存一系列有序项目的集合，也就是说，你可以利用列表保存一串项目的序列。想象起来也不难，你可以想象你有一张购物清单，上面列出了需要购买的商品，除开在购物清单上你可能为每件物品都单独列一行，在 Python 中你需要在它们之间多加上一个逗号。 代码123456789101112131415161718192021222324252627# 列表# This is my shopping list'''在这里要注意在调用 print 函数时我们使用 end 参数，这样就能通过一个空格来结束输出工作，而不是通常的换行。'''shoplist = ['apple', 'mango', 'carrot', 'banana']print('I have', len(shoplist), 'items to purchase')print('These item are:', end=' ')for item in shoplist: print(item, end=' ')print('\nI also have to buy rice.')shoplist.append('rice')print('My shopping list is now', shoplist)print('I will sort my list now')shoplist.sort()print('Sorted shopping list is', shoplist)print('The first item I will buy is', shoplist[0])olditem = shoplist[0]del shoplist[0]print('I bought the', olditem)print('My shopping list is now', shoplist)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的元组]]></title>
    <url>%2F2018%2F07%2F07%2Fpython%E4%B8%AD%E7%9A%84%E5%85%83%E7%BB%84%2F</url>
    <content type="text"><![CDATA[元组元组（Tuple）用于将多个对象保存到一起。你可以将它们近似地看作列表，但是元组不能提供列表类能够提供给你的广泛的功能。元组的一大特征类似于字符串，它们是不可变的，也就是说，你不能编辑或更改元组。元组是通过特别指定项目来定义的，在指定项目时，你可以给它们加上括号，并在括号内部用逗号进行分隔。元组通常用于保证某一语句或某一用户定义的函数可以安全地采用一组数值，意即元组内的数值不会改变。 代码123456789101112131415# 元组'''推荐使用括号来指明元组的开始和结束尽管括号是一个可选选项明了胜过晦涩，显式优于隐式'''zoo = ('python', 'elephant', 'penguin')print('Number of animals in the zoo is', len(zoo))new_zoo = 'monkey', 'camel', zooprint('Number of animals in the zoo is', len(new_zoo))print('All animals in new zoo are', new_zoo)print('Animals brought from old zoo are', new_zoo[2])print('Last animal brought from old zoo is', new_zoo[2][2])print('Number of animals in the new zoo is', len(new_zoo) - 1 + len(new_zoo[2]))]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的序列以及切片的解释]]></title>
    <url>%2F2018%2F07%2F07%2Fpython%E4%B8%AD%E7%9A%84%E5%BA%8F%E5%88%97%E4%BB%A5%E5%8F%8A%E5%88%87%E7%89%87%E7%9A%84%E8%A7%A3%E9%87%8A%2F</url>
    <content type="text"><![CDATA[python中的序列以及切片的解释切片：有一种切片（Slicing）运算符，它能够允许我们序列中的某段切片——也就是序列之中的一部分。 序列1234567891011121314151617181920212223242526272829303132333435# 序列 跑一下看看shoplist = ['apple', 'mango', 'carrot', 'banana']name = 'swaroop'# Indexing or 'Subscription' operation ## 索引或“下标（Subcription）”操作符 #print('Item 0 is', shoplist[0])print('Item 1 is', shoplist[1])print('Item 2 is', shoplist[2])print('Item 3 is', shoplist[3])print('Item -1 is', shoplist[-1])print('Item -2 is', shoplist[-2])print('Character 0 is', name[0])# Slicing on a list #print('Item 1 to 3 is', shoplist[1:3])print('Item 2 to end is', shoplist[2:])print('Item 1 to -1 is', shoplist[1:-1])print('Item start to end is', shoplist[:])# 从某一字符串中切片 #print('characters 1 to 3 is', name[1:3])print('characters 2 to end is', name[2:])print('characters 1 to -1 is', name[1:-1])print('characters start to end is', name[:])'''你会注意到当步长为 2 时，我们得到的是第 0、2、4…… 位项目。当步长为 3 时，我们得到的是第 0、3……位项目。'''print(shoplist[::1])print(shoplist[::2])print(shoplist[::3])print(shoplist[::-1])]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中字符串的一些基本操作]]></title>
    <url>%2F2018%2F07%2F07%2Fpython%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[python字符串的一些基本操作在这里，我们会看见一此操作中包含了好多字符串方法。 startwith 方法用于查找字符串是否以给定的字符串内容开头。 in 运算符用以检查给定的字符串是否是查询的字符串中的一部分。find 方法用于定位字符串中给定的子字符串的位置。如果找不到相应的子字符串， find会返回 -1。 str 类同样还拥有一个简洁的方法用以 联结（Join） 序列中的项目，其中字符串将会作为每一项目之间的分隔符，并以此生成并返回一串更大的字符串。 123456789101112131415# 这是一个字符串对象name = 'Swaroop'if name.startswith('Swa'): print('Yes, the string starts with "Swa"')if 'a' in name: print('Yes, it contains the string "a"')if name.find('war') != -1: print('Yes,it contains the string "war"')delimiter = '_*_'mylist = ['Brazil', 'Russia', 'India', 'China']print(delimiter.join(mylist))]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的引用和切片]]></title>
    <url>%2F2018%2F07%2F07%2Fpython%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8%E5%92%8C%E5%88%87%E7%89%87%2F</url>
    <content type="text"><![CDATA[引用和切片造成的不同影响当你创建了一个对象并将其分配给某个变量时，变量只会查阅（Refer）某个对象，并且它也不会代表对象本身。也就是说，变量名只是指向你计算机内存中存储了相应对象的那一部分。这叫作将名称绑定（Binding）给那一个对象。一般来说，你不需要去关心这个，不过由于这一引用操作困难会产生某些微妙的效果，这是需要你注意的： 123456789101112131415161718192021222324252627'''如果直接引用对象的话，对mylist操作也会影响到原本的shoplist如果想要不影响原本的，必须引用的是对象的切片，切片即为副本'''print('Simple Assignment')shoplist = ['apple', 'mango', 'carrot', 'banana']# mylist 只是指向同一对象的另一种名称mylist = shoplist# 我购买了第一项项目，所以我将其从列表中删除del shoplist[0]print('shoplist is', shoplist)print('mylist is', mylist)# 注意到 shoplist 和 mylist 二者都# 打印出了其中都没有 apple 的同样的列表，以此我们确认# 它们指向的是同一个对象print('Copy by making a full slice')# 通过生成一份完整的切片制作一份列表的副本mylist = shoplist[:]# 删除第一个项目del mylist[0]print('shoplist is', shoplist)print('mylist is', mylist)# 注意到现在两份列表已出现不同]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的Docstring]]></title>
    <url>%2F2018%2F06%2F27%2Fpython%E4%B8%AD%E7%9A%84Docstring%2F</url>
    <content type="text"><![CDATA[基本教程1234567891011121314151617181920212223242526'''文档字符串的应用该文档字符串所约定的是一串多行字符串，其中第一行以某一大写字母开始，以句号结束。第二行为空行，后跟的第三行开始是任何详细的解释说明。 在此强烈建议你在有关你所有非凡功能的文档字符串中都遵循这一约定。'''def print_max(x, y): '''Prints the maximum of two numbers.打印两个数值中的最大数。 The two values must be integers.这两个数都应该是整数 ''' # 如果可能，将其转换至整数类型 x = int(x) y = int(y) if x &gt; y: print(x, 'is maximum') else: print(y, 'is maximum')print_max(3, 5)print(print_max.__doc__)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大公约数和最小公倍数]]></title>
    <url>%2F2018%2F04%2F10%2F%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[使用的辗转相除法辗转相除法：辗转相除法是求两个自然数的最大公约数的一种方法，也叫欧几里德算法。 例如，求（319，377）： ∵ 319÷377=0（余319） ∴（319，377）=（377，319）； ∵ 377÷319=1（余58） ∴（377，319）=（319，58）； ∵ 319÷58=5（余29） ∴ （319，58）=（58，29）； ∵ 58÷29=2（余0） ∴ （58，29）= 29； ∴ （319，377）=29。 可以写成右边的格式。 用辗转相除法求几个数的最大公约数，可以先求出其中任意两个数的最大公约数，再求这个最大公约数与第三个数的最大公约数，依次求下去，直到最后一个数为止。最后所得的那个最大公约数，就是所有这些数的最大公约数。 代码 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;int main() &#123; int maxgongyue(int x,int y); int mingongbei(int num,int finax); int x,y,num; printf("请输入俩个数:\n"); scanf("%d %d",&amp;x,&amp;y); num=x*y; printf("最大公约数是:%d\n",maxgongyue(x,y)); printf("最小公倍数是:%d\n",mingongbei(num,maxgongyue(x,y))); return 0;&#125;int maxgongyue(int x,int y)&#123; int temp,yushu; if(x&lt;y) &#123; //交换成大的在前，小的在后 temp=x; x=y; y=temp; &#125; while(y!=0) &#123; //辗转相除法，如果余数不为0，则循环 yushu=x%y; //求余数 x=y; //将小的赋值给大的 y=yushu; //将余数赋值给小的 &#125;//一直除到余数为0时，这时候的x就是最大公约数 return(x);&#125;int mingongbei(int num,int finax)&#123; return(num/finax);&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>经典算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折半查找]]></title>
    <url>%2F2018%2F04%2F10%2F%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[折半查找定义二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列 查找过程首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。 比较次数 当顺序表有n个关键字时： 查找失败时，至少比较a次关键字；查找成功时，最多比较关键字次数是b。 注意：a,b,n均为正整数。 算法复杂度折半查找法也称为二分查找法，它充分利用了元素间的次序关系，采用分治策略，可在最坏的情况下用O(log n)完成搜索任务。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;stdio.h&gt;#define N 5//折半查找算法int main() &#123; int a[N],i,j,low=0,high=N-1,mid,flag,num; printf("请输入5个数:\n"); scanf("%d",&amp;a[0]); i=1; //升序输入 while(i&lt;N) &#123; scanf("%d",&amp;a[i]); if(a[i]&gt;=a[i-1]) &#123; i++; &#125; else &#123; printf("重新输入数据:\n"); &#125; &#125; printf("\n"); for(i=0; i&lt;N; i++) &#123; printf("%5d",a[i]); &#125; printf("\n请输入你要查询的数字:\n"); scanf("%d",&amp;num); if((num&lt;a[0])||(num&gt;a[N-1])) &#123; printf("该数不在区间范围内\n"); &#125; while(low&lt;=high) &#123; mid = (low + high)/2; if(num==a[mid])&#123; flag=mid; //记录这个数的位置 printf("找到了%d,这个数在第%d号位置",num,flag+1); break; &#125; else if (num &gt; a[mid]) &#123; low = mid+1; &#125; else if (num &lt; a[mid]) &#123; high = mid - 1; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>经典算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[任意行数的杨辉三角形（动态分配）]]></title>
    <url>%2F2018%2F04%2F10%2F%E4%BB%BB%E6%84%8F%E8%A1%8C%E6%95%B0%E7%9A%84%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%88%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%EF%BC%89%2F</url>
    <content type="text"><![CDATA[杨辉三角形金字塔型和直角三角形 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main() &#123; int i,j,num; int **a; printf("请输入你想打印的杨辉三角形行数:\n"); scanf("%d",&amp;num); a=(int **)malloc(num*sizeof(int *)); for (i = 0; i &lt; num; ++i) &#123; //为每列分配num个大小空间 a[i] = (int*)malloc(sizeof(int)*num); &#125; //书上分开打印// for(i=0; i&lt;num; i++) &#123;// a[i][i]=1;// a[i][0]=1;// &#125;// for(i=2; i&lt;num; i++) &#123;// for(j=1; j&lt;=i-1; j++) &#123;// a[i][j]=a[i-1][j-1]+a[i-1][j];// &#125;// &#125;// for(i=0;i&lt;num;i++)&#123;// for(j=0;j&lt;=i;j++)&#123;// printf("%4d",a[i][j]);// &#125;// printf("\n");// &#125;// printf("\n"); //优化 for(i=0; i&lt;num; i++) &#123; for(j=0; j&lt;=i; j++) &#123;// if(i==0||j==0||j==i) &#123;// a[i][j]=1;// &#125; else &#123;// a[i][j]=a[i-1][j-1]+a[i-1][j];// &#125; printf("%4d",(a[i][j])=(i==0||j==0||j==i)?1:a[i-1][j-1]+a[i-1][j]); &#125; printf("\n"); &#125;// for(i=0; i&lt;num; i++) &#123;// for(j=0; j&lt;=i; j++) &#123;// printf("%4d",a[i][j]);// &#125;// printf("\n");// &#125; for (i = 0; i &lt; num; i++) &#123; free(a[i]); &#125; free(a); printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>经典算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F2018%2F04%2F10%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序概念冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。 它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名“冒泡排序”。 算法原理冒泡排序算法的运作如下：（从后往前） 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 时间复杂度冒泡排序总的平均时间复杂度为 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;int main()&#123; void sort(int *x,int n); int i,*p,a[10]; p=a; printf("请输入10个整数:\n"); for(i=0;i&lt;10;i++)&#123; scanf("%d",p++); &#125; p=a; sort(p,10); for(p=a,i=0;i&lt;10;i++)&#123; printf("%d ",*p++); &#125; printf("\n"); return 0;&#125;//数组形式 void sort(int x[],int n)&#123; int i,j,temp; for(i=0;i&lt;n-1;i++) for(j=0;j&lt;n-1-i;j++)&#123; if(x[j]&lt;x[j+1])&#123; temp=x[j]; x[j]=x[j+1]; x[j+1]=temp; &#125; &#125;&#125;//指针形式 void sort(int *x,int n)&#123; int i,j,temp; for(i=0;i&lt;n-1;i++) for(j=0;j&lt;n-1-i;j++)&#123; if(*(x+j)&lt;*(x+j+1))&#123; //*(x+j)就是x[j] temp=*(x+j); *(x+j)=*(x+j+1); *(x+j+1)=temp; &#125; &#125;&#125; ​]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[整合建立输出增删改查的链表]]></title>
    <url>%2F2018%2F04%2F08%2F%E6%95%B4%E5%90%88%E5%BB%BA%E7%AB%8B%E8%BE%93%E5%87%BA%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E7%9A%84%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[简单贴一下链表的建立等常用操作 链表定义链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define LEN sizeof(struct Student)//输入格式 1 89// 2 99// 0 0struct Student &#123; long num; float score; struct Student *next;&#125;;int n;struct Student *creat();struct Student *del(struct Student *head,long num);struct Student *insert(struct Student *head,struct Student *stu);void print(struct Student *head);int main() &#123; struct Student *head,*stu; long del_num; printf("请输入数据:\n"); head=creat(); print(head); printf("请输入要删除的数字:\n"); scanf("%ld",&amp;del_num); while(del_num!=0) &#123; //当输入的学号为0时结束循环 head=del(head,del_num); //删除结点后返回链表的头地址 print(head); //输出全部结点 printf("请输入要删除的数字:\n"); scanf("%ld",&amp;del_num); &#125; printf("请输入要添加的数据:\n"); stu=(struct Student *)malloc(LEN); //开辟一个新结点 scanf("%ld %f",&amp;stu-&gt;num,&amp;stu-&gt;score); while(stu-&gt;num!=0) &#123; //当输入的学号为0时结束循环 head=insert(head,stu); //返回链表的头地址，赋值给head print(head); //输出全部结点 printf("请输入要添加的数据:\n"); stu=(struct Student *)malloc(LEN); //开辟一个新结点 scanf("%ld %f",&amp;stu-&gt;num,&amp;stu-&gt;score); &#125; return 0;&#125;struct Student *creat(void) &#123; //返回一个指向链表头的指针 struct Student *head; struct Student *p1,*p2; n=0; p1=p2=(struct Student *)malloc(LEN);//开辟一个新的结点使p1，p2指向它 scanf("%ld %f",&amp;p1-&gt;num,&amp;p1-&gt;score);//输入第1个学生的学号和成绩 head=NULL; while(p1-&gt;num!=0) &#123; n=n+1; if(n==1) &#123; //如果这个结点是头结点，那么就把head指向p1 head=p1; &#125; else &#123; p2-&gt;next=p1; //如果不是，则使这个结点的next指向新开辟结点 &#125; p2=p1; //使p2指向刚才建立的结点 p1=(struct Student *)malloc(LEN);//生成新的结点 ，使p1指向它 scanf("%ld %f",&amp;p1-&gt;num,&amp;p1-&gt;score); &#125; p2-&gt;next=NULL; //当p2是表尾时，把NULL赋值给next，结束链表建立 return(head);&#125;void print(struct Student *head) &#123; struct Student *p; printf("\nNow,These %d records are:\n",n); p=head; if(head!=NULL) &#123; do &#123; printf("%ld %5.1f\n",p-&gt;num,p-&gt;score); p=p-&gt;next; &#125; while(p!=NULL); &#125;&#125;struct Student *insert(struct Student *head,struct Student *stu) &#123; struct Student *p0,*p1,*p2; p1=head; //使p1指向头结点 p0=stu; //指向要插入的结点 if(head==NULL) &#123; //原来的链表是空表 head=p0; p0-&gt;next=NULL; &#125; else &#123; while((p0-&gt;num&gt;p1-&gt;num)&amp;&amp;(p1-&gt;next!=NULL)) &#123; p2=p1; //使p2指向刚才p1指向的结点 p1=p1-&gt;next;//p1后移一个结点 &#125; if(p0-&gt;num&lt;p1-&gt;num) &#123; if(head==p1) &#123; head=p0; //插到原来第1个结点之前 &#125; else &#123; p2-&gt;next=p0;//插到p2指向的结点之后 p0-&gt;next=p1; &#125; &#125; else &#123; p1-&gt;next=p0; p0-&gt;next=NULL; //插到最后的结点之后 &#125; &#125; n=n+1; return(head); //结点数+1&#125;struct Student *del(struct Student *head,long num) &#123; struct Student *p1,*p2; if(head==NULL) &#123; printf("这是一张空表\n"); return(head); &#125; p1=head; //使p1指向第1个结点 while(num!=p1-&gt;num&amp;&amp;p1-&gt;next!=NULL) &#123; //p1指向的不是所要找的结点且后面还有结点 p2=p1; p1=p1-&gt;next; //p1向后移一个结点 &#125; if(num==p1-&gt;num) &#123; //找到了 if(p1==head) &#123; //若p1指向的是首结点，把第2个结点地址赋予head head=p1-&gt;next; &#125; else &#123; //否则将下一个结点地址赋给前一结点地址 p2-&gt;next=p1-&gt;next; &#125; printf("删除:%ld\n",num); n=n-1; &#125; else &#123; printf("%ld没有找到\n",num);//找不到该结点 &#125; return(head);&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>链表算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择排序]]></title>
    <url>%2F2018%2F04%2F08%2F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[简单的写一下选择排序的源代码定义选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法（比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，导致第一个5挪动到第二个5后面）。 时间复杂度选择排序的交换操作介于 0 和 (n - 1） 次之间。选择排序的比较操作为 n (n - 1） / 2 次之间。选择排序的赋值操作介于 0 和 3 (n - 1） 次之间。 比较次数O(n^2），比较次数与关键字的初始状态无关，总的比较次数N=(n-1）+(n-2）+…+1=n*(n-1）/2。交换次数O(n），最好情况是，已经有序，交换0次；最坏情况交换n-1次，逆序交换n/2次。交换次数比冒泡排序少多了，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快 参考代码 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;//选择排序 int main() &#123; void selectsort(int array[],int n); int a[10],i; printf("输入10个数:\n"); for(i=0; i&lt;10; i++) &#123; scanf("%d",&amp;a[i]); &#125; selectsort(a,10); printf("选择排序之后:\n"); for(i=0; i&lt;10; i++) &#123; printf("%d ",a[i]); &#125; printf("\n"); return 0;&#125;void selectsort(int array[],int n) &#123; int i,j,min,temp; for(i=0; i&lt;n-1; i++) &#123; min=i; for(j=i+1; j&lt;n; j++)&#123; if(array[j]&lt;array[min]) min=j; &#125; temp=array[min]; array[min]=array[i]; array[i]=temp; &#125;&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博客测试]]></title>
    <url>%2F2018%2F04%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[这是我的第一篇博客= =，成功搭建了本网站地址 第一级标题生成一个hexo博客1$ hexo new "My New Post" 更多的信息: Writing 在本地跑起来1$ hexo server 更多的信息: Server 生成静态文件（保存） 1$ hexo generate 更多的信息: Generating 上传到github1$ hexo deploy 更多的信息: Deployment]]></content>
      <categories>
        <category>博客测试文件</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
</search>
