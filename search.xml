<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode-76-最小覆盖字串]]></title>
    <url>%2F2020%2F08%2F19%2FLeetCode-76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%97%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[LeetCode-76-最小覆盖字串给你一个字符串 S、一个字符串 T 。请你设计一种算法，可以在 O(n) 的时间复杂度内，从字符串 S 里面找出：包含 T 所有字符的最小子串。 示例1： 12输入：S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;输出：&quot;BANC&quot; 提示： 如果 S 中不存这样的子串，则返回空字符串 &quot;&quot;。 如果 S 中存在这样的子串，我们保证它是唯一的答案。 解题思路方法1、滑动窗口(数组)： 示例中只列出了大写字母，但实际测试中含有小写字母，且同一字母可能会出现多次 用2个128长度的数组存储窗口window和实际需要的数组need 先将两个字串转为char数组，用need数组存储对应字符的出现次数 初始化滑动窗口指针，left、right、valid(记录匹配的长度) 因为需要返回匹配的最短字串，所以使用start和end指针记录子串的首尾位置 当右边界小于s的长度时，进行窗口滑动，直到包含t中所有字符为止 当valid长度达到t子串长度时，停止增加右边界，记录当前匹配的串的start和end；之后不断减小左边界，直到窗口中的字符不符合要求 重复4、5步，直到right达到s长度 返回子串start,start+end 方法2、滑动窗口(哈希表)： 和上面类似，改为哈希表存储 Java代码112345678910111213141516171819202122232425262728293031323334class Solution &#123; public String minWindow(String s, String t) &#123; char[] arrs = s.toCharArray(); char[] arrt = t.toCharArray(); int[] window = new int[128]; int[] need = new int[128]; for (int i = 0; i &lt; arrt.length; i++) &#123; need[arrt[i]]++; &#125; int left = 0, right = 0, valid = 0; int start = 0, end = Integer.MAX_VALUE; while (right &lt; arrs.length) &#123; char cright = arrs[right]; right++; window[cright]++; if (window[cright] &lt;= need[cright]) &#123; valid++; &#125; while (valid == arrt.length) &#123; if (right - left &lt; end) &#123; start = left; end = right - left; &#125; char cleft = arrs[left]; left++; if (window[cleft] == need[cleft]) &#123; valid--; &#125; window[cleft]--; &#125; &#125; return end == Integer.MAX_VALUE ? "" : s.substring(start, start + end); &#125;&#125; Java代码212345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public String minWindow(String s, String t) &#123; Map&lt;Character,Integer&gt; need = new HashMap&lt;&gt;(); Map&lt;Character,Integer&gt; window = new HashMap&lt;&gt;(); for(char c: t.toCharArray())&#123; need.put(c,need.getOrDefault(c,0)+1); &#125; int left = 0,right = 0; int valid = 0; int start = 0,len = Integer.MAX_VALUE; while(right&lt;s.length())&#123; char cright = s.charAt(right); right++; if(need.containsKey(cright))&#123; window.put(cright,window.getOrDefault(cright,0)+1); if((int)window.get(cright)==(int)need.get(cright))&#123; valid++; &#125; &#125; while(valid==need.size())&#123; if(right-left&lt;len)&#123; start = left; len = right - left; &#125; char dleft = s.charAt(left); left++; if(need.containsKey(dleft))&#123; if((int)window.get(dleft)==(int)need.get(dleft))&#123; valid--; &#125; window.put(dleft,window.get(dleft)-1); &#125; &#125; &#125; return len==Integer.MAX_VALUE? "" : s.substring(start,start+len); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>字符串</tag>
        <tag>Hard</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-567-字符串的排列]]></title>
    <url>%2F2020%2F08%2F18%2FLeetCode-567-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[LeetCode-567-字符串的排列给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。 换句话说，第一个字符串的排列之一是第二个字符串的子串。 示例1： 123输入: s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;输出: True解释: s2 包含 s1 的排列之一 (&quot;ba&quot;). 示例2： 12输入: s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;输出: False 注意： 输入的字符串只包含小写字母 两个字符串的长度都在 [1, 10,000] 之间 解题思路方法1、滑动窗口(套模版)： https://leetcode-cn.com/problems/permutation-in-string/solution/wo-xie-liao-yi-shou-shi-ba-suo-you-hua-dong-chuang/ 方法2、滑动窗口(数组优化)： 由于都是小写字符，所以初始化两个数组作为need和window，剩余步骤依旧按照模版走，详见注释。 Java代码1123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public boolean checkInclusion(String s1, String s2) &#123; Map&lt;Character,Integer&gt; need =new HashMap&lt;&gt;(); Map&lt;Character,Integer&gt; window =new HashMap&lt;&gt;(); for(char c:s1.toCharArray()) need.put(c,need.getOrDefault(c,0)+1); int left = 0,right = 0; int valid = 0; int start=0,len =Integer.MAX_VALUE; while(right &lt; s2.length())&#123; char c = s2.charAt(right); right++; if(need.containsKey(c))&#123; window.put(c,window.getOrDefault(c,0)+1); if((int)window.get(c) ==(int) need.get(c))&#123; valid++; &#125; &#125; while(right-left == s1.length())&#123; if(valid == need.size())&#123; return true; &#125; char d = s2.charAt(left); left++; if(need.containsKey(d))&#123; if((int)window.get(d) == (int)need.get(d))&#123; valid--; &#125; window.put(d,window.get(d)-1); &#125; &#125; &#125; return false; &#125;&#125; Java代码2123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public boolean checkInclusion(String s1, String s2) &#123; char[] arrS1 = s1.toCharArray(); char[] arrS2 = s2.toCharArray(); int[] needs = new int[26]; int[] window = new int[26]; int cntChar = 0; // 有效字母个数(不同的字母个数) for(char c: arrS1)&#123; if(needs[c-'a']==0) cntChar++;// 如果该字母第一次出现，记录下来 needs[c-'a']+=1; &#125; int left = 0; int right = 0; int valid = 0; while(right &lt; arrS2.length)&#123; char c = arrS2[right]; // 对窗口内数据进行一系列更新 window[c-'a']+=1; if(window[c-'a']==needs[c-'a'])&#123; valid++; &#125; // 当窗口扩散到包含s1时，进行左边界收缩 while(cntChar==valid)&#123; // 如果窗口大小为s1的长度，则说明找到了 if(right-left+1==arrS1.length)&#123; return true; &#125; char d = arrS2[left]; // 窗口缩小，对应字符出现次数-1 window[d-'a']-=1; // 当字符次数小于s1中字符出现次数时，则说明窗口达到包含s1字符的最小窗口 if(window[d-'a']&lt;needs[d-'a'])&#123; valid--; &#125; left++; &#125; right++; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Medium</tag>
        <tag>字符串</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-438-找到字符串中所有字母异位词]]></title>
    <url>%2F2020%2F08%2F18%2FLeetCode-438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[LeetCode-438-找到字符串中所有字母异位词给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。 字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。 说明： 字母异位词指字母相同，但排列不同的字符串。 不考虑答案输出的顺序。 示例1： 123456789输入:s: &quot;cbaebabacd&quot; p: &quot;abc&quot;输出:[0, 6]解释:起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的字母异位词。起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的字母异位词。 示例2： 12345678910输入:s: &quot;abab&quot; p: &quot;ab&quot;输出:[0, 1, 2]解释:起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的字母异位词。起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的字母异位词。起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的字母异位词。 解题思路方法1、哈希表+滑动窗口： 详见注释 方法2、数组+滑动窗口： 详见https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/solution/20200321438median-by-jasion_han-r/ 一开始还是先将字符串转换为字符数组，定义一个ans来接收结果 这里使用了两个数组needs和window来分别记录需要得到的元素和滑动窗口遍历到的元素 首先把目标数组arrP中有的元素都放入needs中，然后通过不断移动滑动窗口将目标元素的个数保存到window中 如果window数组中记录的元素个数超过了needs数组的元素个数，则开始移动左窗口慢慢减少多余的个数 最后把整个遍历过程中所有符合要求的左窗口索引放到ans中并返回即可。 Java代码1123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public List&lt;Integer&gt; findAnagrams(String s, String p) &#123; Map&lt;Character, Integer&gt; smap = new HashMap&lt;&gt;(); Map&lt;Character, Integer&gt; pmap = new HashMap&lt;&gt;(); for (char ch : p.toCharArray()) &#123; pmap.put(ch, pmap.getOrDefault(ch, 0) + 1); &#125; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); int count = 0; // 候选字符的个数 int len = p.length(); int left = 0; int right = 0; while (right &lt; s.length()) &#123; char ch = s.charAt(right); smap.put(ch, smap.getOrDefault(ch, 0) + 1); // 如果p中包含当前字符，且s的窗口中该字符出现次数不足，则该字符可以作为一个候选字符串，count++ if (pmap.containsKey(ch) &amp;&amp; smap.get(ch) &lt;= pmap.get(ch)) &#123; count++; &#125; // 当候选字符个数等于p长度，此时left为起始索引 if (count == len) &#123; res.add(left); &#125; // 当窗口大小大于等于p长度时，窗口左边需要收缩一个字符 if (right - left + 1 &gt;= len) &#123; char leftChar = s.charAt(left); // 判断收缩的这个字符是否是候选字符 if (pmap.containsKey(leftChar) &amp;&amp; smap.get(leftChar) &lt;= pmap.get(leftChar)) &#123; count--; &#125; // 窗口收缩一个字符 smap.put(leftChar, smap.getOrDefault(leftChar, 1) - 1); left++; &#125; right++; &#125; return res; &#125;&#125; Java代码2123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; public List&lt;Integer&gt; findAnagrams(String s, String p) &#123; char[] arrS = s.toCharArray(); char[] arrP = p.toCharArray(); // 接收最后返回的结果 List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); // 定义一个 needs 数组来看 arrP 中包含元素的个数 int[] needs = new int[26]; // 定义一个 window 数组来看滑动窗口中是否有 arrP 中的元素，并记录出现的个数 int[] window = new int[26]; // 先将 arrP 中的元素保存到 needs 数组中 for (int i = 0; i &lt; arrP.length; i++) &#123; needs[arrP[i] - 'a'] += 1; &#125; // 定义滑动窗口的两端 int left = 0; int right = 0; // 右窗口开始不断向右移动 while (right &lt; arrS.length) &#123; int curR = arrS[right] - 'a'; right++; // 将右窗口当前访问到的元素 curR 个数加 1 window[curR] += 1; // 当 window 数组中 curR 比 needs 数组中对应元素的个数要多的时候就该移动左窗口指针 while (window[curR] &gt; needs[curR]) &#123; int curL = arrS[left] - 'a'; left++; // 将左窗口当前访问到的元素 curL 个数减 1 window[curL] -= 1; &#125; // 这里将所有符合要求的左窗口索引放入到了接收结果的 List 中 if (right - left == arrP.length) &#123; ans.add(left); &#125; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Medium</tag>
        <tag>字符串</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-279-完全平方数]]></title>
    <url>%2F2020%2F08%2F14%2FLeetCode-279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0%2F</url>
    <content type="text"><![CDATA[LeetCode-279-完全平方数给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例1： 123输入: n = 12输出: 3 解释: 12 = 4 + 4 + 4. 示例2： 123输入: n = 13输出: 2解释: 13 = 4 + 9. 解题思路方法1、动态规划： 详见https://leetcode-cn.com/problems/perfect-squares/solution/hua-jie-suan-fa-279-wan-quan-ping-fang-shu-by-guan/ 首先初始化长度为n+1的数组dp，每个位置都为0如果n为0，则结果为0对数组进行遍历，下标为i，每次都将当前数字先更新为最大的结果，即dp[i]=i，比如i=4，最坏结果为4=1+1+1+1即为4个数字动态转移方程为：dp[i] = MIN(dp[i], dp[i - j j] + 1)，i表示当前数字，`jj`表示平方数 Java代码123456789101112class Solution &#123; public int numSquares(int n) &#123; int[] dp = new int[n + 1]; // 默认初始化值都为0 for (int i = 1; i &lt;= n; i++) &#123; dp[i] = i; // 最坏的情况就是每次+1 for (int j = 1; i - j * j &gt;= 0; j++) &#123; dp[i] = Math.min(dp[i], dp[i - j * j] + 1); // 动态转移方程 &#125; &#125; return dp[n]; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-1143-最长公共子序列]]></title>
    <url>%2F2020%2F08%2F14%2FLeetCode-1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[LeetCode-1143-最长公共子序列给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。 若这两个字符串没有公共子序列，则返回 0。 示例1： 123输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; 输出：3 解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。 示例2： 123输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;输出：3解释：最长公共子序列是 &quot;abc&quot;，它的长度为 3。 示例3： 123输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;输出：0解释：两个字符串没有公共子序列，返回 0。 提示: 1 &lt;= text1.length &lt;= 1000 1 &lt;= text2.length &lt;= 1000 输入的字符串只含有小写英文字符。 解题思路方法1、动态规划：详见大佬解析https://leetcode-cn.com/problems/longest-common-subsequence/solution/dong-tai-gui-hua-zhi-zui-chang-gong-gong-zi-xu-lie/ 初始化DP表 第0列和第0行均为空串，对应位置为0 状态dp[i][j]表示：对于text1[1…i]和text2[1…j]，他们的LCS的长度为dp[i][j] 状态转移方程：根据DP表得到，是前一列的LCS长度和上一行的LCS长度的最大值 Java代码123456789101112131415161718class Solution &#123; public int longestCommonSubsequence(String text1, String text2) &#123; int lenT1 = text1.length(); int lenT2 = text2.length(); int[][] dp = new int[lenT1+1][lenT2+1]; for(int i=1;i&lt;=lenT1;i++)&#123; for(int j=1;j&lt;=lenT2;j++)&#123; if(text1.charAt(i-1)==text2.charAt(j-1))&#123; dp[i][j] = dp[i-1][j-1]+1; &#125;else&#123; dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]); &#125; &#125; &#125; return dp[text1.length()][text2.length()]; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Medium</tag>
        <tag>字符串</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-221-最大正方形]]></title>
    <url>%2F2020%2F08%2F11%2FLeetCode-221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[LeetCode-221-最大正方形在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。 示例1： 12345678输入: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0输出: 4 解题思路方法1、暴力破解： 引用链接https://leetcode-cn.com/problems/maximal-square/solution/zui-da-zheng-fang-xing-by-leetcode-solution/ 暴力法是最简单直观的做法，具体做法如下： 遍历矩阵中的每个元素，每次遇到 1，则将该元素作为正方形的左上角； 确定正方形的左上角后，根据左上角所在的行和列计算可能的最大正方形的边长（正方形的范围不能超出矩阵的行数和列数），在该边长范围内寻找只包含 1 的最大正方形； 每次在下方新增一行以及在右方新增一列，判断新增的行和列是否满足所有元素都是 1。 方法2、动态规划： 状态dp[i][j]表示以第i行第j列为右下角所能构成的最大正方形边长 则当i==0或者j==0，最大正方形边长始终为1，则dp[i][j]=1 右下角的正方形的最大边长，最多比它的上方，左方，左上方为右下角的正方形边长+1 最好的情况是这三个方向的正方形大小都一样，这样加上右下角这个点就可以构成更大的正方形。但是如果其中某一个方向形成的正方形大小不一样，合起来就会缺少某个点，这时候的正方形大小只能取3个正方形中，最小的正方形边长+1了。 状态转移方程为：dp[i][j] = Math.min(dp[i-1][j-1],Math.min(dp[i-1][j],dp[i][j-1]))+1 Java代码11234567891011121314151617181920212223242526272829303132333435363738int maxSide = 0; if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123; return maxSide; &#125; int rows = matrix.length, columns = matrix[0].length; for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; columns; j++) &#123; if (matrix[i][j] == '1') &#123; // 遇到一个 1 作为正方形的左上角 maxSide = Math.max(maxSide, 1); // 计算可能的最大正方形边长 int currentMaxSide = Math.min(rows - i, columns - j); // 遍历可能的最大正方形内的每个元素 for (int k = 1; k &lt; currentMaxSide; k++) &#123; // 判断新增的一行一列是否均为 1 // 先判断对角线是否为0 boolean flag = true; if (matrix[i + k][j + k] == '0') &#123; break; &#125; // 再判断左上角点的右边和下边是否为0 for (int m = 0; m &lt; k; m++) &#123; if (matrix[i + k][j + m] == '0' || matrix[i + m][j + k] == '0') &#123; flag = false; break; &#125; &#125; // 如果flag仍然为true则说明矩阵中全部是1，更新最大边长 if (flag) &#123; maxSide = Math.max(maxSide, k + 1); &#125; else &#123; break; &#125; &#125; &#125; &#125; &#125; return maxSide * maxSide; Java代码2123456789101112131415161718192021222324class Solution &#123; public int maximalSquare(char[][] matrix) &#123; if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123; return 0; &#125; int row = matrix.length; int col = matrix[0].length; int matLen = 0; int[][] dp = new int[row][col]; for(int i=0;i&lt;row;i++)&#123; for(int j=0;j&lt;col;j++)&#123; if (matrix[i][j] == '1') &#123; if(i==0||j==0)&#123; dp[i][j] = 1; &#125;else&#123; dp[i][j] = Math.min(dp[i-1][j-1],Math.min(dp[i-1][j],dp[i][j-1]))+1; &#125; matLen = Math.max(dp[i][j],matLen); &#125; &#125; &#125; return matLen*matLen; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Medium</tag>
        <tag>DP</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-1247-交换字符使得字符串相同]]></title>
    <url>%2F2020%2F08%2F11%2FLeetCode-1247-%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%BD%BF%E5%BE%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%90%8C%2F</url>
    <content type="text"><![CDATA[LeetCode-1247-交换字符使得字符串相同有两个长度相同的字符串 s1 和 s2，且它们其中 只含有 字符 “x” 和 “y”，你需要通过「交换字符」的方式使这两个字符串相同。 每次「交换字符」的时候，你都可以在两个字符串中各选一个字符进行交换。 交换只能发生在两个不同的字符串之间，绝对不能发生在同一个字符串内部。也就是说，我们可以交换 s1[i] 和 s2[j]，但不能交换 s1[i] 和 s1[j]。 最后，请你返回使 s1 和 s2 相同的最小交换次数，如果没有方法能够使得这两个字符串相同，则返回 -1 。 示例1： 1234输入：s1 = &quot;xx&quot;, s2 = &quot;yy&quot;输出：1解释：交换 s1[0] 和 s2[1]，得到 s1 = &quot;yx&quot;，s2 = &quot;yx&quot;。 示例2： 123456输入：s1 = &quot;xy&quot;, s2 = &quot;yx&quot;输出：2解释：交换 s1[0] 和 s2[0]，得到 s1 = &quot;yy&quot;，s2 = &quot;xx&quot; 。交换 s1[0] 和 s2[1]，得到 s1 = &quot;xy&quot;，s2 = &quot;xy&quot; 。注意，你不能交换 s1[0] 和 s1[1] 使得 s1 变成 &quot;yx&quot;，因为我们只能交换属于两个不同字符串的字符。 示例3： 12输入：s1 = &quot;xx&quot;, s2 = &quot;xy&quot;输出：-1 示例4： 12输入：s1 = &quot;xxyyxyxyxx&quot;, s2 = &quot;xyyxyxxxyx&quot;输出：4 提示： 1 &lt;= s1.length, s2.length &lt;= 1000 s1, s2 只包含 &#39;x&#39; 或 &#39;y&#39;。 解题思路根据示例1和示例2可知， 当满足’xx’和’yy’、’yy’和’xx’的时候，只需要1步就可以完成交换 当满足’xy’和’yx’、’yx’和’xy’的时候，只需要2步就可以完成交换 以上两种情况可以总结为，当s1=x、s2=y时，记录位x++；当s1=y、s2=x时，记录位y++ 通过判断x和y的个数，计算最少交换字符的次数 如果x+y是奇数，则返回-1，因为这说明最后还剩下一对，x和y，单字符无法进行交换 如果x+y是偶数，则分为以下两种情况： 奇数x+奇数y：每两个x和y对应移动1次，剩下一对x和y对应移动2次 偶数x+偶数y：每两个x和y对应移动1次 Java代码123456789101112131415161718192021class Solution &#123; public int minimumSwap(String s1, String s2) &#123; int x = 0; int y = 0; for(int i=0;i&lt;s1.length();i++)&#123; if(s1.charAt(i)=='x'&amp;&amp;s2.charAt(i)=='y')&#123; x++; &#125; if(s1.charAt(i)=='y'&amp;&amp;s2.charAt(i)=='x')&#123; y++; &#125; &#125; if((x+y)%2==1) return -1; // x是奇数 if(x%2!=0)&#123; return x/2+y/2+2; &#125;else&#123; return x/2+y/2; &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Medium</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网易2021秋招-最小字典序字符串]]></title>
    <url>%2F2020%2F08%2F10%2F%E7%BD%91%E6%98%932021%E7%A7%8B%E6%8B%9B-%E6%9C%80%E5%B0%8F%E5%AD%97%E5%85%B8%E5%BA%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[网易2021秋招-最小字典序字符串第一行输入2个数字 第一个数字n代表字符串应该扩充为多少位，第二个数字m代表字符串当前有多少个字符 第二行输入m个数字，代表当前字符串 第三行为输出，输出需要满足在不改变当前字符串前后位置的情况下，扩充为长度为n的最小字典序的字符串 每个数字仅可以选择1次 示例1： 1235 32 3 51 2 3 4 5 示例2： 1235 24 21 3 4 2 5 解题思路观察用例可以输入的n就是扩展后字符的最大数，且每个数字只可以选择1次 现有的数字的前后顺序不变，想要字典序最小，插入的数字需要和现有的数字进行比较，小的数字优先插入到现有数字之前。 可以利用一个队列Queue存储当前的字符，保证先后顺序，同时需要一个n+1的数组，用来保存数字是否被选择的状态。 将原始的字符串在对应位置置为true，表示已经选择，之后的插入数字中不能从中选择这类数字。同时将这些数字加入Queue保证先后顺序 利用StringBuilder来进行最终答案的拼接 循环从1开始到n，进行插入数字和队列数字的大小判断： 当队列不为空且队列的头部小于新选择数字i时，从队列中取出头部原始的数字加入到结果res中 如果不小于，则说明未选择的数字应该插入到前面，res.append(i + &quot; &quot;); 如果循环完了，队列中还有值，直接把队列中所有数字按顺序加入res即可 最后去除首尾空格，返回结果 Java代码12345678910111213141516171819202122232425262728import java.util.*;public class Solution &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); boolean[] visited = new boolean[n + 1]; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; m; i++) &#123; int num = sc.nextInt(); visited[num] = true; queue.offer(num); &#125; StringBuilder res = new StringBuilder(); for (int i = 1; i &lt;= n; i++) &#123; if (visited[i]) continue; while (!queue.isEmpty() &amp;&amp; queue.peek() &lt; i) &#123; res.append(queue.poll() + " "); &#125; res.append(i + " "); &#125; while (!queue.isEmpty()) &#123; res.append(queue.poll() + " "); &#125; System.out.println(res.toString().trim()); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Medium</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网易2021秋招-数组的最多素数个数]]></title>
    <url>%2F2020%2F08%2F10%2F%E7%BD%91%E6%98%932021%E7%A7%8B%E6%8B%9B-%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%9A%E7%B4%A0%E6%95%B0%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[网易2021秋招-数组的最多素数个数第一行输入一个数字n 第二行输入n个数字，求这n个数字最多能够拆解为多少个素数，且数字拆解之后素数之后等于数字本身。如5可以拆解为2，3；3本身为素数；7可以拆解为2，2，3 第三行输出数组最多能够拆解成的素数个数 最多1e6个数，每个数字最大为1e9，1不是素数 示例1： 12335 3 76 解题思路观察题目可知，当2的数量最多的时候，数组就拥有最多的素数个数。 考虑数字范围，需要通过long存储结果，因为累加肯定是超过了int范围 可以通过判断数字的奇数和偶数来分别进行计算： 偶数情况直接除以2，奇数情况减去3再除以2，再+1个即可 观察可知，上面的奇数情况可以直接合并为数字除以2即可，因为减去3也是减去的一个数，这个数最后还是要加回来的。 所以对每个数字除以2累加即可得到答案。 Java代码112345678910111213141516171819202122232425import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); long sum = 0; int n = Integer.parseInt(sc.nextLine().trim()); Main main = new Main(); for (int i = 0; i &lt; n; i++) &#123; int num = sc.nextInt(); sum += main.countSu(num); &#125; System.out.println(sum); &#125; public long countSu(int num) &#123; long sum = 0; if (num % 2 == 0) &#123; sum += num / 2; &#125; else &#123; sum += ((num - 3) / 2) + 1; &#125; return sum; &#125;&#125; Java代码212345678910111213import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); long res = 0; int n = sc.nextInt(); for (int i = 0; i &lt; n; i++) &#123; res += sc.nextInt() &gt;&gt; 1; &#125; System.out.println(res); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-84-柱状图中最大的矩形]]></title>
    <url>%2F2020%2F08%2F07%2FLeetCode-84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[LeetCode-84-柱状图中最大的矩形给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的最大面积。 以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。 图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。 示例1： 12输入: [2,1,5,6,2,3]输出: 10 解题思路方法1、暴力破解： 固定一个柱子的高度，往左和右寻找第一个高度小于当前柱子的柱体，向左和向右走的步数即是宽度 对于每个柱子，都计算一次以当前柱子为高度，左右寻找位置为宽度围成的矩形面积，最后得到最大的面积即可 方法2、单调栈： 我们可以 O(1) 的获取柱体 i 左边第一个比它小的柱体吗？答案就是单调增栈，因为对于栈中的柱体来说，栈中下一个柱体就是左边第一个高度小于自身的柱体。 视频详解https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhu-zhuang-tu-zhong-zui-da-de-ju-xing-by-leetcode-/ 方法3、单调栈+哨兵： 视频详解https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhu-zhuang-tu-zhong-zui-da-de-ju-xing-by-leetcode-/ Java代码11234567891011121314151617181920class Solution &#123; public int largestRectangleArea(int[] heights) &#123; int area = 0; int len = heights.length; for(int i=0;i&lt;len;i++)&#123; int width = 1; int height = heights[i]; int j = i; while(--j&gt;=0&amp;&amp;heights[j]&gt;=height)&#123; width++; &#125; j = i; while(++j&lt;len&amp;&amp;heights[j]&gt;=height)&#123; width++; &#125; area = Math.max(area,width*height); &#125; return area; &#125;&#125; Java代码21234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public int largestRectangleArea(int[] heights) &#123; int area = 0; int len = heights.length; if (len == 0) &#123; return 0; &#125; if (len == 1) &#123; return heights[0]; &#125; Deque&lt;Integer&gt; stack = new ArrayDeque&lt;Integer&gt;(); for (int i = 0; i &lt; len; i++) &#123; while(!stack.isEmpty()&amp;&amp;heights[stack.peekLast()]&gt;heights[i])&#123; int height = heights[stack.removeLast()]; while(!stack.isEmpty()&amp;&amp;heights[stack.peekLast()]==height)&#123; stack.removeLast(); &#125; int width; if(stack.isEmpty())&#123; width = i; &#125;else &#123; width = i-stack.peekLast()-1; &#125; area = Math.max(area,width*height); &#125; stack.addLast(i); &#125; while(!stack.isEmpty())&#123; int height = heights[stack.removeLast()]; while(!stack.isEmpty()&amp;&amp;heights[stack.peekLast()]==height)&#123; stack.removeLast(); &#125; int width; if(stack.isEmpty())&#123; width = len; &#125;else &#123; width = len-stack.peekLast()-1; &#125; area = Math.max(area,width*height); &#125; return area; &#125;&#125; Java代码31234567891011121314151617181920212223242526272829class Solution &#123; public int largestRectangleArea(int[] heights) &#123; int area = 0; int len = heights.length; if (len == 0) &#123; return 0; &#125; if (len == 1) &#123; return heights[0]; &#125; int[] newHeights = new int[len + 2]; for (int i = 0; i &lt; len; i++) &#123; newHeights[i + 1] = heights[i]; &#125; len += 2; heights = newHeights; Deque&lt;Integer&gt; stack = new ArrayDeque&lt;Integer&gt;(); stack.addLast(0); for (int i = 0; i &lt; len; i++) &#123; while (heights[stack.peekLast()] &gt; heights[i]) &#123; int height = heights[stack.removeLast()]; int width = i - stack.peekLast() - 1; area = Math.max(area, width * height); &#125; stack.addLast(i); &#125; return area; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-543-二叉树的直径]]></title>
    <url>%2F2020%2F08%2F07%2FLeetCode-543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84%2F</url>
    <content type="text"><![CDATA[LeetCode-543-二叉树的直径给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。 示例1： 给定二叉树 12345 1 / \ 2 3 / \ 4 5 返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。 注意：两结点之间的路径长度是以它们之间边的数目表示。 解题思路方法1、DFS： 二叉树的直径是不一定经过root节点的，可能存在于每个子树中，所以需要遍历每个节点的左右子树深度。动态记录最大的直径 直径 = max(左子树深度+右子树深度) 某节点子树的深度 = max(某节点左子树深度，某节点右子树深度)+1 Java代码12345678910111213141516171819202122232425/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; private int res = 0; public int diameterOfBinaryTree(TreeNode root) &#123; if(root==null) return 0; calDepth(root); return res; &#125; public int calDepth(TreeNode root)&#123; if(root==null) return 0; int left = calDepth(root.left); int right = calDepth(root.right); res = Math.max(left+right,res); return Math.max(left,right)+1; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>树</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-62-不同路径]]></title>
    <url>%2F2020%2F08%2F06%2FLeetCode-62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[LeetCode-62-不同路径一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 示例1： 1234567输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下2. 向右 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向右 示例2： 12输入: m = 7, n = 3输出: 28 提示： 1 &lt;= m, n &lt;= 100 题目数据保证答案小于等于 2 * 10 ^ 9 解题思路方法1、动态规划： 这道题是个经典的动态规划问题，初始化矩阵大小的dp数组保存数字，由于只能往右或者往下走所以第1行和第1列都是1 dp[i][j]状态定义为：有多少条路径到i，j这一格 状态转移方程： 当i==0或者j==0时，dp[i][j]=1 其余位置，dp[i][j]的值依赖于左边位置的路径+上边位置的路径，即dp[i - 1][j] + dp[i][j - 1] 最后返回右下角的值即可 方法2、动态规划(空间优化)： 由于每格的值仅与左侧和上方的值有关，所以只需要维护一行的值即可，空间复杂度可以降到O(N) Java代码1123456789101112131415class Solution &#123; public int uniquePaths(int m, int n) &#123; int[][] dp = new int[n][m]; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (i == 0 || j == 0) &#123; dp[i][j] = 1; &#125; else &#123; dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; &#125; &#125; &#125; return dp[n - 1][m - 1]; &#125;&#125; Java代码2123456789101112class Solution &#123; public int uniquePaths(int m, int n) &#123; int[] dp = new int[m]; Arrays.fill(dp, 1); for (int i = 1; i &lt; n; i++) &#123; for (int j = 1; j &lt; m; j++) &#123; dp[j] += dp[j - 1]; &#125; &#125; return dp[m - 1]; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Medium</tag>
        <tag>DP</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-75-颜色分类]]></title>
    <url>%2F2020%2F08%2F06%2FLeetCode-75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[LeetCode-75-颜色分类给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意:不能使用代码库中的排序函数来解决这道题。 示例1： 12输入: [2,0,2,1,1,0]输出: [0,0,1,1,2,2] 进阶： 一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。 你能想出一个仅使用常数空间的一趟扫描算法吗？ 解题思路方法1、计数排序： 初始化max+1容量的桶，将数组值为下标的元素放入对应的桶内，并进行计数，如nums[2]=3，则bucket[3]+1。之后从每个桶中取出元素，重新放入原本的数组，实现原地修改。需要多次遍历数组。当然使用快排也可以，但题目要求使用一趟的扫描算法。 方法2、三指针一次遍历(荷兰国旗问题)： 我们用三个指针（p0, p2 和curr）来分别追踪0的最右边界，2的最左边界和当前考虑的元素。 本解法的思路是沿着数组移动 curr 指针，若nums[curr] = 0，则将其与 nums[p0]互换；若 nums[curr] = 2 ，则与 nums[p2]互换。 算法 初始化0的最右边界：p0 = 0。在整个算法执行过程中 nums[idx &lt; p0] = 0. 初始化2的最左边界 ：p2 = n - 1。在整个算法执行过程中 nums[idx &gt; p2] = 2. 初始化当前考虑的元素序号 ：curr = 0. While curr &lt;= p2 : 若 nums[curr] = 0 ：交换第 curr个 和 第p0个 元素，并将指针都向右移。 若 nums[curr] = 2 ：交换第 curr个和第 p2个元素，并将 p2指针左移 。 若 nums[curr] = 1 ：将指针curr右移。 Java代码112345678910111213141516171819202122class Solution &#123; public void sortColors(int[] nums) &#123; int len = nums.length; int max = Integer.MIN_VALUE; if (nums == null || len &lt; 2) return; for (int num : nums) &#123; max = Math.max(max, num); &#125; int[] bucket = new int[max + 1]; for (int i = 0; i &lt; len; i++) &#123; bucket[nums[i]]++; &#125; int index = 0; for (int j = 0; j &lt; bucket.length; j++) &#123; while (bucket[j] &gt; 0) &#123; nums[index] = j; bucket[j] -= 1; index++; &#125; &#125; &#125;&#125; Java代码2123456789101112131415161718192021222324252627282930class Solution &#123; //只有三种数 0 1 2 // 直接冒泡排序 时间复杂度不符合 // 双指针 p_0 标注 0元素的最右边 p_2 标注 2元素的最最左边 // curr 指针，标注当前元素 public void sortColors(int[] nums) &#123; int p1 = 0; int p2 = nums.length-1; int curr = 0; int temp; while(curr&lt;=p2)&#123; //如果当前元素等于0，则与P_0互换位置 if(nums[curr]==0)&#123; temp = nums[p1]; nums[p1] = nums[curr]; nums[curr] = temp; curr++; p1++; &#125;else if(nums[curr]==2)&#123;//如果当前元素等于2，则与P_2互换位置 temp = nums[p2]; nums[p2] = nums[curr]; nums[curr] = temp; p2--; //因为curr左边的值已经扫描过了，所以curr要++继续扫描下一位，而与p2交换的值，curr未扫描，要停下来扫描一下，所以curr不用++ &#125;else&#123; curr++; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-416-分割等和子集]]></title>
    <url>%2F2020%2F08%2F05%2FLeetCode-416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86%2F</url>
    <content type="text"><![CDATA[LeetCode-416-分割等和子集给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200 示例1： 12345输入: [1, 5, 11, 5]输出: true解释: 数组可以分割成 [1, 5, 5] 和 [11]. 示例2： 12345输入: [1, 2, 3, 5]输出: false解释: 数组不能分割成两个元素和相等的子集. 解题思路方法1、动态规划：非常好的详解，0-1背包问题https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/0-1-bei-bao-wen-ti-xiang-jie-zhen-dui-ben-ti-de-yo/ 做这道题需要做这样一个等价转换：是否可以从这个数组中挑选出一些正整数，使得这些数的和等于整个数组元素的和的一半。前提条件是：数组的和一定得是偶数，即数组的和一定得被2整除，这一点是特判。 Java代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Solution &#123; public boolean canPartition(int[] nums) &#123; int len = nums.length; if (len == 0) &#123; return false; &#125; int sum = 0; for (int num : nums) &#123; sum += num; &#125; // 特判：如果是奇数，就不符合要求 if ((sum &amp; 1) == 1) &#123; return false; &#125; int target = sum / 2; // 创建二维状态数组，行：物品索引，列：容量（包括 0） boolean[][] dp = new boolean[len][target + 1]; // 先填表格第 0 行，第 1 个数只能让容积为它自己的背包恰好装满 if (nums[0] &lt;= target) &#123; dp[0][nums[0]] = true; &#125; // 再填表格后面几行 for (int i = 1; i &lt; len; i++) &#123; for (int j = 0; j &lt;= target; j++) &#123; // 直接从上一行先把结果抄下来，然后再修正 dp[i][j] = dp[i - 1][j]; if (nums[i] == j) &#123; dp[i][j] = true; continue; &#125; if (nums[i] &lt; j) &#123; dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]]; &#125; &#125; &#125; return dp[len - 1][target]; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-146-LRU缓存机制]]></title>
    <url>%2F2020%2F08%2F04%2FLeetCode-146-LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[LeetCode-146-LRU缓存机制运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。 获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。 进阶: 你是否可以在 O(1) 时间复杂度内完成这两种操作？ 示例1： 1234567891011LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // 返回 1cache.put(3, 3); // 该操作会使得关键字 2 作废cache.get(2); // 返回 -1 (未找到)cache.put(4, 4); // 该操作会使得关键字 1 作废cache.get(1); // 返回 -1 (未找到)cache.get(3); // 返回 3cache.get(4); // 返回 4 解题思路方法1、队列+哈希表： 观察示例可知，当执行get(1)之后，后加入的key为2的数据会变为最久没有使用的 不难知道，在get操作之后需要对数据进行重排。而put操作也将依赖与重排的逻辑进行操作 这里选择先进先出的Queue作为重排的容器比较合适。 首先需要记录初始化的容量capacity 每进行一次put，队列中也会加入key，map中也会加入key，value，同时容量减1 当容量为0时，需要删除map中最久没有使用的key，value，再添加新的key，value 如果get的时候能够保证queue头部存储的最久没有使用的key，那么这一步操作就变得很简单。只需要如下操作即可。 123map.remove(queue.poll());queue.add(key);map.put(key,value); 那么如何让get操作，保证queue的头部存储的最久没有使用的key呢？ 想要实现这样的queue，换一种思路，使用了(get)之后的key应该放在队列的最后 那么当查找一个key的时候，通过判断queue是否有这个key来进行get操作 当有这个key的时候，将这个key拿出来，然后放到queue末尾，之后返回map中获得key的结果即可。 如果没有这个key，返回-1即可。 回到put函数这里，除了put中的1、2两个操作之外，还需要考虑第3种情况 如果put的过程中queue中有这个key，即put[1,2]之后又put[1,5]这种情况仅仅value不同，key相同，需要删除原本queue中的key，再添加新的key，因为put同一个key的操作或许不是连续的。同时需要更新map的key和value 方法2、哈希表+双向链表： 原文链接：https://leetcode-cn.com/problems/lru-cache/solution/lruhuan-cun-ji-zhi-by-leetcode-solution/ 利用LinkedHashMap，不利用LinkedHashMap两个版本 LRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。 双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。 哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。 这样以来，我们首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在 O(1) 的时间内完成 get或者 put 操作。具体的方法如下： 对于 get 操作，首先判断 key是否存在： 如果 key 不存在，则返回−1； 如果 key存在，则 key对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。 对于 put 操作，首先判断key是否存在： 如果key 不存在，使用key和 value创建一个新的节点，在双向链表的头部添加该节点，并将 key和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项； 如果 key存在，则与 get操作类似，先通过哈希表定位，再将对应的节点的值更新为 value，并将该节点移到双向链表的头部。 上述各项操作中，访问哈希表的时间复杂度为 O(1)，在双向链表的头部添加节点、在双向链表的尾部删除节点的复杂度也为 O(1)。而将一个节点移到双向链表的头部，可以分成「删除该节点」和「在双向链表的头部添加节点」两步操作，都可以在O(1) 时间内完成。 小贴士 在双向链表的实现中，使用一个伪头部（dummy head）和伪尾部（dummy tail）标记界限，这样在添加节点和删除节点的时候就不需要检查相邻的节点是否存在。 Java代码11234567891011121314151617181920212223242526272829303132333435363738394041424344class LRUCache &#123; Queue&lt;Integer&gt; queue; HashMap&lt;Integer,Integer&gt; map; int capacity; public LRUCache(int capacity) &#123; this.map = new HashMap&lt;&gt;(); this.queue = new LinkedList&lt;&gt;(); this.capacity = capacity; &#125; public int get(int key) &#123; if(queue.contains(key))&#123; queue.remove(key); queue.add(key); return map.get(key); &#125;else&#123; return -1; &#125; &#125; public void put(int key, int value) &#123; if(queue.contains(key))&#123; queue.remove(key); queue.add(key); map.put(key,value); &#125; else if(capacity==0)&#123; map.remove(queue.poll()); queue.add(key); map.put(key,value); &#125;else&#123; queue.add(key); map.put(key,value); capacity--; &#125; &#125;&#125;/** * Your LRUCache object will be instantiated and called as such: * LRUCache obj = new LRUCache(capacity); * int param_1 = obj.get(key); * obj.put(key,value); */ Java代码2123456789101112131415161718192021222324252627282930class LRUCache &#123; private int cap; private Map&lt;Integer, Integer&gt; map = new LinkedHashMap&lt;&gt;(); // 保持插入顺序 public LRUCache(int capacity) &#123; this.cap = capacity; &#125; public int get(int key) &#123; if (map.keySet().contains(key)) &#123; int value = map.get(key); map.remove(key); // 保证每次查询后，都在末尾 map.put(key, value); return value; &#125; return -1; &#125; public void put(int key, int value) &#123; if (map.keySet().contains(key)) &#123; map.remove(key); &#125; else if (map.size() == cap) &#123; Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; iterator = map.entrySet().iterator(); iterator.next(); iterator.remove(); &#125; map.put(key, value); &#125;&#125; Java代码3完全手动实现LinkedHashMap 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public class LRUCache &#123; class DLinkedNode &#123; int key; int value; DLinkedNode prev; DLinkedNode next; public DLinkedNode() &#123;&#125; public DLinkedNode(int _key, int _value) &#123;key = _key; value = _value;&#125; &#125; private Map&lt;Integer, DLinkedNode&gt; cache = new HashMap&lt;Integer, DLinkedNode&gt;(); private int size; private int capacity; private DLinkedNode head, tail; public LRUCache(int capacity) &#123; this.size = 0; this.capacity = capacity; // 使用伪头部和伪尾部节点 head = new DLinkedNode(); tail = new DLinkedNode(); head.next = tail; tail.prev = head; &#125; public int get(int key) &#123; DLinkedNode node = cache.get(key); if (node == null) &#123; return -1; &#125; // 如果 key 存在，先通过哈希表定位，再移到头部 moveToHead(node); return node.value; &#125; public void put(int key, int value) &#123; DLinkedNode node = cache.get(key); if (node == null) &#123; // 如果 key 不存在，创建一个新的节点 DLinkedNode newNode = new DLinkedNode(key, value); // 添加进哈希表 cache.put(key, newNode); // 添加至双向链表的头部 addToHead(newNode); ++size; if (size &gt; capacity) &#123; // 如果超出容量，删除双向链表的尾部节点 DLinkedNode tail = removeTail(); // 删除哈希表中对应的项 cache.remove(tail.key); --size; &#125; &#125; else &#123; // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部 node.value = value; moveToHead(node); &#125; &#125; private void addToHead(DLinkedNode node) &#123; node.prev = head; node.next = head.next; head.next.prev = node; head.next = node; &#125; private void removeNode(DLinkedNode node) &#123; node.prev.next = node.next; node.next.prev = node.prev; &#125; private void moveToHead(DLinkedNode node) &#123; removeNode(node); addToHead(node); &#125; private DLinkedNode removeTail() &#123; DLinkedNode res = tail.prev; removeNode(res); return res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-394-字符串解码]]></title>
    <url>%2F2020%2F08%2F03%2FLeetCode-394-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[LeetCode-394-字符串解码给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。 示例1： 12输入：s = &quot;3[a]2[bc]&quot;输出：&quot;aaabcbc&quot; 示例2： 12输入：s = &quot;3[a2[c]]&quot;输出：&quot;accaccacc&quot; 示例3： 12输入：s = &quot;2[abc]3[cd]ef&quot;输出：&quot;abcabccdcdcdef&quot; 示例4： 12输入：s = &quot;abc3[cd]xyz&quot;输出：&quot;abccdcdcdxyz&quot; 解题思路方法1、栈： 观察示例可知，当出现括号时，需要考虑括号前的数字 由于有时候括号不止1个，而且括号内的字符也不止1组，所以需要2个栈(或者队列)来进行存储，此外还需要一个res存储最终拼接的字符串。 顺序进行遍历，情况分为以下4种： 0&lt;=当前字符&lt;=9时，记录当前num，num=c[i]-&#39;0&#39;，但是num可能不止一个数字，当字符为100时，下一个也是num，如果直接覆盖会导致数字丢失，于是num=num * 10 + c[i] - &#39;0&#39;正是考虑这种情况。 当前字符==[左括号时，记录括号前的num，并将num置0，方便下次记录。同时需要记录数字之前出现的所有英文字符，使用str的栈进行先前结果的存储，strStack.push(res.toString());，复用res准备记录括号内的英文字符。 当前字符是a-z或者A-Z范围内时，直接进行字符串拼接res.append(c[i]) 当前字符==]右括号时，需要将括号内的字符重复，同时需要将之前保存的字符串和括号内的字符串进行拼接。首先弹出数字栈内的数字tempNum，利用一个临时的字符串tempStr保存之前的结果，从字符栈中弹出之前的字符串strStack.pop()，并转为StringBuilder类型赋值给tempStr，循环添加到tempStr中，此时的res保存的是括号内的字符，循环次数为tempNum。进行玩括号内字符添加后，将临时字符串赋值给res，继续进行循环判断。 最后，返回res.toString() Java代码1234567891011121314151617181920212223242526272829class Solution &#123; public String decodeString(String s) &#123; StringBuilder res = new StringBuilder(); Stack&lt;Integer&gt; numStack = new Stack&lt;&gt;(); Stack&lt;String&gt; strStack = new Stack&lt;&gt;(); char[] c = s.toCharArray(); int num = 0; for (int i = 0; i &lt; c.length; i++) &#123; if (c[i] &gt;= '0' &amp;&amp; c[i] &lt;= '9') &#123; num = num * 10 + c[i] - '0'; &#125; else if (c[i] == '[') &#123; numStack.push(num); num = 0; strStack.push(res.toString()); res = new StringBuilder(); &#125; else if (('a' &lt;= c[i] &amp;&amp; c[i] &lt;= 'z') || ('A' &lt;= c[i] &amp;&amp; c[i] &lt;= 'Z')) &#123; res.append(c[i]); &#125; else if (c[i] == ']') &#123; int tempNum = numStack.pop(); StringBuilder tempStr = new StringBuilder(strStack.pop()); for (int j = 0; j &lt; tempNum; j++) &#123; tempStr.append(res); &#125; res = tempStr; &#125; &#125; return res.toString(); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Medium</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-448-找到所有数组中消失的数字]]></title>
    <url>%2F2020%2F08%2F03%2FLeetCode-448-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[LeetCode-448-找到所有数组中消失的数字给定一个范围在 1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。 找到所有在 [1, n] 范围之间没有出现在数组中的数字。 您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。 示例1： 12345输入:[4,3,2,7,8,2,3,1]输出:[5,6] 解题思路方法1、哈希表： 排序后的复杂度不符合要求，写一个需要空间要求的。利用一个O(n)空间的哈希表进行数据存储，之后进行数组的遍历，判断是否有i这个值在哈希表内，如果不在则就是消失的数字。 方法2、原地修改： 原地修改具有技巧性，不容易想到，详见https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/solution/zhao-dao-suo-you-shu-zu-zhong-xiao-shi-de-shu-zi-2/ Java代码112345678910111213141516class Solution &#123; public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if (nums == null || nums.length == 0) return res; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int num : nums) &#123; map.put(num, 1); &#125; for (int i = 1; i &lt;= nums.length; i++) &#123; if (!map.containsKey(i)) &#123; res.add(i); &#125; &#125; return res; &#125;&#125; Java代码21234567891011121314151617181920212223242526272829303132333435363738 /** * * 找出 1 - n 中没有出现的数字。不能使用额外的空间，两次循环时间复杂度为 2O(n)，即为 O(n)。 * * 解题思路：使用数组的下标来标记数字的出现于否，通过一遍遍历即可标记出全部已经出现的数组 * * [4,3,2,7,8,2,3,1] 初始数据 * * [4,3,2,-7,8,2,3,1] 第一个数据 4 出现，将数组的第四个也就是下标 3 的数据修改为负数。-7 计算时，通过绝对值处理一下即可不影响数据的计算 * [4,3,-2,-7,8,2,3,1] * [4,-3,-2,-7,8,2,3,1] * [4,-3,-2,-7,8,2,-3,1] * [4,-3,-2,-7,8,2,-3,-1] * [4,-3,-2,-7,8,2,-3,-1] * [4,-3,-2,-7,8,2,-3,-1] * [-4,-3,-2,-7,8,2,-3,-1] * * 计算结束，数组的第五个，第六个依然为整数，证明 5,6 没有出现 * * @param nums * @return */class Solution &#123; public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123; List&lt;Integer&gt; results = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[Math.abs(nums[i]) - 1] &gt; 0) &#123; nums[Math.abs(nums[i]) - 1] *= -1; &#125; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] &gt; 0) &#123; results.add(i + 1); &#125; &#125; return results; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-56-合并区间]]></title>
    <url>%2F2020%2F08%2F02%2FLeetCode-56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[LeetCode-56-合并区间给出一个区间的集合，请合并所有重叠的区间。 示例1： 123输入: [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例2： 123输入: [[1,4],[4,5]]输出: [[1,5]]解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 解题思路方法1、排序+双指针： 虽然示例中没有给出需要排序的案例，但需要考虑数组不是按照首位数组顺序排列的情况，这样会让区间难以判断，所以先做一个排序。 之后初始化双指针，指向第一个区间的start和end 进入for循环判断，判断下一个区间的首位是否大于上个区间的末尾 如果大于，则说明区间分离，加入新区间{start，end}，更新start 当下一个区间不大于end，即&lt;=end的时候，区间均要进行合并，此时区间为上一个区间的start，到当前区间和下一个区间end的最大值，所以end = Math.max(end,intervals[i][1]) 由于开始的start和end是上一个区间的结果，所以在最后一次时，暂时不会添加区间，res.add(new int[]{start,end});为最后一次添加之后转化为int[][]返回即可 Java代码1234567891011121314151617181920class Solution &#123; public int[][] merge(int[][] intervals) &#123; int len = intervals.length; if (intervals == null || len &lt;= 1) return intervals; List&lt;int[]&gt; res = new ArrayList&lt;&gt;(); Arrays.sort(intervals, (x, y) -&gt; x[0] - y[0]); int start = intervals[0][0]; int end = intervals[0][1]; for (int i = 1; i &lt; len; i++) &#123; if(intervals[i][0]&gt;end)&#123; res.add(new int[]&#123;start,end&#125;); start = intervals[i][0]; &#125; end = Math.max(end,intervals[i][1]); &#125; // 最后一次添加 res.add(new int[]&#123;start,end&#125;); return res.toArray(new int[res.size()][2]); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-236-二叉树的最近公共祖先]]></title>
    <url>%2F2020%2F08%2F01%2FLeetCode-236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%2F</url>
    <content type="text"><![CDATA[LeetCode-236-二叉树的最近公共祖先给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] 示例1： 123输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例2： 123输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉树中。 解题思路方法1、递归： 参考链接https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/ 根据上述示例可以得知，如果root是p，q的最近公共祖先，则可能的情况有以下3种： root节点的子树包含p和q两个节点，且p和q分别在root的左、右子树中； p=root，且q在root的左/右子树中； q=root，且p在root的左/右子树中； 递归解析： 1、终止条件： 当越过叶节点，则直接返回null； 当root等于p,q，则直接返回root； 2、递推工作： 开启递归左子节点，返回值记为left； 开启递归右子节点，返回值记为right； 3、返回值：根据left和right，可展开为四种情况； 当left和right同时为空：说明root的左/右子树中都不包含p,q，返回null； 当left和right同时不为空：说明p,q分列在root的左/右子树，因此root为最近公共祖先，返回root； 当left为空，right不为空：p,q都不在root的左子树中，直接返回right。具体可分为两种情况： p,q其中一个在root的右子树中，此时right指向p(假设为p)； p,q两节点都在root的右子树中，此时right指向最近公共祖先节点； 当left不为空，right为空：与情况3同理； 观察发现，情况1可合并至3和4内 Java代码112345678910111213141516171819/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root==null||root==p||root==q) return root; TreeNode left = lowestCommonAncestor(root.left,p,q); TreeNode right = lowestCommonAncestor(root.right,p,q); if(left==null) return right; if(right==null) return left; return root; &#125;&#125; Java代码21234567891011class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root == null || root == p || root == q) return root; TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if(left == null &amp;&amp; right == null) return null; // 1. if(left == null) return right; // 3. if(right == null) return left; // 4. return root; // 2. if(left != null and right != null) &#125;&#125; Java代码3逻辑更清晰版本，出处https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/comments/ 123456789101112131415161718192021public class Solution &#123;//所有的递归的返回值有4种可能性，null、p、q、公共祖先 public TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if (root == null) &#123;//当遍历到叶结点后就会返回null return root; &#125; if (root == p || root == q) &#123;//当找到p或者q的是时候就会返回pq return root;/*当然，值得一提的是，如果公共祖先是自己（pq），并不需要寻找另外 一个，我们在执行前序遍历会先找上面的，后找下面的，我们会直接返回公共祖先。*/ &#125; TreeNode left = LowestCommonAncestor(root.left, p, q);//返回的结点进行保存，可能是null TreeNode right = LowestCommonAncestor(root.right, p, q);//也可能是pq，还可能是公共祖先 if (left != null &amp;&amp; right != null) &#123; return root;//如果左右都存在，就说明pq都出现了，这就是，公共祖先，此时不用考虑公共祖先是自己的情况，因为上面已经做过判断了。 &#125; else if (left != null) &#123;//否则我们返回已经找到的那个值（存储在left，与right中），p或者q return left;//还有一种可能就是，由下面返回的公共祖先，并将这个值一路返回到最表层 &#125; else if (right != null) &#123; return right; &#125; return null; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>树</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-560-和为K的子数组]]></title>
    <url>%2F2020%2F07%2F31%2FLeetCode-560-%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[LeetCode-560-和为K的子数组给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。 示例1： 12输入:nums = [1,1,1], k = 2输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。 说明 : 数组的长度为 [1, 20,000]。 数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。 解题思路方法1、暴力累加： 以数组中每一个数字作为起点，不断向后累加，找到一个累加和为k的就让count++ 当以下一个数字为起点时，重置sum为0，即可得到最终结果 方法2、哈希表： 更好的题解https://leetcode-cn.com/problems/subarray-sum-equals-k/solution/dai-ni-da-tong-qian-zhui-he-cong-zui-ben-fang-fa-y/ 方法1的瓶颈在于对于每个数字i，需要枚举所有的j来判断是否符合条件 这一步其实是可优化的 我们定义sum[i] 为 [0..i] 里所有数的和，则 sum[i]可以由sum[i−1]递推而来，即：sum[i]=sum[i−1]+nums[i] 那么[j..i]这个子数组和为 k这个条件我们可以转化为sum[i]−sum[j−1]==k 简单移项可得符合条件的下标j需要满足sum[j−1]==sum[i]−k 所以我们考虑以i结尾的和为k的连续子数组个数时只要统计有多少个前缀和为 sum[i]−k的 sum[j]即可。我们建立哈希表 mp，以和为键，出现次数为对应的值，记录 sum[i]出现的次数，从左往右边更新 mp边计算答案，那么以 i结尾的答案 mp[sum[i]−k] 即可在 O(1)时间内得到。最后的答案即为所有下标结尾的和为 k的子数组个数之和。 需要注意的是，从左往右边更新边计算的时候已经保证了mp[sum[i]−k]里记录的 sum[j]的下标范围是 0≤j≤i 。同时，由于sum[i]的计算只与前一项的答案有关，因此我们可以不用建立 sum数组，直接用sum变量来记录 sum[i−1] 的答案即可。 Java代码1123456789101112131415class Solution &#123; public int subarraySum(int[] nums, int k) &#123; int count = 0; for (int i = 0; i &lt; nums.length; i++) &#123; int sum = 0; for (int j = i; j &lt; nums.length; j++) &#123; sum += nums[j]; if (sum == k) &#123; count++; &#125; &#125; &#125; return count; &#125;&#125; Java代码2123456789101112131415161718class Solution &#123; public int subarraySum(int[] nums, int k) &#123; int count = 0; int sum = 0; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); map.put(0,1); for(int i=0;i&lt;nums.length;i++)&#123; sum+=nums[i]; // 如果sum-k这个数值之前存在，则需要统计在这个区间内之前的前缀和 if(map.containsKey(sum-k))&#123; count+=map.get(sum-k); &#125; // 存储当前的sum值，如果没有就是1，有则获取sum值出现的次数，次数再+1 map.put(sum,map.getOrDefault(sum,0)+1); &#125; return count; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-77-组合]]></title>
    <url>%2F2020%2F07%2F28%2FLeetCode-77-%E7%BB%84%E5%90%88%2F</url>
    <content type="text"><![CDATA[LeetCode-77-组合给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。 示例1： 12345678910输入: n = 4, k = 2输出:[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 解题思路方法1、回溯： 典型的回溯题目，通过画一棵选择树不难看出，当有初始数组[1,2,3,4]，k=2时 选择1之后，选择2，3，4能够组合成新的字串 选择2之后，选择3，4，能够组合成新的字串 可以归纳为，对于第i个选择的数，其和i+1开始到n的所有数进行组合，能够得到新的字串，且不会发生重复。 递归的终止条件为，k==2时，将字串添加进res中 当选择到达要求进行返回时，撤销上一次的选择，进行新的选择组合成新的字串 Java代码12345678910111213141516171819class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); backtrack(res, 1, n, k, new ArrayList&lt;&gt;()); return res; &#125; private void backtrack(List&lt;List&lt;Integer&gt;&gt; res, int i, int n, int k, ArrayList&lt;Integer&gt; temp) &#123; if (k == temp.size()) &#123; res.add(new ArrayList&lt;&gt;(temp)); return; &#125; for (int start = i; start &lt; n + 1; start++) &#123; temp.add(start); backtrack(res, start + 1, n, k, temp); temp.remove(temp.size() - 1); &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-78-子集]]></title>
    <url>%2F2020%2F07%2F27%2FLeetCode-78-%E5%AD%90%E9%9B%86%2F</url>
    <content type="text"><![CDATA[LeetCode-78-子集给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例1： 123456789101112输入: nums = [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 解题思路方法1、迭代： 外层循环遍历原始数组 内层循环遍历结果集，进行结果集的组合 特例：空集是所有结果的子集 当知道目前结果集有[[],[1]]时，想要得到[1,2]的所有子集，可以通过选择数字2和结果集进行组合得到；2与[]组合，得到[2]，2与1组合得到[1,2]。最终结果集为[[],[1],[2],[1,2]]满足数组[1,2]子集结果 在代码上想要进行这类组合，只需要在选择下一个数字后，计算当前结果集的大小，内部循环到size，进行各个位置存的结果的获取，获取之后往尾部添加选择的数字即可。 方法2、回溯： 可以画递归树，看起来更为清晰 回溯的框架： 做出选择 递归进入下一层，此时i+1，从原始数组下一个开始，避免重复选择，所以不需要剪枝 当达到循环结束条件，即数组选完了，撤销上一次选择，走另外的路 Java代码1123456789101112131415class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); res.add(new ArrayList&lt;&gt;()); for (int num : nums) &#123; int size = res.size(); for (int i = 0; i &lt; size; i++) &#123; List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(res.get(i)); tmp.add(num); res.add(tmp); &#125; &#125; return res; &#125;&#125; Java代码212345678910111213141516171819class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; int len = nums.length; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (len == 0) return res; List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); backtrack(nums, 0, path, res); return res; &#125; private void backtrack(int[] nums, int start, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res) &#123; res.add(new ArrayList&lt;&gt;(path)); for (int i = start; i &lt; nums.length; i++) &#123; path.add(nums[i]); backtrack(nums, i + 1, path, res); path.remove(path.size() - 1); &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-72-编辑距离]]></title>
    <url>%2F2020%2F07%2F27%2FLeetCode-72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[LeetCode-72-编辑距离给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 示例1： 123456输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;输出：3解释：horse -&gt; rorse (将 &apos;h&apos; 替换为 &apos;r&apos;)rorse -&gt; rose (删除 &apos;r&apos;)rose -&gt; ros (删除 &apos;e&apos;) 示例2： 12345678输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;输出：5解释：intention -&gt; inention (删除 &apos;t&apos;)inention -&gt; enention (将 &apos;i&apos; 替换为 &apos;e&apos;)enention -&gt; exention (将 &apos;n&apos; 替换为 &apos;x&apos;)exention -&gt; exection (将 &apos;n&apos; 替换为 &apos;c&apos;)exection -&gt; execution (插入 &apos;u&apos;) 解题思路方法1、动态规划： 编辑距离是大厂面试的常考题目，是用作机器翻译和语音识别评价的基本算法 详解见官方https://leetcode-cn.com/problems/edit-distance/solution/bian-ji-ju-chi-by-leetcode-solution/ Java代码12345678910111213141516171819202122public int minDistance(String word1, String word2) &#123; int n1 = word1.length(); int n2 = word2.length(); int[][] dp = new int[n1 + 1][n2 + 1]; // 边界状态初始化 for (int i = 0; i &lt; n1 + 1; i++) &#123; dp[i][0] = i; &#125; for (int j = 0; j &lt; n2 + 1; j++) &#123; dp[0][j] = j; &#125; for (int i = 1; i &lt; n1 + 1; i++) &#123; for (int j = 1; j &lt; n2 + 1; j++) &#123; if (word1.charAt(i - 1) == word2.charAt(j - 1)) &#123; dp[i][j] = dp[i - 1][j - 1]; &#125; else &#123; dp[i][j] = 1 + Math.min(Math.min(dp[i - 1][j - 1], dp[i][j - 1]), dp[i - 1][j]); &#125; &#125; &#125; return dp[n1][n2]; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>字符串</tag>
        <tag>DP</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-890-查找和替换模式]]></title>
    <url>%2F2020%2F07%2F26%2FLeetCode-890-%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9B%BF%E6%8D%A2%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[LeetCode-890-查找和替换模式你有一个单词列表 words 和一个模式 pattern，你想知道 words 中的哪些单词与模式匹配。 如果存在字母的排列 p ，使得将模式中的每个字母 x 替换为 p(x) 之后，我们就得到了所需的单词，那么单词与模式是匹配的。 （回想一下，字母的排列是从字母到字母的双射：每个字母映射到另一个字母，没有两个字母映射到同一个字母。） 返回 words 中与给定模式匹配的单词列表。 你可以按任何顺序返回答案。 示例1： 123456输入：words = [&quot;abc&quot;,&quot;deq&quot;,&quot;mee&quot;,&quot;aqq&quot;,&quot;dkd&quot;,&quot;ccc&quot;], pattern = &quot;abb&quot;输出：[&quot;mee&quot;,&quot;aqq&quot;]解释：&quot;mee&quot; 与模式匹配，因为存在排列 &#123;a -&gt; m, b -&gt; e, ...&#125;。&quot;ccc&quot; 与模式不匹配，因为 &#123;a -&gt; c, b -&gt; c, ...&#125; 不是排列。因为 a 和 b 映射到同一个字母。 提示： 1 &lt;= words.length &lt;= 50 1 &lt;= pattern.length = words[i].length &lt;= 20 解题思路我们可以用两个映射表（map）存储字母到字母的映射关系，第一个映射表保证一个字母不会映射到两个字母，第二个映射表保证不会有两个字母映射到同一个字母。例如 word 为 a，pattern 为 x，那么第一个映射表存储 a -&gt; x，第二个映射表存储 x -&gt; a。 Java代码123456789101112131415161718192021222324class Solution &#123; public List&lt;String&gt; findAndReplacePattern(String[] words, String pattern) &#123; List&lt;String&gt; ans = new ArrayList(); for (String word : words) if (match(word, pattern)) ans.add(word); return ans; &#125; public boolean match(String word, String pattern) &#123; Map&lt;Character, Character&gt; m1 = new HashMap(); Map&lt;Character, Character&gt; m2 = new HashMap(); for (int i = 0; i &lt; word.length(); ++i) &#123; char w = word.charAt(i); char p = pattern.charAt(i); if (!m1.containsKey(w)) m1.put(w, p); if (!m2.containsKey(p)) m2.put(p, w); if (m1.get(w) != p || m2.get(p) != w) return false; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-34-在排序数组中查找元素的第一个和最后一个位置]]></title>
    <url>%2F2020%2F07%2F25%2FLeetCode-34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[LeetCode-34-在排序数组中查找元素的第一个和最后一个位置给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 你的算法时间复杂度必须是 O(log n) 级别。 如果数组中不存在目标值，返回 [-1, -1]。 示例1： 12输入: nums = [5,7,7,8,8,10], target = 8输出: [3,4] 示例2： 12输入: nums = [5,7,7,8,8,10], target = 6输出: [-1,-1] 解题思路方法1、双指针暴力法(low)： 特例判断： 当数组为空或数组长度为0时，直接返回[-1,1] 当数组长度为1时，判断第一个数字是否等于target，等于则返回[0,0]，否则返回[-1,-1] 初始化头尾指针 移动头指针，直到找到第一个等于target的位置，如果找完了都没有找到，返回[-1,-1] 移动尾指针，直到找到最后一个等于target的位置，如果找完了都没有找到，返回[-1,-1] 当头尾指针相同时，说明只有一个target，返回当前位置[start,start]或[end,end] 反之，返回头尾指针区间[start,end] 方法2、二分查找(fast)： 通过判断mid位置的数值，决定左右边界的移动 当nums[mid]&lt;target时，说明target在mid右方，start = mid+1 当nums[mid]&gt;target时，说明target在mid左方，end = mid-1 当nums[mid]==target时，说明左右边界有一个地方等于target，这时候只需要查找另外一个边界等于target的即可，可以进行循环移动查找，最后返回[start,end]即可 如果没有找到，返回[-1,-1] 方法3、递归分治(low)： 通过二分查找切分数组寻找左右子数组的target位置，迭代到只有一个，判断是否是目标值，返回一个都是当前index的数组，然后进行合并即可 方法4、二次二分找左右边界(fast)： 第一次二分找左边界，第二次二分找右边界，找左边界时向右逼近，找右边界时向左逼近 Java代码11234567891011121314151617181920212223class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; int len = nums.length; if(nums==null||len==0) return new int[]&#123;-1,-1&#125;; if(len==1) return nums[0]==target? new int[]&#123;0,0&#125;: new int[]&#123;-1,-1&#125;; int start = 0; int end = len-1; while(nums[start]!=target)&#123; if((start+1)&gt;len-1)&#123; return new int[]&#123;-1,-1&#125;; &#125; start++; &#125; while(nums[end]!=target)&#123; if((end-1)&lt;0)&#123; return new int[]&#123;-1,-1&#125;; &#125; end--; &#125; if(start==end) return new int[]&#123;start,start&#125;; return new int[]&#123;start,end&#125;; &#125;&#125; Java代码212345678910111213141516171819202122class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; int len = nums.length; if(nums==null||len==0) return new int[]&#123;-1,-1&#125;; if(len==1) return nums[0]==target? new int[]&#123;0,0&#125;: new int[]&#123;-1,-1&#125;; int start = 0; int end = len-1; while(start&lt;=end)&#123; int mid = start+(end-start)/2; if(nums[mid]&lt;target)&#123; start = mid+1; &#125;else if(nums[mid]&gt;target)&#123; end = mid-1; &#125;else&#123; while(nums[start]!=target) start++; while(nums[end]!=target) end--; return new int[]&#123;start,end&#125;; &#125; &#125; return new int[]&#123;-1,-1&#125;; &#125;&#125; Java代码31234567891011121314151617181920class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; if(nums.length == 0) return new int[]&#123;-1,-1&#125;; return subSearch(nums,target,0,nums.length-1); &#125; public int[] subSearch(int[] nums,int target,int left, int right)&#123; if(nums[left]&gt;target || nums[right]&lt;target) return new int[]&#123;-1,-1&#125;; if(left==right)&#123; if(nums[left] == target) return new int[]&#123;left,left&#125;; else return new int[]&#123;-1,-1&#125;; &#125; int mid = (left+right)/2; int[] leftRe = subSearch(nums,target,left,mid); int[] rightRe = subSearch(nums,target,mid+1,right); if(leftRe[0] &gt;=0 &amp;&amp; rightRe[0] &gt;=0) return new int[]&#123;leftRe[0],rightRe[1]&#125;; if(leftRe[0] &gt;=0) return leftRe; else return rightRe; &#125;&#125; Java代码4123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; int[] result = new int[2]; result[0] = binarySearchLeftBound(nums, target); result[1] = binarySearchRightBound(nums, target); return result; &#125; public int binarySearchLeftBound(int[] nums, int target) &#123; int l = 0, r = nums.length - 1; while (l &lt;= r) &#123; int mid = l + ((r - l) &gt;&gt; 1); if (nums[mid] &lt; target) &#123; l = mid + 1; &#125; else if (nums[mid] &gt; target) &#123; r = mid - 1; &#125; else if (nums[mid] == target) &#123; r = mid - 1; &#125; &#125; if (l &gt;= nums.length || nums[l] != target) return -1; return l; &#125; public int binarySearchRightBound(int[] nums, int target) &#123; int l = 0, r = nums.length - 1; while (l &lt;= r) &#123; int mid = l + ((r - l) &gt;&gt; 1); if (nums[mid] &lt; target) &#123; l = mid + 1; &#125; else if (nums[mid] &gt; target) &#123; r = mid - 1; &#125; else if (nums[mid] == target) &#123; l = mid + 1; &#125; &#125; if (r &lt; 0 || nums[r] != target) return -1; return r; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-494-目标和]]></title>
    <url>%2F2020%2F07%2F20%2FLeetCode-494-%E7%9B%AE%E6%A0%87%E5%92%8C%2F</url>
    <content type="text"><![CDATA[LeetCode-494-目标和给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。 返回可以使最终数组和为目标数 S 的所有添加符号的方法数。 示例1： 1234567891011输入：nums: [1, 1, 1, 1, 1], S: 3输出：5解释：-1+1+1+1+1 = 3+1-1+1+1+1 = 3+1+1-1+1+1 = 3+1+1+1-1+1 = 3+1+1+1+1-1 = 3一共有5种方法让最终目标和为3。 提示： 数组非空，且长度不会超过 20 。 初始的数组的和不会超过 1000 。 保证返回的最终结果能被 32 位整数存下。 解题思路方法1、回溯： 每一步选择都有该位置数的正负2种选择方案，画成树状图可以知道需要DFS遍历2棵树 1棵树以第1位数为正开始寻找，1棵树以第1位数为负开始寻找，找到符合要求的答案。 类似于暴力穷举。 当遍历的深度达到数组长度，且路径和等于S的时候，说明找到了一条路径，count++ 当不满足路径和要求时，返回上一层，进行回溯，撤销上一次的选择。 方法2、动态规划： 详见https://leetcode-cn.com/problems/target-sum/solution/494-mu-biao-he-by-ming-zhi-shan-you-m9rfkvkdad/ Java代码11234567891011121314151617181920212223242526272829class Solution &#123; int res = 0; int count = 0; public int findTargetSumWays(int[] nums, int S) &#123; int len = nums.length; backtrack(0,nums,S,len); return count; &#125; public void backtrack(int i,int[] nums,int S,int len)&#123; if(i==len)&#123; if(res==S)&#123; count++; &#125; return; &#125; // 选择正号 res+=nums[i]; backtrack(i+1,nums,S,len); // 撤销选择 res-=nums[i]; // 选择负号 res-=nums[i]; backtrack(i+1,nums,S,len); // 撤销选择 res+=nums[i]; &#125;&#125; Java代码2123456789101112131415161718192021222324class Solution&#123; public int findTargetSumWays(int[] nums, int S)&#123; if(nums.length == 0) return 0; int sum = 0; for(int i = 0; i &lt; nums.length; i++) sum += nums[i]; if (Math.abs(S) &gt; Math.abs(sum)) return 0; int[][] dp = new int[nums.length][sum*2+1]; if(nums[0] == 0) dp[0][sum] = 2; else&#123; dp[0][sum+nums[0]] = 1; dp[0][sum-nums[0]] = 1; &#125; for(int i = 1; i&lt;nums.length; i++)&#123; for(int j = 0; j&lt;(sum*2+1);j++)&#123; int l = (j - nums[i]) &gt;= 0 ? j - nums[i] : 0; int r = (j + nums[i]) &lt; (sum*2+1) ? j + nums[i] : 0; dp[i][j] = dp[i-1][l] + dp[i-1][r]; &#125; &#125; return dp[nums.length-1][sum+S]; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
        <tag>DP</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-461-汉明距离]]></title>
    <url>%2F2020%2F07%2F20%2FLeetCode-461-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[LeetCode-461-汉明距离两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。 给出两个整数 x 和 y，计算它们之间的汉明距离。 注意：0 ≤ x, y &lt; 2^31. 示例1： 12345678910输入: x = 1, y = 4输出: 2解释:1 (0 0 0 1)4 (0 1 0 0) ↑ ↑上面的箭头指出了对应二进制位不同的位置。 解题思路方法1、异或+移位： 不难看出异或运算能够保留数据中不相同位置的1，之后我们只需要统计1的个数即可 在Java中内置函数Integer.bitCount(x^y)可以快速计算出1的个数 另外一种方式是将每个位逻辑位移，移动到最左侧，或者最右侧，检查该位是否为1 这里采用移动到最右侧的方式，即右移运算 使用取模%2运算或者AND运算&amp;1，检查最右边的一位是否为1，这两个操作都会屏蔽最右位以外的其他位。 Java代码12345678910111213class Solution &#123; public int hammingDistance(int x, int y) &#123; int xOry = x^y; int distance = 0; while(xOry!=0)&#123; if((xOry%2)==1)&#123; // 或者使用(xOry&amp;1)也可以 distance++; &#125; xOry=xOry&gt;&gt;1; &#125; return distance; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-207-课程表]]></title>
    <url>%2F2020%2F07%2F18%2FLeetCode-207-%E8%AF%BE%E7%A8%8B%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[LeetCode-207-课程表你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1] 给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？ 示例1： 123输入: 2, [[1,0]] 输出: true解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。 示例2： 123输入: 2, [[1,0],[0,1]]输出: false解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。 提示： 输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。 你可以假定输入的先决条件中没有重复的边。 1 &lt;= numCourses &lt;= 10^5 解题思路转载自https://leetcode-cn.com/problems/course-schedule/solution/course-schedule-tuo-bu-pai-xu-bfsdfsliang-chong-fa/ 课程安排图问题，可以转化为通过拓扑排序判断这个图是否是有向无环图 拓扑排序的原理：可见这篇文章 方法1、入度表(BFS)： 算法流程： 统计课程安排图中每个节点的入度，生成 入度表 indegrees。 借助一个队列 queue，将所有入度为 0 的节点入队。 当 queue 非空时，依次将队首节点出队，在课程安排图中删除此节点pre： 并不是真正从邻接表中删除此节点 pre，而是将此节点对应所有邻接节点cur的入度 -1，即indegrees[cur] -= 1。 当入度 -1后邻接节点cur 的入度为 0，说明 cur所有的前驱节点已经被 “删除”，此时将 cur入队。 在每次 pre出队时，执行 numCourses--； 若整个课程安排图是有向无环图（即可以安排），则所有节点一定都入队并出队过，即完成拓扑排序。换个角度说，若课程安排图中存在环，一定有节点的入度始终不为 0。 因此，拓扑排序出队次数等于课程个数，返回 numCourses == 0 判断课程是否可以成功安排。 复杂度分析： 时间复杂度 O(N + M)： 遍历一个图需要访问所有节点和所有临边，N 和 M 分别为节点数量和临边数量； 空间复杂度 O(N + M)： 为建立邻接表所需额外空间，adjacency 长度为 N ，并存储 M 条临边的数据。 Java代码12345678910111213141516171819202122232425262728class Solution &#123; public boolean canFinish(int numCourses, int[][] prerequisites) &#123; int[] indegrees = new int[numCourses]; List&lt;List&lt;Integer&gt;&gt; adjacency = new ArrayList&lt;&gt;(); Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for(int i=0;i&lt;numCourses;i++)&#123; adjacency.add(new ArrayList&lt;&gt;()); &#125; // 获得每个课程入度和邻接表 for(int[] cp:prerequisites)&#123; indegrees[cp[0]]++; adjacency.get(cp[1]).add(cp[0]); &#125; // 获得所有入度为0的课程 for(int i=0;i&lt;numCourses;i++)&#123; if(indegrees[i]==0) queue.add(i); &#125; // BFS while(!queue.isEmpty())&#123; int pre = queue.poll(); numCourses--; for(int cur: adjacency.get(pre))&#123; if(--indegrees[cur]==0) queue.add(cur); &#125; &#125; return numCourses == 0; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
        <tag>图论算法</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-406-根据身高重建队列]]></title>
    <url>%2F2020%2F07%2F18%2FLeetCode-406-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[LeetCode-406-根据身高重建队列假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。 注意：总人数少于1100人。 示例： 12345输入:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]输出:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 解题思路方法1、贪心算法(排序+插入): 详见官方题解：https://leetcode-cn.com/problems/queue-reconstruction-by-height/solution/gen-ju-shen-gao-zhong-jian-dui-lie-by-leetcode/ 算法： 排序： 按高度降序排列。 在同一高度的人中，按 k 值的升序排列。 逐个地把它们放在输出队列中，索引等于它们的 k 值。 返回输出队列 Java代码12345678910111213141516171819class Solution &#123; public int[][] reconstructQueue(int[][] people) &#123; Arrays.sort(people, new Comparator&lt;int[]&gt;() &#123; // 如果两个人的身高相同，则需要按照k值进行升序排列 // 如果不同则按照身高降序排列 // 注意下面的数组下标是不同的 @Override public int compare(int[] o1, int[] o2) &#123; return o1[0] == o2[0] ? o1[1] - o2[1] : o2[0] - o1[0]; &#125; &#125;); List&lt;int[]&gt; output = new LinkedList&lt;&gt;(); for (int[] p : people) &#123; output.add(p[1], p); &#125; int n = people.length; return output.toArray(new int[n][2]); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-206-反转链表]]></title>
    <url>%2F2020%2F07%2F17%2FLeetCode-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[LeetCode-206-反转链表反转一个单链表。 示例1： 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 解题思路方法1、迭代： 利用pre指针指向null，并利用cur指针存储head节点，当cur不为空的时候 临时存储cur.next，因为要改变指向，将cur.next指向pre，将pre移动到cur的位置，将cur移动到cur.next即temp 最后返回pre即可 方法2、递归： 递归方法不容易理解，详见https://leetcode-cn.com/problems/reverse-linked-list/solution/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/中的幻灯片演示 Java代码112345678910111213141516171819202122/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseList(ListNode head) &#123; if(head==null||head.next==null) return head; ListNode pre = null; ListNode cur = head; while(cur!=null)&#123; ListNode temp = cur.next; cur.next = pre; pre = cur; cur = temp; &#125; return pre; &#125;&#125; Java代码212345678910111213141516171819class Solution &#123; public ListNode reverseList(ListNode head) &#123; //递归终止条件是当前为空，或者下一个节点为空 if(head==null || head.next==null) &#123; return head; &#125; //这里的cur就是最后一个节点 ListNode cur = reverseList(head.next); //这里请配合动画演示理解 //如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，那么此时的cur就是5 //而head是4，head的下一个是5，下下一个是空 //所以head.next.next 就是5-&gt;4 head.next.next = head; //防止链表循环，需要将head.next设置为空 head.next = null; //每层递归函数都返回cur，也就是最后一个节点 return cur; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-32-最长有效括号]]></title>
    <url>%2F2020%2F07%2F17%2FLeetCode-32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[LeetCode-32-最长有效括号给定一个只包含 &#39;(&#39; 和 &#39;)&#39; 的字符串，找出最长的包含有效括号的子串的长度。 示例1： 123输入: &quot;(()&quot;输出: 2解释: 最长有效括号子串为 &quot;()&quot; 示例2： 123输入: &quot;)()())&quot;输出: 4解释: 最长有效括号子串为 &quot;()()&quot; 解题思路方法1、动态规划： 详见链接：https://leetcode-cn.com/problems/longest-valid-parentheses/solution/zui-chang-you-xiao-gua-hao-by-leetcode-solution/ 方法2、栈： 具体做法是我们始终保持栈底元素为当前已经遍历过的元素中「最后一个没有被匹配的右括号的下标」，这样的做法主要是考虑了边界条件的处理，栈里其他元素维护左括号的下标： 对于遇到的每个‘(’ ，我们将它的下标放入栈中 对于遇到的每个 ‘)’ ，我们先弹出栈顶元素表示匹配了当前右括号： 如果栈为空，说明当前的右括号为没有被匹配的右括号，我们将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」 如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」 我们从前往后遍历字符串并更新答案即可。 需要注意的是，如果一开始栈为空，第一个字符为左括号的时候我们会将其放入栈中，这样就不满足提及的「最后一个没有被匹配的右括号的下标」，为了保持统一，我们在一开始的时候往栈中放入一个值为 −1 的元素。 方法3、双指针： 在此方法中，我们利用两个计数器 left 和right 。首先，我们从左到右遍历字符串，对于遇到的每个‘(’，我们增加 left 计数器，对于遇到的每个‘)’ ，我们增加 right 计数器。每当 left 计数器与 right 计数器相等时，我们计算当前有效字符串的长度，并且记录目前为止找到的最长子字符串。当 right 计数器比 left 计数器大时，我们将 left 和 right 计数器同时变回 0。 这样的做法贪心地考虑了以当前字符下标结尾的有效括号长度，每次当右括号数量多于左括号数量的时候之前的字符我们都扔掉不再考虑，重新从下一个字符开始计算，但这样会漏掉一种情况，就是遍历的时候左括号的数量始终大于右括号的数量，即 (() ，这种时候最长有效括号是求不出来的。 解决的方法也很简单，我们只需要从右往左遍历用类似的方法计算即可，只是这个时候判断条件反了过来： 当left 计数器比right 计数器大时，我们将left 和right 计数器同时变回 0当 left 计数器与 right 计数器相等时，我们计算当前有效字符串的长度，并且记录目前为止找到的最长子字符串这样我们就能涵盖所有情况从而求解出答案。 Java代码11234567891011121314151617class Solution &#123; public int longestValidParentheses(String s) &#123; int maxans = 0; int dp[] = new int[s.length()]; for (int i = 1; i &lt; s.length(); i++) &#123; if (s.charAt(i) == ')') &#123; if (s.charAt(i - 1) == '(') &#123; dp[i] = (i &gt;= 2 ? dp[i - 2] : 0) + 2; &#125; else if (i - dp[i - 1] &gt; 0 &amp;&amp; s.charAt(i - dp[i - 1] - 1) == '(') &#123; dp[i] = dp[i - 1] + ((i - dp[i - 1]) &gt;= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2; &#125; maxans = Math.max(maxans, dp[i]); &#125; &#125; return maxans; &#125;&#125; Java代码21234567891011121314151617181920class Solution &#123; public int longestValidParentheses(String s) &#123; int max = 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); stack.push(-1); for(int i=0;i&lt;s.length();i++)&#123; if(s.charAt(i)=='(')&#123; stack.push(i); &#125;else&#123; stack.pop(); if(stack.isEmpty())&#123; stack.push(i); &#125;else&#123; max = Math.max(max,i-stack.peek()); &#125; &#125; &#125; return max; &#125;&#125; Java代码312345678910111213141516171819202122232425262728293031323334class Solution &#123; public int longestValidParentheses(String s) &#123; int left = 0, right = 0, maxlength = 0; for (int i = 0; i &lt; s.length(); i++) &#123; if (s.charAt(i) == '(') &#123; left++; &#125; else &#123; right++; &#125; if (left == right) &#123; maxlength = Math.max(maxlength, 2 * right); &#125; else if (right &gt; left) &#123; left = 0; right = 0; &#125; &#125; left = 0; right = 0; for (int i = s.length() - 1; i &gt;= 0; i--) &#123; if (s.charAt(i) == '(') &#123; left++; &#125; else &#123; right++; &#125; if (left == right) &#123; maxlength = Math.max(maxlength, 2 * left); &#125; else if (left &gt; right) &#123; left = 0; right = 0; &#125; &#125; return maxlength; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>字符串</tag>
        <tag>DP</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-64-最小路径和]]></title>
    <url>%2F2020%2F07%2F16%2FLeetCode-64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C%2F</url>
    <content type="text"><![CDATA[LeetCode-64-最小路径和给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例： 12345678输入:[ [1,3,1], [1,5,1], [4,2,1]]输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。 解题思路方法1、动态规划： 特例判断：当行或者列为空，行列其中一个为0的时候，数组没有意义，直接返回0 由于只能往下或者往右走，所以第一行和第一列的值始终是由单个方向移动得到 这一部分的值可以先通过循环累加得到 剩下的位置，以i=1，j=1的位置，数字5为例，数字5位置的最小值可以由，Min(上方位置的值+5，左方位置的值+5)计算得到 所以当前的状态可以定义为：从左方和右方计算得到的当前位置的路径最小值 不难看出，数值可以在原本的数组中原地改变且不影响结果。 状态转移方程为： grid[i][j] = Math.min(grid[i-1][j]+grid[i][j],grid[i][j-1]+grid[i][j]); 由于当前位置始终存储到达该位置的路径最小值，则最后到达右下角时，就是该矩阵中到达右下角总和最小的路径和 横向按顺序遍历的方法类似，这里不再重复介绍，详见Python代码 Java代码123456789101112131415161718192021class Solution &#123; public int minPathSum(int[][] grid) &#123; int rowlen = grid.length; int collen = grid[0].length; if(grid==null||rowlen==0||grid[0]==null||collen==0)&#123; return 0; &#125; for(int i=1;i&lt;collen;i++)&#123; grid[0][i] += grid[0][i-1]; &#125; for(int j=1;j&lt;rowlen;j++)&#123; grid[j][0] += grid[j-1][0]; &#125; for(int i=1;i&lt;rowlen;i++)&#123; for(int j=1;j&lt;collen;j++)&#123; grid[i][j] = Math.min(grid[i-1][j]+grid[i][j],grid[i][j-1]+grid[i][j]); &#125; &#125; return grid[rowlen-1][collen-1]; &#125;&#125; Python代码123456789class Solution: def minPathSum(self, grid: [[int]]) -&gt; int: for i in range(len(grid)): for j in range(len(grid[0])): if i == j == 0: continue elif i == 0: grid[i][j] = grid[i][j - 1] + grid[i][j] elif j == 0: grid[i][j] = grid[i - 1][j] + grid[i][j] else: grid[i][j] = min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j] return grid[-1][-1]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
        <tag>DP</tag>
        <tag>Python</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-739-每日温度]]></title>
    <url>%2F2020%2F07%2F16%2FLeetCode-739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[LeetCode-739-每日温度请根据每日气温列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。 例如，给定一个列表temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。 提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100]范围内的整数。 解题思路方法1、暴力破解： 顺序遍历数组，固定第一个数，往后找比他大的数的位置，位置之差就是新数组中该数位置的值。之后固定第二个…直到数组结束 方法2、单调栈： 使用一个栈存储元素下标，当栈内有元素(不为空)，且新温度大于栈顶元素时，弹出栈顶元素，计算下标差值，作为栈顶元素位置的值。 继续看新的栈顶元素，直到当前数字小于等于栈顶元素停止，然后将数字入栈，这样就可以保持递减栈，且每个数字和第一个大于它的数的距离也可以算出来 Java代码123456789101112131415161718class Solution &#123; public int[] dailyTemperatures(int[] T) &#123; int len = T.length; int[] dp = new int[len]; for (int i = 0; i &lt; len; i++) &#123; int j = i; while (j &lt; len) &#123; if (T[i] &lt; T[j]) &#123; dp[i] = j - i; break; &#125; else &#123; j++; &#125; &#125; &#125; return dp; &#125;&#125; Java代码2123456789101112131415class Solution &#123; public int[] dailyTemperatures(int[] T) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int len = T.length; int[] res = new int[len]; for(int i=0;i&lt;len;i++)&#123; while(!stack.isEmpty()&amp;&amp;T[i]&gt;T[stack.peek()])&#123; int pre = stack.pop(); res[pre] = i-pre; &#125; stack.add(i); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-102-二叉树的层序遍历]]></title>
    <url>%2F2020%2F07%2F15%2FLeetCode-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[LeetCode-102-二叉树的层序遍历给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 示例：二叉树：[3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 返回其层次遍历结果： 12345[ [3], [9,20], [15,7]] 解题思路方法1、Queue迭代： 利用一个Queue存储每层的节点，当一层没有遍历完时，持续poll出队列中的节点，并同时加入对应左右节点进入queue中，当一层遍历完成之后加入到结果集res中。 Java代码12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); if(root==null) return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty())&#123; List&lt;Integer&gt; row = new LinkedList&lt;&gt;(); int size = queue.size(); for(int i=0;i&lt;size;i++)&#123; TreeNode temp = queue.poll(); row.add(temp.val); if(temp.left!=null) queue.add(temp.left); if(temp.right!=null) queue.add(temp.right); &#125; res.add(new LinkedList&lt;&gt;(row)); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>树</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-169-多数元素]]></title>
    <url>%2F2020%2F07%2F15%2FLeetCode-169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[LeetCode-169-多数元素给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例1： 12输入: [3,2,3]输出: 3 示例2： 12输入: [2,2,1,1,1,2,2]输出: 2 解题思路方法1、哈希表： 利用一个哈希表计算频率，当元素的频率大于nums.length/2的时候就是要找的元素 方法2、排序： 由于多数元素在数组中出现的次数大于n/2，于是可以将数组排序，对应nums.length/2的位置就是这个多数元素 方法3、摩尔计数法： 原文链接：https://leetcode-cn.com/problems/majority-element/solution/3chong-fang-fa-by-gfu-2/ 候选人(cand_num)初始化为nums[0]，票数count初始化为1。当遇到与cand_num相同的数，则票数count = count + 1，否则票数count = count - 1。当票数count为0时，更换候选人，并将票数count重置为1。遍历完数组后，cand_num即为最终答案。 为何这行得通呢？投票法是遇到相同的则票数 + 1，遇到不同的则票数 - 1。且“多数元素”的个数&gt; ⌊ n/2 ⌋，其余元素的个数总和&lt;= ⌊ n/2 ⌋。因此“多数元素”的个数 - 其余元素的个数总和 的结果 肯定 &gt;= 1。这就相当于每个“多数元素”和其他元素 两两相互抵消，抵消到最后肯定还剩余至少1个“多数元素”。 无论数组是1 2 1 2 1，亦或是1 2 2 1 1，总能得到正确的候选人。 Java代码112345678910111213141516class Solution &#123; public int majorityElement(int[] nums) &#123; int len = nums.length; int res = Integer.MIN_VALUE; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int num:nums)&#123; map.put(num,map.getOrDefault(num,0)+1); &#125; for(Map.Entry&lt;Integer,Integer&gt; entry: map.entrySet())&#123; if(entry.getValue()&gt;len/2)&#123; res = entry.getKey(); &#125; &#125; return res; &#125;&#125; Java代码2123456class Solution &#123; public int majorityElement(int[] nums) &#123; Arrays.sort(nums); return nums[nums.length/2]; &#125;&#125; Java代码31234567891011121314class Solution &#123; public int majorityElement(int[] nums) &#123; int cand_num = nums[0], count = 1; for (int i = 1; i &lt; nums.length; ++i) &#123; if (cand_num == nums[i]) ++count; else if (--count == 0) &#123; cand_num = nums[i]; count = 1; &#125; &#125; return cand_num; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-347-前K个高频元素]]></title>
    <url>%2F2020%2F07%2F15%2FLeetCode-347-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[LeetCode-347-前K个高频元素给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例1： 12输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2] 示例2： 12输入: nums = [1], k = 1输出: [1] 提示： 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。 你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。 你可以按任意顺序返回答案。 解题思路方法1、最小堆： 首先利用Map来计算数组中数字出现的频率 之后利用一个优先队列，在存储的过程中按照频率进行排序，且只存储频率最高的前K个数 由于题目要求的顺序可以不同，所以最后一次弹出queue中的数字到list中就好了 计算频率这个步骤需要 O(N)时间其中 N是列表中元素个数。 第二步建立堆，堆中添加一个元素的复杂度是 O(log(k))，要进行 N 次复杂度是 O(N)。 最后一步是输出结果，复杂度为 O(klog(k))。第二步和最后一步复杂度综合O(Nlog(k))。 因此总复杂度为O(N+Nlog(k)) = O(Nlog(k)) Java代码123456789101112131415161718192021222324class Solution &#123; public int[] topKFrequent(int[] nums, int k) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int num : nums) &#123; map.put(num, map.getOrDefault(num, 0) + 1); &#125; PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; queue = new PriorityQueue&lt;&gt;((v1, v2) -&gt; v1.getValue() - v2.getValue()); for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; if (queue.size() &lt; k) &#123; queue.add(entry); &#125; else &#123; if (entry.getValue() &gt; queue.peek().getValue()) &#123; queue.poll(); queue.add(entry); &#125; &#125; &#125; while (!queue.isEmpty()) &#123; list.add(queue.poll().getKey()); &#125; return list.stream().mapToInt(Integer::intValue).toArray(); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-114-二叉树展开为链表]]></title>
    <url>%2F2020%2F07%2F14%2FLeetCode-114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[LeetCode-114-二叉树展开为链表给定一个二叉树，原地将它展开为一个单链表。 例如，给定二叉树 12345 1 / \ 2 5 / \ \3 4 6 将其展开为： 12345678910111 \ 2 \ 3 \ 4 \ 5 \ 6 解题思路方法1、递归： 先将根节点的左子树变成链表，之后将根节点的右子树变成链表 最后将变成链表的右子树放在变成链表的左子树的最右边 方法2、迭代： 从右至左的先序遍历，用一个栈来存储节点，先存储右节点后存储左节点，同时需要一个pre指针指向上一个节点，用于拼接前一个节点和当前节点 当栈中弹出节点时，当前节点始终是拼接在前一个节点的右侧，于是pre.left=null、pre.right=temp,当当前节点temp右子节点不为空时，右子节点入栈，当左子节点不为空时，左子节点入栈。完成当前节点的左右子节点遍历，前一个节点变为链表中当前节点即pre=pre.right Java代码11234567891011121314151617181920class Solution &#123; public void flatten(TreeNode root) &#123; if(root == null)&#123; return ; &#125; //将根节点的左子树变成链表 flatten(root.left); //将根节点的右子树变成链表 flatten(root.right); TreeNode temp = root.right; //把树的右边换成左边的链表 root.right = root.left; //记得要将左边置空 root.left = null; //找到树的最右边的节点 while(root.right != null) root = root.right; //把右边的链表接到刚才树的最右边的节点 root.right = temp; &#125;&#125; Java代码21234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public void flatten(TreeNode root) &#123; if(root==null) return; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.add(root); TreeNode pre = new TreeNode(-1); while(!stack.isEmpty())&#123; TreeNode temp = stack.pop(); pre.left = null; pre.right = temp; if(temp.right!=null)&#123; stack.add(temp.right); &#125; if(temp.left!=null)&#123; stack.add(temp.left); &#125; pre = pre.right; &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>树</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-581-最短无序连续子数组]]></title>
    <url>%2F2020%2F07%2F14%2FLeetCode-581-%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[LeetCode-581-最短无序连续子数组给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。 你找到的子数组应是最短的，请输出它的长度。 示例1： 123输入: [2, 6, 4, 8, 10, 9, 15]输出: 5解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。 说明 : 输入的数组长度范围在 [1, 10,000]。 输入的数组可能包含重复元素 ，所以升序的意思是&lt;=。 解题思路方法1、排序比较： 先给数组排序，然后进行一一比较，遇到不相等的位置就更新start和end start始终靠最小值比较，end始终靠最大值比较 之后就能够通过end-start+1得到未排序子数组的长度 特例判断：只有当end-start+1&gt;=0时，长度计算有效，否则为0 方法2、双指针找边界： 初步思路是，使用双指针，指针i从头开始遍历，指针j从尾开始遍历。分别找到第一个逆序的位置，之后返回长度即可，但这种方法不适用于数组中有重复的数字的情况，如[1,6,5,5]，这使得逆序位置的判断失效。 于是换一种思路，让指针分别找到最后逆序的位置 同时从前往后和从后往前遍历，分别得到要排序数组的右边界和左边界；寻找右边界：从前往后遍历的过程中，用max记录遍历过的最大值，如果max大于当前的nums[i]，说明nums[i]的位置不正确，属于需要排序的数组，因此将右边界更新为i，然后更新max；这样最终可以找到需要排序的数组的右边界，右边界之后的元素都大于max；寻找左边界：从后往前遍历的过程中，用min记录遍历过的最小值，如果min小于当前的nums[j]，说明nums[j]的位置不正确，应该属于需要排序的数组，因此将左边界更新为j，然后更新min；这样最终可以找到需要排序的数组的左边界，左边界之前的元素都小于min；（从前往后遍历和从后往前遍历两个过程可以分两次循环完成，也可以放一起完成，这样的话就有：j=len-i-1） Java代码1123456789101112131415class Solution &#123; public int findUnsortedSubarray(int[] nums) &#123; int[] temp = nums.clone(); Arrays.sort(temp); int start = temp.length; int end = 0; for (int i = 0; i &lt; temp.length; i++) &#123; if (nums[i] != temp[i]) &#123; start = Math.min(start, i); end = Math.max(end, i); &#125; &#125; return end - start + 1 &gt;= 0 ? end - start + 1 : 0; &#125;&#125; Java代码2123456789101112131415161718192021class Solution &#123; public int findUnsortedSubarray(int[] nums) &#123; int len = nums.length; int max = nums[0]; int min = nums[len-1]; int l = 0, r = -1; for(int i=0;i&lt;len;i++)&#123; if(max&gt;nums[i])&#123; r = i; &#125;else&#123; max = nums[i]; &#125; if(min&lt;nums[len-i-1])&#123; l = len-i-1; &#125;else&#123; min = nums[len-i-1]; &#125; &#125; return r-l+1; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-234-回文链表]]></title>
    <url>%2F2020%2F07%2F13%2FLeetCode-234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[LeetCode-234-回文链表请判断一个链表是否为回文链表。 示例1： 12输入: 1-&gt;2输出: false 示例2： 12输入: 1-&gt;2-&gt;2-&gt;1输出: true 进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？ 解题思路方法1、快慢指针+反转链表： 先通过快慢指针找到链表中点 奇偶情况不同，奇数情况应该跳过中心节点，偶数情况中心节点为2个，需要翻转的的位置仍然是slow.next开始 之后进行后半部分的链表反转 反转完成之后分别从链表的头部开始遍历匹配，当两个链表都不为空的时候，不断移动两端指针比较指针的值是否相等 Java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isPalindrome(ListNode head) &#123; if(head==null||head.next==null) return true; ListNode dummy = new ListNode(-1); dummy.next = head; ListNode fast = dummy; ListNode slow = dummy; while(fast!=null&amp;&amp;fast.next!=null)&#123; slow = slow.next; fast = fast.next.next; &#125; ListNode head2 = reverseLink(slow.next); slow.next = null; while(head!=null&amp;&amp;head2!=null)&#123; if(head.val!=head2.val)&#123; return false; &#125;else&#123; head = head.next; head2 = head2.next; &#125; &#125; return true; &#125; public ListNode reverseLink(ListNode head)&#123; if(head==null||head.next==null) return head; ListNode pre = null; ListNode cur = head; while(cur!=null)&#123; ListNode temp = cur.next; cur.next = pre; pre = cur; cur = temp; &#125; return pre; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-287-寻找重复数]]></title>
    <url>%2F2020%2F07%2F13%2FLeetCode-287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[LeetCode-287-寻找重复数给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 示例1： 12输入: [1,3,4,2,2]输出: 2 示例2： 12输入: [3,1,3,4,2]输出: 3 说明： 不能更改原数组（假设数组是只读的）。 只能使用额外的 O(1) 的空间。 时间复杂度小于 O(n2) 。 数组中只有一个重复的数字，但它可能不止重复出现一次。 解题思路方法1、二分查找： 我们知道二分查找算法要求数组是有序的，而本题中数组不是有序的，但有数字都在1到n的这个条件。而1到n本身就是一个有序序列，于是可以使用二分查找进行判断。 mid = (left+right)/2，判断答案是在[left,mid]中，还是在[mid+1,right]中 我们只需要一次遍历数组，统计原数组中小于等于mid的个数，记为count 当count&lt;=mid时，说明[left,mid]范围中没有重复的数字，答案应该在[mid+1,right]中 反之，当count&gt;mid时，说明[left,mid]中有重复的数字，将right变为mid再进行查找 Java代码123456789101112131415161718192021class Solution &#123; public int findDuplicate(int[] nums) &#123; int left = 0; int right = nums.length; while(left&lt;right)&#123; int mid = (left+right)&gt;&gt;1; int count = 0; for(int num : nums)&#123; if(num&lt;=mid)&#123; count++; &#125; &#125; if(count&lt;=mid)&#123; left = mid+1; &#125;else&#123; right = mid; &#125; &#125; return right; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-155-最小栈]]></title>
    <url>%2F2020%2F07%2F13%2FLeetCode-155-%E6%9C%80%E5%B0%8F%E6%A0%88%2F</url>
    <content type="text"><![CDATA[LeetCode-155-最小栈设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) —— 将元素 x 推入栈中。 pop() —— 删除栈顶的元素。 top() —— 获取栈顶元素。 getMin() —— 检索栈中的最小元素。 示例1： 12345678910111213141516输入：[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;][[],[-2],[0],[-3],[],[],[],[]]输出：[null,null,null,null,-3,null,0,-2]解释：MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.getMin(); --&gt; 返回 -2. 提示： pop、top 和 getMin 操作总是在 非空栈 上调用。 如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 解题思路方法1、两个栈： 需要一个数据栈，一个最小栈 最小栈始终存储当前的最小值 在push进数据栈的同时，判断最小栈是否为空或者新值是否小于最小栈的顶部值， 如果小于则加入新值到最小栈，如果不小于则加入最小栈栈顶(即上一个最小元素)入最小栈 当需要pop的时候，同时弹出最小栈和数据栈数值 当需要getMin时，返回最小栈的栈顶元素即是当前最小元素 当需要拿到top时，返回数据栈栈顶元素 Java代码123456789101112131415161718192021222324252627282930313233343536373839404142class MinStack &#123; private Stack&lt;Integer&gt; stack_data; private Stack&lt;Integer&gt; stack_min; /** initialize your data structure here. */ public MinStack() &#123; stack_data = new Stack&lt;&gt;(); stack_min = new Stack&lt;&gt;(); &#125; public void push(int x) &#123; stack_data.push(x); if(stack_min.size()==0||x&lt;stack_min.peek())&#123; stack_min.push(x); &#125;else&#123; stack_min.push(stack_min.peek()); &#125; &#125; public void pop() &#123; stack_data.pop(); stack_min.pop(); &#125; public int top() &#123; return stack_data.peek(); &#125; public int getMin() &#123; return stack_min.peek(); &#125;&#125;/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-152-乘积最大子数组]]></title>
    <url>%2F2020%2F07%2F12%2FLeetCode-152-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[LeetCode-152-乘积最大子数组给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。 示例1： 123输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。 示例2： 123输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 解题思路方法1、动态规划： 遍历数组的时候不断计算当前的最大值 同时还需要记录之前的最小值，当遍历的到的nums[i]为负数的时候 最大值*负数：会导致最大值变为最小 最小值*负数：会导致最小值变为最大 所以需要维护当前的最大值和当前的最小值 最大值可由curMax = Math.max(curMax*nums[i],nums[i]);计算 最小值可由curMin = Math.min(curMin*nums[i],nums[i]);计算 最大值和最小值会发生互换，导致结果不对 既然这样当遇到负数nums[i]的时候，提前将最大值和最小值互换，就可以维持原本的最大最小值 一个更好的题解来自https://leetcode-cn.com/problems/maximum-product-subarray/solution/dpfang-fa-xiang-jie-by-yang-cong-12/ Java代码123456789101112131415161718class Solution &#123; public int maxProduct(int[] nums) &#123; int max = Integer.MIN_VALUE; int curMax = 1; int curMin = 1; for(int i=0;i&lt;nums.length;i++)&#123; if(nums[i]&lt;0)&#123; int temp = curMax; curMax = curMin; curMin = temp; &#125; curMax = Math.max(curMax*nums[i],nums[i]); curMin = Math.min(curMin*nums[i],nums[i]); max = Math.max(max,curMax); &#125; return max; &#125;&#125; dp数组版本 Java代码1234567891011121314151617181920212223242526class Solution &#123; public int maxProduct(int[] nums) &#123; int[] dp_max = new int[nums.length+1]; int[] dp_min = new int[nums.length+1]; if(nums.length == 0) return 0; int max = Integer.MIN_VALUE; // 由于存在负数，所以需要维护两个数组 // dp_max[i] 指的是以第 i 个数结尾的 乘积最大 的连续子序列 // dp_min[i] 指的是以第 i 个数结尾的 乘积最小 的连续子序列 dp_max[0] = 1; dp_min[0] = 1; for (int i = 1;i &lt;= nums.length;i++)&#123; // 如果数组的数是负数，那么会导致 max 变成 min，min 变成 max // 故需要交换dp if(nums[i-1] &lt; 0)&#123; int temp = dp_min[i-1]; dp_min[i-1] = dp_max[i-1]; dp_max[i-1] = temp; &#125; dp_min[i] = Math.min(nums[i-1],dp_min[i-1]*nums[i-1]); dp_max[i] = Math.max(nums[i-1],dp_max[i-1]*nums[i-1]); max = Math.max(max,dp_max[i]); &#125; return max; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-160-相交链表]]></title>
    <url>%2F2020%2F07%2F11%2FLeetCode-160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[LeetCode-160-相交链表编写一个程序，找到两个单链表相交的起始节点。 如下面的两个链表： 1234567 a1---&gt;a2 \ \ c1---&gt;c2---&gt;c3 / / b1---&gt;b2---&gt;b3 在节点c1开始相交 示例1： 123输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Reference of the node with value = 8输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例2： 123输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Reference of the node with value = 2输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例3： 1234输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。解释：这两个链表不相交，因此返回 null。 注意： 如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 解题思路方法1、快慢指针： 短链表的指针会先到达链表末尾，称为快指针，此时将短链表指针指向长链表头部， 当短链表到达末尾时，长链表还剩的节点就是长短链表的相差的个数n， 这个时候短链表和长链表继续向前走，当长链表的慢指针到达尾部的时候，快指针就会从长链表头部走n步，此时再将慢指针变为短链表头部，就能够使得长短链表开始的头部位置相同 继续往下遍历直到链表头部值相等，如果找完了都不相等则返回null Java代码12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if(headA==null||headB==null) return null; ListNode tempA = headA; ListNode tempB = headB; while(tempA!=tempB)&#123; if(tempA!=null)&#123; tempA = tempA.next; &#125;else&#123; tempA = headB; &#125; if(tempB!=null)&#123; tempB = tempB.next; &#125;else&#123; tempB = headA; &#125; &#125; return tempA; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-128-最长连续序列]]></title>
    <url>%2F2020%2F07%2F11%2FLeetCode-128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[LeetCode-128-最长连续序列给定一个未排序的整数数组，找出最长连续序列的长度。 要求算法的时间复杂度为 O(n)。 示例1： 123输入: [100, 4, 200, 1, 3, 2]输出: 4解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。 解题思路方法1、哈希表： 题解转自LeetCode：https://leetcode-cn.com/problems/longest-consecutive-sequence/solution/zui-chang-lian-xu-xu-lie-by-leetcode-solution/ 我们考虑枚举数组中的每个数 x，考虑以其为起点，不断尝试匹配 x+1, x+2,⋯ 是否存在，假设最长匹配到了 x+y，那么以 x为起点的最长连续序列即为 x, x+1, x+2, ⋯,x+y，其长度为 y+1，我们不断枚举并更新答案即可。 对于匹配的过程，暴力的方法是 O(n)遍历数组去看是否存在这个数，但其实更高效的方法是用一个哈希表存储数组中的数，这样查看一个数是否存在即能优化至 O(1) 的时间复杂度。 仅仅是这样我们的算法时间复杂度最坏情况下还是会达到 O(n^2)（即外层需要枚举 O(n)个数，内层需要暴力匹配 O(n)次），无法满足题目的要求。但仔细分析这个过程，我们会发现其中执行了很多不必要的枚举，如果已知有一个 x, x+1, x+2, ⋯,x+y 的连续序列，而我们却重新从 x+1，x+2 或者是 x+y处开始尝试匹配，那么得到的结果肯定不会优于枚举 x 为起点的答案，因此我们在外层循环的时候碰到这种情况跳过即可。 那么怎么判断是否跳过呢？由于我们要枚举的数 x 一定是在数组中不存在前驱数 x-1 的，不然按照上面的分析我们会从 x-1 开始尝试匹配，因此我们每次在哈希表中检查是否存在 x-1即能判断是否需要跳过了。 Java代码123456789101112131415161718192021class Solution &#123; public int longestConsecutive(int[] nums) &#123; Set&lt;Integer&gt; num_set = new HashSet&lt;Integer&gt;(); for(int num:nums)&#123; num_set.add(num); &#125; int longest = 0; for(int num: num_set)&#123; if(!num_set.contains(num-1))&#123; int curNum = num; int curStreak = 1; while(num_set.contains(curNum+1))&#123; curStreak+=1; curNum+=1; &#125; longest = Math.max(curStreak,longest); &#125; &#125; return longest; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-226-翻转二叉树]]></title>
    <url>%2F2020%2F07%2F10%2FLeetCode-226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[LeetCode-226-翻转二叉树翻转一棵二叉树。 示例1： 输入： 12345 4 / \ 2 7 / \ / \1 3 6 9 输出： 12345 4 / \ 7 2 / \ / \9 6 3 1 备注:这个问题是受到 Max Howell 的 原问题 启发的 ： 谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。 解题思路方法1、DFS递归： 当根节点不为空的时候，交换他的左右子节点 当左子节点不为空时，继续往左子树递归遍历，进行下一层的交换 当右子节点不为空时，继续往右子树递归遍历，进行下一层的交换 方法2、迭代： 这个方法的思路就是，我们需要交换树中所有节点的左孩子和右孩子。 因此可以创一个队列来存储所有左孩子和右孩子还没有被交换过的节点。 开始的时候，只有根节点在这个队列里面。 只要这个队列不空，就一直从队列中出队节点，然后互换这个节点的左右孩子节点，接着再把孩子节点入队到队列，对于其中的空节点不需要加入队列。 最终队列一定会空，这时候所有节点的孩子节点都被互换过了，直接返回最初的根节点就可以了。 Java代码12345678910111213141516171819202122232425/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if(root==null) return root; if(root.left==null&amp;&amp;root.right==null) return root; TreeNode temp = root.left; root.left = root.right; root.right = temp; if(root.left!=null)&#123; invertTree(root.left); &#125; if(root.right!=null)&#123; invertTree(root.right); &#125; return root; &#125;&#125; Java代码212345678910111213141516171819202122232425/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if(root==null) return root; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty())&#123; TreeNode node = queue.poll(); TreeNode temp = node.left; node.left = node.right; node.right = temp; if(node.left!=null) queue.add(node.left); if(node.right!=null) queue.add(node.right); &#125; return root; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>树</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-33-搜索旋转排序数组]]></title>
    <url>%2F2020%2F07%2F10%2FLeetCode-33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[LeetCode-33-搜索旋转排序数组假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 示例1： 12输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4 示例2： 12输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1 解题思路方法1、双指针+根据规则的if-else： 这种方法应该是不符合本题的时间复杂度，但又不同于直接顺序遍历 用于铺垫二分查找解法。 根据旋转的规则，旋转点可能出现在数组中间，也可能出现旋转后数组不变的情况 假设旋转点出现在数组中间： 数组分成2部分有序，可以通过判断target和low、high之间的大小来确定target可能在哪一半数组中 其次，定义旋转边界，左半边数组升序排列，右半边数组从右向左降序排列 如果从low开始向右遍历，则满足nums[i]-num[i-1]&gt;0，当小于0时，则为旋转边界。如果到达边界都没有找到，说明查找的数不在数组中，此时返回-1，如果查找过程中找到target则返回数组下标。 从high开始向左遍历情况类似。 假设旋转点出现在数组之外： 则数组直接有序，这时候线性遍历或者进行二分查找均可，这里简单写了线性遍历 特例判断： 当target等于low和high的时候，返回对应下标 当target&gt;low时，进行左子数组遍历 当target&lt;high时，进行右子数组遍历 如果数组为空或者数组长度为0，返回-1 如果数组长度为1，比较数组值是否等于target，等于则返回该值，不等于则返回-1 方法2、二分查找： 在上面一个方法中，虽然划分了数组，但比较过程仍然只是线性遍历 我们可以进一步利用二分查找来进行搜索 如果中间的数小于最右边的数，则右半段是有序的 如果中间的数大于最右边的数，则左半段是有序的 我们只需要在有序的半段里用首尾两个数来判断目标值是否在这个区域中，就可以确定保留哪半边数组 Java代码1 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int search(int[] nums, int target) &#123; int len = nums.length; if(nums==null||len==0) return -1; int low = nums[0]; int high = nums[len-1]; if(target==low) return 0; if(target==high) return len-1; if(len==1) return nums[0]==target?nums[0]:-1; if(low&lt;high)&#123; for(int i=0;i&lt;len-1;i++)&#123; if(target==nums[i]) return i; &#125; &#125;else&#123; if(target&gt;low)&#123; for(int i=1;i&lt;len-1;i++)&#123; if(target==nums[i]) return i; if(nums[i]-nums[i-1]&gt;0)&#123; continue; &#125;else&#123; break; &#125; &#125; &#125;else if(target&lt;high)&#123; for(int i=len-1;i&gt;=0;i--)&#123; if(target==nums[i]) return i; if(nums[i]-nums[i-1]&gt;0)&#123; continue; &#125;else&#123; break; &#125; &#125; &#125; &#125; return -1; &#125;&#125; Java代码2123456789101112131415161718192021222324class Solution &#123; public int search(int[] nums, int target) &#123; int len = nums.length; int left = 0, right = len-1; while(left&lt;=right)&#123; int mid = (left+right)/2; if(nums[mid]==target) return mid; else if(nums[mid]&lt;nums[right])&#123; // 如果中间数小于右边，说明右边有序 if(nums[mid]&lt;target &amp;&amp; target&lt;=nums[right]) left = mid+1; // 缩小左边查找区间 else right = mid-1; &#125; else&#123;// 如果中间数大于右边，说明左边有序 if(nums[left]&lt;=target &amp;&amp; target&lt;nums[mid]) right = mid-1; // 缩小右边查找区间 else left = mid+1; &#125; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-538-把二叉搜索树转换为累加树]]></title>
    <url>%2F2020%2F07%2F09%2FLeetCode-538-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91%2F</url>
    <content type="text"><![CDATA[LeetCode-538-把二叉搜索树转换为累加树给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。 示例1： 123456789输入: 原始二叉搜索树: 5 / \ 2 13输出: 转换为累加树: 18 / \ 20 13 解题思路方法1、递归： 二叉搜索树是，当树中根节点不为空的时候，其左子树上所有节点的值均小于它的根节点的值。若它的右子树不空，则右子树上所有结点的值均大于它的根节点的值。 根据这一特点，累加树就可以通过反向的中序遍历得到，即先遍历右根左的顺序进行遍历，同时进行节点值累加，满足当一个节点的值是由所有大于它的节点值累加得到的这一定义。 当root不为空时，进行右子树递归，并累加节点值，之后进行左子树递归，最后返回root节点 方法2、迭代： 使用一个Stack来存储节点，利用反序的中序遍历进行节点值累加，实现方法和中序遍历的迭代方式类似。 Java代码1123456789101112131415161718192021/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; private int sum = 0; public TreeNode convertBST(TreeNode root) &#123; if(root!=null)&#123; convertBST(root.right); sum+= root.val; root.val = sum; convertBST(root.left); &#125; return root; &#125;&#125; Java代码2123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode convertBST(TreeNode root) &#123; int sum = 0; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode temp = root; while(temp!=null||!stack.isEmpty())&#123; while(temp!=null)&#123; stack.push(temp); temp = temp.right; &#125; temp = stack.pop(); sum +=temp.val; temp.val = sum; temp = temp.left; &#125; return root; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-199-二叉树的右视图]]></title>
    <url>%2F2020%2F07%2F08%2FLeetCode-199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[LeetCode-199-二叉树的右视图给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 示例1： 123456789输入: [1,2,3,null,5,null,4]输出: [1, 3, 4]解释: 1 &lt;--- / \2 3 &lt;--- \ \ 5 4 &lt;--- 解题思路方法1、Queue迭代+BFS： 按照层序遍历的思想，利用一个Queue进行迭代，在层序遍历的时候优先加入右节点，按根右左的顺序遍历二叉树 从右边可见的节点始终是层序遍历时队列中第一个弹出的节点，即i==0时，将节点加入到res中 方法2、DFS： 我们对树进行深度优先搜索，在搜索过程中，我们总是先访问右子树。那么对于每一层来说，我们在这层见到的第一个结点一定是最右边的结点。这样一来，只需要存储每个深度访问的第一个节点即可 Java代码1123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; rightSideView(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root==null) return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0;i&lt;size;i++)&#123; if(i==0)&#123; res.add(queue.peek().val); &#125; TreeNode temp = queue.poll(); if(temp.right!=null)&#123; queue.add(temp.right); &#125; if(temp.left!=null)&#123; queue.add(temp.left); &#125; &#125; &#125; return res; &#125;&#125; Java代码212345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; rightSideView(TreeNode root) &#123; if(root==null) return res; DFS(root,0); return res; &#125; public void DFS(TreeNode root,int depth)&#123; if(root==null) return; // 如果当前节点所在深度还没有出现在res里 // 说明在该深度下当前节点是第一个被访问的节点，因此将当前节点加入res中。 if(depth&gt;=res.size())&#123; res.add(root.val); &#125; DFS(root.right,depth+1); DFS(root.left,depth+1); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>树</tag>
        <tag>Medium</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-309-最佳买卖股票时机含冷冻期]]></title>
    <url>%2F2020%2F07%2F08%2FLeetCode-309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[LeetCode-309-最佳买卖股票时机含冷冻期给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 示例1： 123输入: [1,2,3,0,2]输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出] 解题思路详见链接https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-lab/ Java代码1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public int maxProfit(int[] prices) &#123; if(prices == null || prices.length == 0)&#123; return 0; &#125; //状态转移图： // 持股 不持股 // ↙-----、 卖出 ↙-----、 // 持股-----↑--------→不持股---↑ // | // |卖 // |出 // ↓ // 冷冻期(期间什么都不能干) // int[][] dp = new int[prices.length][3]; //dp[i][x]第i天进入x状态（0.不持股，1.持股，2.冷冻期） //不持股 dp[0][0] = 0; //持股 dp[0][1] = -prices[0]; //冷冻期 dp[0][2] = 0; for(int i = 1;i &lt; prices.length;i++)&#123; //第i天不持股可以从两种状态转移而来，1.第i-1天不持股，今天仍不买股票，保持不持股状态。2.冷冻期结束了，但是今天不买股票。 dp[i][0] = Math.max(dp[i-1][0], dp[i-1][2]); //第i天持股可从两种状态转移而来，1.第i-1天不持股(包含昨天是冷冻期或者昨天本身就不持股)，今天买股票。2.第i-1天持股，今天不卖出，保持持股状态。 dp[i][1] = Math.max(dp[i - 1][0] - prices[i], dp[i - 1][1]); //只有第i天卖出了股票，第i天才能进入冷冻期。 dp[i][2] = dp[i-1][1] + prices[i]; &#125; //只有最后一天不持股（不持股状态）或者前一天已经卖掉了（今天为冷冻期）这两种情况手里是拿着钱的，最大值在二者中产生。 return Math.max(dp[prices.length - 1][0], dp[prices.length - 1][2]); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList的扩容机制]]></title>
    <url>%2F2020%2F07%2F07%2FArrayList%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[ArrayList的扩容机制ArrayList是List接口的实现类，能够根据需要动态增长数组，本文通过分析源码，总结ArrayList的扩容机制 ArrayList构造函数在ArrayList中有3种方法进行初始化，构造方法源码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576 /** * Default initial capacity. 默认初始容量大小 */ private static final int DEFAULT_CAPACITY = 10; /** * Shared empty array instance used for empty instances. */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; /** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; /** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */ transient Object[] elementData; // non-private to simplify nested class access /** * The size of the ArrayList (the number of elements it contains). * * @serial */ private int size;/** * 带初始容量参数的构造方法，容量由用户指定 */ public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; // 初始容量大于0 // 创建initialCapacity大小的数组 this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; // 初始容量等于0 // 创建空数组 this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; // 初始容量小于0，抛出异常 throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125; &#125; /** * Constructs an empty list with an initial capacity of ten. * 默认构造函数，使用初始容量10构造一个空列表(无参数构造) */ public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; /** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * 构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回 * 如果指定的集合为null，抛出空指针异常 * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */ public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; 在无参构造方法中，创建ArrayList实际上是初始化一个空数组。 EMPTY_ELEMENTDATA常量数组为空实例共享一个空数组 DEFAULTCAPACITY_EMPTY_ELEMENTDATA常量数组，与EMPTY_ELEMENTDATA不同，用于默认大小的空实例的共享空数组实例。将其与EMPTY_ELEMENTDATA区分开来，以便知道添加第一个元素时需要扩容多少。当真正对数组进行添加元素操作的时候，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为10 1.Add方法12345678910111213/** * Appends the specified element to the end of this list. * 将指定的元素追加到此列表的末尾 * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;) */public boolean add(E e) &#123;// 添加元素之前，先调用ensureCapacityInternal方法 ensureCapacityInternal(size + 1); // Increments modCount!! // 在ArrayList添加元素的实质，相当于为数组赋值 elementData[size++] = e; return true;&#125; 2.ensureCapacityInternal()方法在add方法中，调用了ensureCapacityInternal(size + 1)，ensureCapacityInternal源码如下 123private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125; 在源码中，又调用了calculateCapacity和ensureExplicitCapacity方法 3.calculateCapacity()方法calculateCapacity传入一个数组和最小扩容量，计算扩容量的值 1234567private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; // 获取默认的容量和传入参数的较大值 return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity;&#125; 当要add第一个元素时，数组的size为0，传入的参数为size+1，所以minCapacity为1，在Math.max方法比较后，minCapacity变为10，之后将minCapacity返回，执行ensureExplicitCapacity()方法 4.ensureExplicitCapacity()方法当第1次add的时候，从上一个返回接回10，作为minCapacity的初始值，由于minCapacity-elementData.length &gt; 0所以会进入到grow(minCapacity)方法 此后，当添加2，3，……，10个元素时，由于数组容量足够大，都不会进行grow方法扩容 而当添加第11个元素时，minCapacity - elementData.length &gt; 0成立，再次进行扩容 123456789// 判断是否需要扩容private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) // 调用grow方法进行扩容，调用此方法代表已经开始扩容了 grow(minCapacity);&#125; 5.grow()方法123456789101112131415161718192021222324252627// 要分配的最大数组大小private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;/** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * 增加容量，以确保它至少可以容纳最小容量参数指定的元素数量。 * ArrayList扩容的核心方法 * @param minCapacity the desired minimum capacity */private void grow(int minCapacity) &#123; // overflow-conscious code // oldCapacity为旧容量，newCapacity为新容量 int oldCapacity = elementData.length; // 将oldCapacity右移一位，其效果相当于oldCapacity/2 // 位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; // 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE // 如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8` if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)，所以ArrayList每次扩容之后容量都会变为原来的1.5倍左右(oldCapacity为偶数就是1.5倍，否则是1.5倍左右)，奇偶不同，比如：10+10/2 = 15，33+33/2 = 49。如果是奇数的话会丢掉小数。 我们再来通过例子探究一下grow() 方法 ： 当add第1个元素时，oldCapacity 为0，经比较后第一个if判断成立，newCapacity = minCapacity(为10)。但是第二个if判断不会成立，即newCapacity 不比 MAX_ARRAY_SIZE大，则不会进入 hugeCapacity 方法。数组容量为10，add方法中 return true,size增为1。 当add第11个元素进入grow方法时，newCapacity为15，比minCapacity（为11）大，第一个if判断不成立。新容量没有大于数组最大size，不会进入hugeCapacity方法。数组容量扩为15，add方法中return true,size增为11。 以此类推······ 6.hugeCapacity()方法从上面grow()方法源码中能够知道，如果新容量大于最大容量MAX_ARRAY_SIZE，进入(执行)hugeCapacity()方法来比较minCapacity和MAX_ARRAY_SIZE，如果minCapacity大于最大容量，则新容量则为Integer.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 Integer.MAX_VALUE - 8。 1234567private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 通过以上6个方法，即可实现ArrayList的完整扩容流程 其他方法(ensureCapacity方法)ArrayList源码中，还有一个ensureCapacity方法，这个方法在ArrayList内部没有被调用过，所以显然是提供给用户调用的，那么这个方法有什么作用呢？ 12345678910111213141516171819/** * Increases the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance, if * necessary, to ensure that it can hold at least the number of elements * specified by the minimum capacity argument. * 如有必要，增加此ArrayList实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数 * @param minCapacity the desired minimum capacity 所需的最小容量 */public void ensureCapacity(int minCapacity) &#123; int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It's already // supposed to be at default size. : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125;&#125; 最好在add大量元素之前用ensureCapacity方法，以减少增量重新分配的次数 代码示例 12345678910111213public class EnsureCapacityTest &#123; public static void main(String[] args) &#123; ArrayList&lt;Object&gt; list = new ArrayList&lt;Object&gt;(); final int N = 10000000; long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; N; i++) &#123; list.add(i); &#125; long endTime = System.currentTimeMillis(); System.out.println("使用ensureCapacity方法前："+(endTime - startTime)); &#125;&#125; 运行结果： 1使用ensureCapacity方法前：2158 使用ensureCapacity后 1234567891011121314public class EnsureCapacityTest &#123; public static void main(String[] args) &#123; ArrayList&lt;Object&gt; list = new ArrayList&lt;Object&gt;(); final int N = 10000000; list = new ArrayList&lt;Object&gt;(); long startTime1 = System.currentTimeMillis(); list.ensureCapacity(N); for (int i = 0; i &lt; N; i++) &#123; list.add(i); &#125; long endTime1 = System.currentTimeMillis(); System.out.println("使用ensureCapacity方法后："+(endTime1 - startTime1)); &#125;&#125; 运行结果： 1使用ensureCapacity方法后：1773 通过运行结果，我们可以看出向 ArrayList 添加大量元素之前最好先使用ensureCapacity 方法，以减少增量重新分配的次数。 参考资料： JavaGuide：https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList-Grow.md]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-55-跳跃游戏]]></title>
    <url>%2F2020%2F07%2F06%2FLeetCode-55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[LeetCode-55-跳跃游戏给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。 示例1： 123输入: [2,3,1,1,4]输出: true解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。 示例2： 123输入: [3,2,1,0,4]输出: false解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。 解题思路方法1、贪心： 对于数组中任意的一个位置y，如何判断是否可达 根据题意，只要存在一个位置x，它本身可达，并且它跳跃的最大长度为x+nums[x]，这个值&gt;=y，即x+nums[x]&gt;=y，那么位置y也可达 换句话说，对于每个可达的位置x，它使得x+1，x+2，……，x+nums[x]这些连续的位置都可以到达 于是我们可以动态记录最远可以到达的位置，对于每一个起跳点，更新对应的最远可以到达的位置 即把每个能起跳的点都试一次，使用max表示最远能够到达的点，超过max就不能跳了，直接进行返回 Java代码12345678910111213class Solution &#123; public boolean canJump(int[] nums) &#123; boolean falg = true; if(nums.length&lt;2) return falg; int max = 0; for(int i=0;i&lt;nums.length;i++)&#123; if(i&gt;max) falg = false; max = Math.max(max,i+nums[i]); &#125; return falg; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-617-合并二叉树]]></title>
    <url>%2F2020%2F07%2F06%2FLeetCode-617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[LeetCode-617-合并二叉树给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。 你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。 示例1： 1234567891011121314输入: Tree 1 Tree 2 1 2 / \ / \ 3 2 1 3 / \ \ 5 4 7 输出: 合并后的树: 3 / \ 4 5 / \ \ 5 4 7 注意: 合并必须从两个树的根节点开始。 解题思路方法1、递归： 合并两个树可以按照前序遍历的方式进行合并 当节点t1为空时，返回t2，当t2为空时，返回t1 每次合并需要将对应的节点值相加 递归进行左子树和右子树的构建即可 方法2、迭代： 用一个stack存储两棵树的节点，将树的根节点t1,t2放入stack中，当stack不为空的时候 当任意一棵树的节点为空的时候，直接跳过 当两者不为空时，进行节点值相加，当前两个节点判断完毕，之后进行左子节点和右子节点的判断 当左子节点/右子节点为空时，说明该位置没有左/右节点，直接拼接左右子树的节点 当左子节点/右子节点不为空时，将两棵树的左节点或者右节点都添加进stack中 最后返回t1根节点即可 Java代码12345678910111213141516171819/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode mergeTrees(TreeNode t1, TreeNode t2) &#123; if(t1==null) return t2; if(t2==null) return t1; t1.val+=t2.val; t1.left = mergeTrees(t1.left,t2.left); t1.right = mergeTrees(t1.right,t2.right); return t1; &#125;&#125; Java代码21234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode mergeTrees(TreeNode t1, TreeNode t2) &#123; if(t1==null) return t2; if(t2==null) return t1; Stack&lt;TreeNode[]&gt; stack = new Stack&lt;&gt;(); stack.push(new TreeNode[] &#123;t1, t2&#125;); while(!stack.isEmpty())&#123; TreeNode[] temp = stack.pop(); if(temp[0]==null||temp[1]==null)&#123; continue; &#125; temp[0].val+=temp[1].val; if(temp[0].left==null)&#123; temp[0].left = temp[1].left; &#125;else&#123; stack.push(new TreeNode[]&#123;temp[0].left,temp[1].left&#125;); &#125; if(temp[0].right==null)&#123; temp[0].right = temp[1].right; &#125;else&#123; stack.push(new TreeNode[]&#123;temp[0].right,temp[1].right&#125;); &#125; &#125; return t1; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-39-组合总数]]></title>
    <url>%2F2020%2F07%2F05%2FLeetCode-39-%E7%BB%84%E5%90%88%E6%80%BB%E6%95%B0%2F</url>
    <content type="text"><![CDATA[LeetCode-39-组合总数给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。 示例1： 123456输入: candidates = [2,3,6,7], target = 7,所求解集为:[ [7], [2,2,3]] 示例2： 1234567输入: candidates = [2,3,5], target = 8,所求解集为:[ [2,2,2,2], [2,3,3], [3,5]] 解题思路方法1、DFS+回溯： 排列组合的问题，一般也是全排列问题 这类问题可以使用回溯法+递归解决 基本思路： 当target=7时，为根节点，进行分支选择 当减到0或者负数的时候，就是到了叶子节点，进行返回 当减到0时，进行结果集的保存，从根节点到叶子节点(0)的路径就是答案其中一个组合 刚开始一定要在纸上画一棵递归树，写出示例的整个树结构，在明白最基本的算法怎么实现之后，根据题意需要考虑结果不重复的问题，于是就需要对这个树进行剪枝操作 比如示例1中，可能的路径有[[2,2,3],[2,3,2],[3,2,2],[7]] 而答案中只有[[7],[2,2,3]]，显然，重复的原因是在较深层的节点值考虑了之前选择过的元素 剪枝流程： 在搜索的时候，需要设置起点的下标start，避免选择之前选择过的节点 Java代码1234567891011121314151617181920212223242526class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); int len = candidates.length; if(len==0) return res; List&lt;Integer&gt; arr = new ArrayList&lt;&gt;(); Arrays.sort(candidates); backtrack(candidates,target,res,0,arr); return res; &#125; public void backtrack(int[] candidates,int target,List&lt;List&lt;Integer&gt;&gt; res,int i,List&lt;Integer&gt; tmp_list)&#123; if(target&lt;0) return; if(target==0)&#123; res.add(new ArrayList&lt;&gt;(tmp_list)); return; &#125; // 如果start从0开始，则会遍历全部数组，选择重复的，记录start避免重复 for(int start=i;start&lt;candidates.length;start++)&#123; if(target&lt;0) break; tmp_list.add(candidates[start]); backtrack(candidates,target-candidates[start],res,start,tmp_list); tmp_list.remove(tmp_list.size()-1); &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-31-下一个排列]]></title>
    <url>%2F2020%2F07%2F05%2FLeetCode-31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[LeetCode-31-下一个排列实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须原地修改，只允许使用额外常数空间。 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 解题思路思路出处 推导： 如何得到这样的排列顺序？这是本文的重点。我们可以这样来分析： 我们希望下一个数比当前数大，这样才满足“下一个排列”的定义。因此只需要将后面的「大数」与前面的「小数」交换，就能得到一个更大的数。比如 123456，将 5 和 6 交换就能得到一个更大的数 123465。 我们还希望下一个数增加的幅度尽可能的小，这样才满足“下一个排列与当前排列紧邻“的要求。为了满足这个要求，我们需要： 在尽可能靠右的低位进行交换，需要从后向前查找 将一个 尽可能小的「大数」 与前面的「小数」交换。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换 将「大数」换到前面后，需要将「大数」后面的所有数重置为升序，升序排列就是最小的排列。以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。显然 123546 比 123564 更小，123546 就是 123465 的下一个排列 以上就是求“下一个排列”的分析过程。 算法流程： 标准的“下一个排列”算法可以描述为： 从后向前查找第一个相邻升序的元素对 (i,j)，满足 A[i] &lt; A[j]。此时 [j,end) 必然是降序 在 [j,end) 从后向前查找第一个满足 A[i] &lt; A[k] 的 k。A[i]、A[k] 分别就是上文所说的「小数」、「大数」 将 A[i] 与 A[k] 交换 可以断定这时 [j,end) 必然是降序，逆置 [j,end)，使其升序 如果在步骤 1 找不到符合的相邻元素对，说明当前 [begin,end) 为一个降序顺序，则直接跳到步骤 4 Java代码123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public void nextPermutation(int[] nums) &#123; int len = nums.length; if (len &lt; 2) return; int i = len - 2; int j = len - 1; int k = len - 1; // 从后向前找第一个正序，这里最后i指向的是逆序起始位置 while (i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[j]) &#123; i--; j--; &#125; if (i &gt;= 0) &#123; // 从后向前找第一个比nums[j]大的元素，进行交换 while (nums[i] &gt;= nums[k]) &#123; k--; &#125; swap(nums, i, k); &#125; // 翻转交换点后的数组，使后面的数组升序，保证整个数组是下一个最大数组 reverse(nums, j, len - 1); &#125; public void swap(int[] nums, int i, int j) &#123; int temp = nums[j]; nums[j] = nums[i]; nums[i] = temp; &#125; public void reverse(int[] nums, int start, int end) &#123; while (start &lt; end) &#123; int temp = nums[end]; nums[end] = nums[start]; nums[start] = temp; start++; end--; &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见排序算法总结]]></title>
    <url>%2F2020%2F07%2F02%2F%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[常见排序算法总结总结了常用的排序算法，以及对应分析 相关链接： LeetCode-冒泡排序 LeetCode-选择排序 LeetCode-插入排序 LeetCode-快速排序 LeetCode-归并排序 LeetCode-希尔排序 LeetCode-桶排序 LeetCode-基数排序 LeetCode-堆排序 总结各种排序算法的时间复杂度和空间复杂度，以及其对应的稳定性 算法种类 最好情况 平均时间复杂度 最坏情况 空间复杂度 是否稳定 冒泡排序 O(n) O(n^2) O(n^2) O(1) 是 选择排序 O(n^2) O(n^2) O(n^2) O(1) 是 插入排序 O(n) O(n^2) O(n^2) O(1) 是 快速排序 O(nlogn) O(nlogn) O(n^2) O(logn) 否 归并排序 O(nlogn) O(nlogn) O(nlogn) O(n) 是 希尔排序 O(n^1.3)-O(n^2) O(1) 否 桶排序 O(n) O(n*(log(n/m)+1)) O(n^2) O(n+m) 是 基数排序 O(d(n+r)) O(d(n+r)) O(d(n+r)) O(r) 是 堆排序 O(nlogn) O(nlogn) O(nlogn) O(1) 否]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-基数排序]]></title>
    <url>%2F2020%2F07%2F01%2FLeetCode-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[LeetCode-基数排序基数排序算法回顾 示例1 12输入: nums = [1, 4, 3, 100, 323, 53, 13, 559230, 123, 20, 43, 12]输出: [1,3,4,12,13,20,43,53,100,123,323,559230] 解题思路​ 基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数； ​ 基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。基数排序基于分别排序，分别收集，所以是稳定的。 ​ 时间复杂度：设待排序列为n个记录，d个关键码，关键码的取值范围为radix，则进行链式基数排序的时间复杂度为O(d(n+radix))，其中，一趟分配时间复杂度为O(n)，一趟收集时间复杂度为O(radix)，共进行d趟分配和收集。 ​ 基数排序是稳定的排序算法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.*;public class RadixSort &#123; public static void main(String[] args) &#123; int[] array = &#123;1, 4, 3, 100, 323, 53, 13, 559230, 123, 20, 43, 12&#125;; sort(array); for (Integer i : array) &#123; System.out.print(i+" "); &#125; &#125; // 基数排序，注意这里只能排序正整数 public static void sort(int[] array) &#123; // 找到数组中最大数max，并计算它的位数maxDig int max = array[0]; for (int maxTemp : array) &#123; max = Math.max(max, maxTemp); &#125; int maxDig = String.valueOf(max).length(); // 创建从0-9的基数数据集 Map&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; map.put(i, new ArrayList&lt;Integer&gt;()); &#125; // 从低位baseDig开始到高位maxDig进行指定位的基数排序 int baseDig = 1; while (baseDig &lt;= maxDig) &#123; // 第一阶段，遍历目标数组，将数组元素放入指定的基数数据集中 for (int temp : array) &#123; String strVal = String.valueOf(temp); // 获取元素baseDig位的数字，放入相对的基数数据集中 // 如果不存在，将该元素放入0基数数据集中 Integer key = null; if (strVal.length() &lt; baseDig) &#123; key = 0; &#125; else &#123; // 获取指定位上的字符，并转化成目标基数key char bitNum = strVal.charAt(strVal.length() - baseDig); key = Integer.valueOf(String.valueOf(bitNum)); &#125; map.get(key).add(temp); &#125; int j = 0; // 第二阶段，将0-9基数数据集中的数据，放回到数组中 // 表示当前baseDig位的基数排序完成 for (int i = 0; i &lt; 10; i++) &#123; Iterator&lt;Integer&gt; it = map.get(i).iterator(); while (it.hasNext()) &#123; array[j++] = it.next(); &#125; map.get(i).clear(); &#125; baseDig++; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-堆排序]]></title>
    <url>%2F2020%2F07%2F01%2FLeetCode-%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[LeetCode-堆排序堆排序算法回顾 示例1 12输入: nums = [1, 4, 3, 100, 323, 53, 13, 559230, 123, 20, 43, 12]输出: [1,3,4,12,13,20,43,53,100,123,323,559230] 解题思路一个不错的堆排序讲解，出处在这 了解堆排序首先需要了解堆 堆是一种具有如下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆 大顶堆满足：arr[i]&gt;=arr[2i+1]&amp;&amp;arr[i]&gt;=arr[2i+2] 小顶堆满足：arr[i]&lt;=arr[2i+1]&amp;&amp;arr[i]&lt;=arr[2i+2] 堆排序的基本思想是： 将待排序序列构造成一个大顶堆/小顶堆，此时，整个序列的最大值就是堆顶的根节点。 将其与末尾元素进行交换，此时末尾就为最大/小值。 然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。 如此反复执行，便能得到一个有序序列了 堆排序是一种选择排序，整体主要由构建初始堆+交换堆顶元素和末尾元素并重建堆两部分组成。 其中构建初始堆的复杂度为O(n)，在交换并重建堆的过程中，需交换n-1次，而重建堆的过程中，根据完全二叉树的性质 [log2(n-1),log2(n-2),….,1]逐步递减，所以时间复杂度近似为O(nlogn)，堆排序是一种不稳定的排序算法 Java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445public class HeapSort &#123; public static void main(String[] args) &#123; int[] array = &#123;1, 4, 3, 100, 323, 53, 13, 559230, 123, 20, 43, 12&#125;; sort(array); for (Integer i : array) &#123; System.out.print(i + " "); &#125; &#125; public static void sort(int[] arr) &#123; // 构建大顶堆 for (int i = arr.length / 2 - 1; i &gt;= 0; i--) &#123; //从第一个非叶子节点从下至上，从右至左调整结构 adjustHeap(arr, i, arr.length); &#125; // 调整堆结构+交换堆顶元素与末尾元素 for (int j = arr.length - 1; j &gt; 0; j--) &#123; swap(arr, 0, j);// 将堆顶元素和末尾元素进行交换 adjustHeap(arr, 0, j);// 重新对堆进行调整 &#125; &#125; // 调整大顶堆(仅是调整过程，建立在大顶堆已构建的基础上) private static void adjustHeap(int[] arr, int i, int length) &#123; int temp = arr[i];// 先取出当前元素i for (int k = i * 2 + 1; k &lt; length; k = k * 2 + 1) &#123;// 从i节点的左子节点开始，也就是2i+1处开始 if (k + 1 &lt; length &amp;&amp; arr[k] &lt; arr[k + 1]) &#123;// 如果左子节点小于右子节点，k指向右子节点 k++; &#125; if (arr[k] &gt; temp) &#123;// 如果子节点大于父节点，将子节点值赋给父节点(不用进行交换) arr[i] = arr[k]; i = k; &#125; else &#123; break; &#125; &#125; arr[i] = temp;// 将temp值放到最终的位置 &#125; private static void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-桶排序]]></title>
    <url>%2F2020%2F07%2F01%2FLeetCode-%E6%A1%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[LeetCode-桶排序桶排序算法回顾 示例1 12输入: nums = [4,0,1,2,0,5]输出: [0,0,1,2,4,5] 解题思路桶排序(Bucket Sort)的原理很简单，它是将数组分到有限数量的桶子里。是一种非比较的排序方法 在了解桶排序之前，先了解计数排序 其中计数排序思想如下： 假设待排序的数组a中共有N个整数，并且已知数组a中数据的范围[0, MAX)。在桶排序时，创建容量为MAX的桶数组r，并将桶数组元素都初始化为0；将容量为MAX的桶数组中的每一个单元都看作一个”桶”。在排序时，逐个遍历数组a，将数组a的值，作为”桶数组r”的下标。当a中数据被读取时，就将桶的值加1。例如，读取到数组a[3]=5，则将r[5]的值+1。 Java代码1123456789101112131415161718192021222324252627282930public class BucketSort2 &#123; public static void main(String[] args) &#123; int[] arr = &#123;4, 0, 1, 2, 0, 10&#125;; bucketSort2(arr); for (Integer i : arr) &#123; System.out.print(i); &#125; &#125; public static void bucketSort2(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; int max = Integer.MIN_VALUE; for (int i = 0; i &lt; arr.length; i++) &#123; max = Math.max(max, arr[i]); &#125; int[] bucket = new int[max + 1]; for (int i = 0; i &lt; arr.length; i++) &#123; bucket[arr[i]]++; &#125; int index = 0; for (int j = 0; j &lt; bucket.length; j++) &#123; while (bucket[j]-- &gt; 0) &#123; arr[index++] = j; &#125; &#125; &#125;&#125; 桶排序可以看做是计数排序的扩展，在计数排序中，每个桶只存储相同的元素 而桶排序中每个桶存储一定范围的元素，通过映射函数，将待排序数组中的元素存储到各个对应的桶中 之后对每个桶中的元素进行排序 最后将非空桶中的元素逐个放入原序列中 桶排序需要尽量保证元素分散均匀，否则当所有数据集中在同一个桶中时，桶排序就会失效 桶排序的稳定性取决于桶内部使用的排序算法 Java代码2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.ArrayList;import java.util.Collections;public class BucketSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;4, 0, 1, 2, 0, 5&#125;; bucketSort(arr); for (Integer i : arr) &#123; System.out.print(i); &#125; &#125; public static void bucketSort(int[] arr) &#123; // 计算最大值与最小值 int max = Integer.MIN_VALUE; int min = Integer.MAX_VALUE; for (int i = 0; i &lt; arr.length; i++) &#123; max = Math.max(max, arr[i]); min = Math.min(min, arr[i]); &#125; // 计算桶的数量 int bucketNum = (max - min) / arr.length + 1; //保证每个桶存的区间范围平均，+1代表余数补1个桶 ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = new ArrayList&lt;&gt;(bucketNum); for (int i = 0; i &lt; bucketNum; i++) &#123; bucketArr.add(new ArrayList&lt;Integer&gt;()); &#125; // 将每个元素放入桶 for (int i = 0; i &lt; arr.length; i++) &#123; int num = (arr[i] - min) / (arr.length); //确定arr[i]存储在哪个桶 bucketArr.get(num).add(arr[i]); &#125; // 对每个桶进行排序 for (int i = 0; i &lt; bucketArr.size(); i++) &#123; Collections.sort(bucketArr.get(i)); // 内层排序算法可选择 &#125; // 将桶中的元素赋值到原序列 int index = 0; for (int i = 0; i &lt; bucketArr.size(); i++) &#123; for (int j = 0; j &lt; bucketArr.get(i).size(); j++) &#123; arr[index++] = bucketArr.get(i).get(j); &#125; &#125; &#125;&#125; 时间复杂度对于待排序序列大小为N，共分为M个桶，主要步骤有： N次循环，将每个元素装入对应的桶中 M次循环，对每个桶中的数据进行排序(平均每个桶有N/M个元素) 一般使用较为快速的排序算法，时间复杂度为O(nlogn)，实际的桶排序过程是以链表形式插入的 整个桶排序的时间复杂度为： O(N)+O(M*(N/M*log(N/M)))=O(N*(log(N/M)+1)) 当N=M时，复杂度为O(N) 空间复杂度O(N+M)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射获取类对象的三种方式]]></title>
    <url>%2F2020%2F06%2F29%2FJava%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Java反射获取类对象的三种方式简单了解Java获取类的3种方式 1、Class.forName(“全类名”) 将字节吗文件加载进内存，返回Class对象，多用于配指文件，将类名定义在配置文件中，便于利用java的反射机制生成类对象，加载类。 12//加载一个用户实体类UserBeanClass c1 = Class.forName(``"com.test.UserBean"``)； 2、类名.class 通过类名的属性class获取，多用于传递参数。 1Class c2 = UserBean.class; 3、对象.getClass() 多用于对象获取字节码的方式。 12UserBean user = new UserBean();Class c3 = user.getClass(); 对于三种方式获取到的类对象都指向堆内存中同一个地址，所以三种方式获取的类对象都是同一个，根据实际应用环境选择使用。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[海量数据TopK问题]]></title>
    <url>%2F2020%2F06%2F29%2F%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AETopK%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[海量数据TopK问题在大规模数据处理中，经常会遇到这类问题：在海量数据中找到出现频率/数值最大的前K个数 本文主要提供这类问题的基本解决方法 假设这样一个场景，一个问题阅读量越高，说明这个问题越有价值，越应该推送给用户 假设数据量有1亿，取Top100 最容易想到的方法是将全部数据进行排序，但如果数据量太大 ，这显然是不能接受的。 第二种方法为局部淘汰法，该方法与排序方法类似，用一个容器保存前K个数，然后将剩余的所有数字——与容器内的最小数字相比，如果所有后续的元素都比容器内的K个数还小，那么容器内这个K个数就是最大K个数。如果某一后续元素比容器内最小数字大，则删掉容器内最小元素，并将该元素插入容器，最后遍历完这1亿个数，得到的结果容器中保存的数即为最终结果了。此时的时间复杂度为O（n+m^2），其中m为容器的大小，即K。 第三种方法是分治法，将1亿个数据分成100份，每份100万个数据，找到每份数据中最大的100个(即每份数据的TopK)，最后在剩下的100*100个数据里面找出最大的100个。如果100万数据选择足够理想，那么可以过滤掉1亿数据里面99%的数据。100万个数据里面查找最大的100个数据的方法如下：用快速排序的方法，将数据分为2堆，如果大的那堆个数N大于100个，继续对大堆快速排序一次分成2堆，如果大的那堆个数N大于100个，继续对大堆快速排序一次分成2堆，如果大堆个数N小于100个，就在小的那堆里面快速排序一次，找第100-n大的数字；递归以上过程，就可以找到第100大的数。参考上面的找出第100大数字，就可以类似的方法找到前100大数字了。 第四种方法是Hash法。如果这1亿个数里面有很多重复的数，先通过Hash法，把这1亿个数字去重复，这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间，然后通过分治法或最小堆法查找最大的100个数。 第五种方法采用最小堆。首先读入前100个数来创建大小为100的最小堆，然后遍历后续的数字，并于堆顶（最小）数字进行比较。如果比最小的数小，则继续读取后续数字；如果比堆顶数字大，则替换堆顶元素并重新调整堆为最小堆。整个过程直至1亿个数全部遍历完为止。然后按照中序遍历的方式输出当前堆中的所有100个数字。建堆时间复杂度是O(m)，堆调整的时间复杂度是O(logm)，最终的时间复杂度=1次建堆的时间+n次堆调整的时间，所以该算法的时间复杂度为O(nlogm)，空间复杂度是100（常数）。 代码示例： 我们首先可以用HashMap去存储问题和阅读量的映射 1234567891011//伪代码String read;HashMap&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();while (fileStream.hasNext())&#123; url = read(); if (map.containsKey(read))&#123; map.put(read,map.get(read)+1); &#125;else&#123; map.put(read, 1); &#125;&#125; 之后， 我们使用长度为100的最小堆来找到最热的100条数据。 12345678910111213141516171819PriorityQueue&lt;Map.Entry&lt;String, Integer&gt;&gt; queue = new PriorityQueue&lt;Map.Entry&lt;String, Integer&gt;&gt;(100, new Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;()&#123; @Override public int compare(Entry&lt;String, Integer&gt; o1, Entry&lt;String, Integer&gt; o2) &#123; return o1.getValue() - o2.getValue(); &#125; &#125;); int k = 100;for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet())&#123; if (queue.size() &lt; k)&#123; queue.add(entry); &#125; else &#123; if (entry.getValue() &gt; queue.peek().getValue())&#123; queue.poll(); queue.add(entry); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>TopK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-希尔排序]]></title>
    <url>%2F2020%2F06%2F28%2FLeetCode-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[LeetCode-希尔排序希尔排序算法回顾 示例1 12输入: nums = [4,0,1,2,0,5]输出: [0,0,1,2,4,5] 解题思路希尔排序算法回顾 希尔排序是插入排序的一种又称”缩小增量排序” 它是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止 希尔排序是不稳定的排序算法，时间复杂度O(n^1.3)-O(n^2) Java代码12345678910111213141516171819202122232425262728293031323334public class ShellSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;4, 0, 1, 2, 0, 5&#125;; shellSort(arr); for (Integer i : arr) &#123; System.out.print(i); &#125; &#125; public static void shellSort(int[] arr) &#123; //当前正在比较的数字 int current; //初始增量 int gap = arr.length / 2; //gap==1的时候，数组已经有序 while (gap &gt; 0) &#123; for (int i = gap; i &lt; arr.length; i++) &#123;//内部就是一个插入排序 current = arr[i]; // 与current同组的前一个数字 int preIndex = i - gap; // 找到同组内比current小的数字 while (preIndex &gt;= 0 &amp;&amp; current &lt; arr[preIndex]) &#123; // 向后移动同组内已排好序的，大于current的数字 arr[preIndex + gap] = arr[preIndex]; preIndex -= gap; &#125; //插入current到相应的位置 arr[preIndex + gap] = current; &#125; //缩小增量 gap /= 2; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-插入排序]]></title>
    <url>%2F2020%2F06%2F28%2FLeetCode-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[LeetCode-插入排序插入排序算法回顾 示例1 12输入: nums = [4,0,1,2,0,5]输出: [0,0,1,2,4,5] 解题思路插入排序算法回顾 插入排序是一种简单直观的排序算法，其基本原理是通过构建有序序列，对未排序的数组，需要在已排序的序列中从后向前进行扫描，找到相应位置并插入。在从后向前扫描的过程中，需要反复把已排序的元素向后移动，为新元素提供插入的空间。 插入排序是稳定的排序算法，时间复杂度O(n^(1-2)) Java代码123456789101112131415161718192021public class InsertSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;4, 0, 1, 2, 0, 5&#125;; insertSort(arr, arr.length - 1); for (Integer i : arr) &#123; System.out.print(i); &#125; &#125; public static void insertSort(int arr[], int len) &#123; for (int i = 1; i &lt; len; i++) &#123; int temp = arr[i]; int left = i - 1; while (left &gt;= 0 &amp;&amp; arr[left] &gt; temp) &#123; arr[left + 1] = arr[left]; left--; &#125; arr[left + 1] = temp; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-选择排序]]></title>
    <url>%2F2020%2F06%2F28%2FLeetCode-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[LeetCode-选择排序选择排序算法回顾 示例1 12输入: nums = [4,0,1,2,0,5]输出: [0,0,1,2,4,5] 解题思路选择排序算法回顾 选择排序是指每一趟从待排序的数据元素中选出最大（或最小）的一个元素，顺序放在已排好序的数列的最后，直到全部待排序的数据元素排完。时间复杂度O(n^2)，是不稳定的排序算法。 Java代码12345678910111213141516171819202122232425public class SelectionSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;4, 0, 1, 2, 0, 5&#125;; selectionSort(arr); for (Integer i : arr) &#123; System.out.print(i); &#125; &#125; public static void selectionSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; int min = i; for (int j = min + 1; j &lt; arr.length; j++) &#123; if (arr[min] &gt; arr[j]) &#123; min = j; &#125; &#125; if (min != i) &#123; int temp = arr[min]; arr[min] = arr[i]; arr[i] = temp; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-冒泡排序]]></title>
    <url>%2F2020%2F06%2F28%2FLeetCode-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[LeetCode-冒泡排序冒泡排序算法回顾 示例1 12输入: nums = [4,0,1,2,0,5]输出: [0,0,1,2,4,5] 解题思路冒泡排序算法回顾，列表中两个相邻的数比较大小，如果前面的比后面的大，则交换位置 整个过程像冒泡一样，时间复杂度O(n^2)，是稳定的排序算法 Java代码123456789101112131415161718192021public class BubbleSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;4, 0, 1, 2, 0, 5&#125;; bubbleSort(arr, arr.length - 1); for (Integer i : arr) &#123; System.out.print(i); &#125; &#125; public static void bubbleSort(int[] arr, int len) &#123; for (int i = 0; i &lt; len; i++) &#123; for (int j = 0; j &lt; len - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j + 1]; arr[j + 1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程实现的几种方式]]></title>
    <url>%2F2020%2F06%2F28%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Java多线程实现的几种方式多进程是计算机中的一个重要概念，通常一个任务称为一个进程，比如浏览网页、播放音乐都是一个进程。 在进程内部可能还需要执行多个子任务，比如在使用word文档打字的时候，不仅要进行字符打印，同时还要进行字符统计、拼接检查等任务。 进程和线程的关系是：一个进程可以包含一个或者多个线程，但至少会包含一个线程。 在Java中，多线程的学习是非常重要的，本文主要概括Java多线程实现的几种方式。 Java中实现多进程的方式大概有3种： 实现Runnable接口，重写run方法 继承Thread类，重写run方法(Thread类本身也实现了Runnable接口) 实现Callable接口，重写call方法(带有返回值) 通过Runnable接口实现多线程12345678910111213public class Main &#123; public static void main(String[] args) &#123; Thread t = new Thread(new MyRunnable()); t.start(); // 启动新线程 &#125;&#125;class MyRunnable implements Runnable &#123; @Override public void run() &#123; System.out.println("start new thread!"); &#125;&#125; 实现Runnable接口的类，只定义了任务，自身不具有线程能力。需要通过Thread类的构造器来将任务驱动在一个线程中。 通过继承Thread类实现Thread类中已经实现了Runnable接口，所以可以直接继承Thread类，覆写run方法实现多线程 12345678910public class MyThread extends Thread&#123; public void run()&#123; System.out.println("New Thread : "+Thread.currentThread().getName()); &#125; public static void main (String []args)&#123; MyThread thread = new MyThread(); thread.start(); System.out.println("Main Thread : " + Thread.currentThread().getName()); &#125;&#125; 通过继承Callable接口实现相较于实现Runnable接口，Callable方法可以有返回值，并且可以抛出异常 执行Callable方法，需要FutureTask实现类的支持，用于接受运算的结果，FutureTask是Future接口的实现 需要覆写call方法，运行Callable任务可以拿到一个Future对象，Future表示异步计算的结果 通过Future对象可了解任务执行情况，可取消任务的执行，还可以获取任务执行的结果 12345678910111213141516171819202122232425262728293031323334353637import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class TestCallable &#123; public static void main(String[] args) &#123; ThreadDemo td = new ThreadDemo(); FutureTask&lt;Integer&gt; result = new FutureTask&lt;&gt;(td); new Thread(result).start(); try &#123; Integer sum = result.get(); System.out.println(sum); &#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class ThreadDemo implements Callable&lt;Integer&gt; &#123; @Override public Integer call() throws Exception &#123; int sum = 0; for (int i = 0; i &lt;= 100; i++) &#123; sum += i; &#125; return sum; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-22-括号生成]]></title>
    <url>%2F2020%2F06%2F26%2FLeetCode-22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90%2F</url>
    <content type="text"><![CDATA[LeetCode-22-括号生成数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 示例 1: 12345678输入：n = 3输出：[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot; ] 解题思路方法1、DFS： 深度优先遍历选择左括号和右括号，由于String拼接每次会产生一个新的String对象，所以传入的字符串不会影响其他结果，当左括号&gt;0时，左括号-1进入下一次拼接。只有当左右括号数目相等为n的时候，拼接的括号才是合法的，此时加入到最终结果，返回上一层。当左括号用完了的时候进行右括号的拼接 方法2、回溯： 回溯法基本上和DFS一致，只是这里的回溯需要手动回溯，由于String每次生成一个新的String对象耗时比较多，所以可以用StringBuilder，然而StringBuilder拼接的时候会把上一次的字符记录着，所以在DFS之后需要手动回溯，即删除上一层拼接的字符cur.deleteCharAt(cur.length()-1); Java代码12345678910111213141516171819202122class Solution &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); public List&lt;String&gt; generateParenthesis(int n) &#123; if(n==0) return res; dfs(n,n,""); return res; &#125; public void dfs(int left,int right,String curStr)&#123; if(left==0&amp;&amp;right==0)&#123; res.add(curStr); return; &#125; if(left&gt;0)&#123; dfs(left-1,right,curStr+"("); &#125; if(right&gt;left)&#123; dfs(left,right-1,curStr+")"); &#125; &#125;&#125; Java代码2123456789101112131415161718192021222324class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; res = new ArrayList(); backtrack(res, new StringBuilder(), 0, 0, n); return res; &#125; public void backtrack(List&lt;String&gt; res,StringBuilder cur,int left,int right,int max)&#123; if(cur.length()==max*2)&#123; res.add(cur.toString()); return; &#125; if(left&lt;max)&#123; cur.append('('); backtrack(res,cur,left+1,right,max); cur.deleteCharAt(cur.length()-1); &#125; if(right&lt;left)&#123; cur.append(')'); backtrack(res,cur,left,right+1,max); cur.deleteCharAt(cur.length()-1); &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Medium</tag>
        <tag>DFS</tag>
        <tag>字符串</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-19-删除链表的倒数第N个节点]]></title>
    <url>%2F2020%2F06%2F26%2FLeetCode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[LeetCode-19-删除链表的倒数第N个节点给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例 1: 123给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 说明： 给定的 n 保证是有效的。 进阶： 你能尝试使用一趟扫描实现吗？ 解题思路方法1、双指针： 两次遍历是一定能找到的，但是这样复杂度比较高，所以直接能想到的是使用双指针来进行操作，一次遍历即可完成 快指针先走n+1步，之后慢指针和快指针一起走 当快指针走到末尾时，慢指针刚好指向要删除节点的前一个节点，改变指向就可以完成节点删除。 其中需要初始化1个哑结点作为辅助，该节点位于列表头部，用来简化某些特例，比如列表中只含有一个节点，或者需要删除列表的头部。 快指针和慢指针的间隔始终是n Java代码12345678910111213141516171819202122232425/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode cur = dummy; ListNode pre = dummy; for (int i = 0; i &lt;n+1; i++) &#123; cur = cur.next; &#125; while (cur != null) &#123; cur = cur.next; pre = pre.next; &#125; pre.next = pre.next.next; return dummy.next; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Medium</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用AOP实现操作日志]]></title>
    <url>%2F2020%2F06%2F26%2F%E5%88%A9%E7%94%A8AOP%E5%AE%9E%E7%8E%B0%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[利用AOP实现操作日志AOP能够实现一些前置或者后置任务，作为一个切面，来完成例如日志记录、性能统计、安全控制、事务处理、异常处理等任务。这篇文章主要是总结自己利用AOP去实现全局操作日志记录功能的步骤。 要完成日志功能的记录和查询首先需要一个数据库表，命名为sysLog 包含id、visitTime、username、ip、url、executionTime、method字段 分别代表主键、访问时间、操作者用户名、访问ip、访问资源url、执行时长、访问方法。 创建一个对应的实体类 12345678910public class SysLog &#123; private String id; private Date visitTime; private String visitTimeStr; private String username; private String ip; private String url; private Long executionTime; private String method;&#125; 创建AOP切面 前置通知： 开始时间的获取直接new Date()即可 利用JoinPoint对象的getTarget()方法可以获得被代理的对象，之后通过getClass()获取要访问的类 那么如何去获得类中的方法名称呢？ JoinPoint中还有一个方法叫getSignature()用于获取封装了署名信息的对象，在该对象中可以获取到目标方 法名，所属类的Class等信息 除此之外还可以通过getArgs()方法获取传入目标方法的参数对象 后置通知： 结束时间可以直接用new Date().getTime()减去开始时间，即可获得访问时长了 我们还想要获取Controller中执行注解的url，有一下几个步骤： 当访问的类、访问的方法不为空且当前的类不是AOP这个类的时候，进行反射url获取 我们可以通过getAnnotation(xxx.class)获取class的注解，并通过.value()找到对应的RequesMapping映 射值，在这里我们分别通过clazz.getAnnotation和method.getAnnotation获取对应的类和方法上的url 之后进行字符串拼接即可得到完整的操作路径。 如何获取IP地址呢？如果我们能够拿到request对象，那么获取ip地址就比较容易，这里采用了Spring提供的 org.springframework.web.context.request.RequestContextListener，在LogAop中我们可以注入一 个HttpServletRequest request，通过request.getRemoteAddr()获取ip地址。 由于当前的用户受到SpringSecurity的控制，所以获取操作用户的对象，也必须从SpringSecurity的上下文中获取 具体代码如下，获取的User非用户定义，而是SpringSecurity中提供的User； 或者通过request.getSession().getAttribute(&quot;SPRING_SECURITY_CONTEXT&quot;)也可以获取User对象 123SecurityContext context = SecurityContextHolder.getContext();// 从上下文中获取当前登陆的用户User user = (User) context.getAuthentication().getPrincipal();String username = user.getUsername(); 之后可以对上面的信息进行数据存储，或者查询操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778@Component@Aspectpublic class LogAop &#123; @Autowired private HttpServletRequest request; @Autowired private ISysLogService sysLogService; private Date visitTime; // 开始时间 private Class clazz;// 访问的类 private Method method;// 访问的方法 //前置通知 主要是获取开始时间，执行的类是哪一个，执行的是哪一个方法 @Before("execution(* com.cqupt.lesson.controller.*.*(..))") public void doBefore(JoinPoint jp) throws NoSuchMethodException &#123; visitTime = new Date();// 当前时间是就是开始访问的时间 clazz = jp.getTarget().getClass();// 具体要访问的类 String methodName = jp.getSignature().getName();// 获取访问的方法的名称 Object[] args = jp.getArgs();// 获取访问的方法的参数 // 获取具体执行方法的Method对象 if (args == null || args.length == 0) &#123; method = clazz.getMethod(methodName);// 只能获取无参数的方法 &#125; else &#123; // 构建Class[]数组 Class[] classArgs = new Class[args.length]; for (int i = 0; i &lt; args.length; i++) &#123; classArgs[i] = args[i].getClass(); &#125; clazz.getMethod(methodName, classArgs);// 获取有参的方法 &#125; &#125; //后置通知 //通过反射完成方法体的寻找 @After("execution(* com.cqupt.lesson.controller.*.*(..))") public void doAfter(JoinPoint jp) throws Exception &#123; long time = new Date().getTime() - visitTime.getTime();// 获取访问时长 String url = ""; // 获取url if (clazz != null &amp;&amp; method != null &amp;&amp; clazz != LogAop.class) &#123; //1、获取类上的@RequestMapping("/orders") RequestMapping classAnnotation = (RequestMapping) clazz.getAnnotation(RequestMapping.class); if (classAnnotation != null) &#123; String[] classValue = classAnnotation.value(); //2、获取方法上的@RequestMapping("/findAll") RequestMapping methodAnnotation = method.getAnnotation(RequestMapping.class); if (methodAnnotation != null) &#123; String[] methodValue = methodAnnotation.value(); url = classValue[0] + methodValue[0]; // 获取访问的ip地址 String ip = request.getRemoteAddr(); // 获取当前操作的用户 SecurityContext context = SecurityContextHolder.getContext();// 从上下文中获取当前登陆的用户 User user = (User) context.getAuthentication().getPrincipal(); String username = user.getUsername(); //将日志相关信息封装到SysLog对象 SysLog sysLog = new SysLog(); sysLog.setExecutionTime(time);//执行时长 sysLog.setIp(ip); sysLog.setMethod("[类名] " + clazz.getName() + "[方法名] " + method.getName()); sysLog.setUrl(url); sysLog.setUsername(username); sysLog.setVisitTime(visitTime); //调用Service完成操作 sysLogService.save(sysLog); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis实现共享Session]]></title>
    <url>%2F2020%2F06%2F25%2FRedis%E5%AE%9E%E7%8E%B0%E5%85%B1%E4%BA%ABSession%2F</url>
    <content type="text"><![CDATA[Redis实现共享SessionSession共享，一般有一个这样的场景。以往单机的项目，数据请求都是在一个服务器上，session保存在这个服务器上自然是没有问题的。但是如果项目需要部署在多台服务器上的时候，session就会存在共享的问题 举一个例子： 假如现在有两台服务器同时运行，分别是ServerA和ServerB。 假设第一次请求(登陆请求)被分配到了A进行处理，A收到请求之后会生成一个sessionId并保存到内存中，然后返回给用户(浏览器)，浏览器会把sessionId保存到cookie中，第一次请求完成。如果之后每一次请求还是由A来进行处理，那么一切正常。如果A服务器挂掉了，这时候请求被分配到B，B拿到的sessionId是由A生成的，两边就对不上了。于是用户会发现，需要重新登陆了。 那么这样的问题应该怎么样去解决呢？ 首先，问题的根源出在sessionId无法共享上，想要把sessionId共享，一个简单的思路就是把sessionId保存到数据库中(这里选择redis)，这样验证的时候就不再从当前服务器获取sessionId了，而改为了从redis中获取 实现思路如下： 登陆页面提交用户名密码 登陆成功之后生成token。Token相当于原来的sessionId，字符串等，可以使用UUID 把用户信息保存到redis中。Key就是token，value就是userId 设置key的过期时间。模拟Session的过期时间 拦截器请求校验sessionId 代码实现登陆成功，生成sessionId存入redis 123456789101112131415161718192021222324252627282930@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private SysUserMapper sysUserMapper; @Autowired private RedisService redisService; @Override public LoginRespVo login(LoginReqVo vo) &#123; SysUser sysUser = sysUserMapper.selectByUsername(vo.getUsername()); if(sysUser==null)&#123; throw new BusinessException(4001005,"不存在该用户,请先注册"); &#125; if(sysUser.getStatus()==2)&#123; throw new BusinessException(4001006,"该帐号已被禁用"); &#125; if(!PasswordUtils.matches(sysUser.getSalt(),vo.getPassword(),sysUser.getPassword()))&#123; throw new BusinessException(4001007,"用户名密码不匹配"); &#125; String token = UUID.randomUUID().toString(); LoginRespVo respVo = new LoginRespVo(); respVo.setUserId(sysUser.getId()); respVo.setToken(token); redisService.set(token,sysUser.getId(),60, TimeUnit.MINUTES); redisService.set(sysUser.getId(),token,60,TimeUnit.MINUTES); return respVo; &#125;&#125; 其中LoginRespVo类为 12345678910111213package com.cqupt.lesson.vo.req;import io.swagger.annotations.ApiModelProperty;import lombok.Data;@Datapublic class LoginReqVo &#123; @ApiModelProperty(value = "用户名") private String username; @ApiModelProperty(value = "密码") private String password;&#125; SessionInterceptor拦截器校验sessionId，拦截器实现HandlerInterceptor的preHandle方法，可以获取从头部获取token或者从cookie获取token，之后进行token的验证 123456789101112131415161718192021222324252627282930313233package com.cqupt.lesson.interceptor;import com.cqupt.lesson.exception.BusinessException;import com.cqupt.lesson.service.RedisService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.util.StringUtils;import org.springframework.web.servlet.HandlerInterceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class TokenInterceptor implements HandlerInterceptor &#123; @Autowired private RedisService redisService; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String token = request.getHeader("token"); if(StringUtils.isEmpty(token))&#123; throw new BusinessException(4001002,"用户凭证不能为空"); &#125;else &#123; if(!redisService.hasKey(token))&#123; throw new BusinessException(4001002,"用户凭证无效"); &#125; String userId = (String) redisService.get(token); if(redisService.hasKey(userId)&amp;&amp;!token.equals(redisService.get(userId)))&#123; throw new BusinessException(4001002,"帐号已在异地登陆"); &#125; &#125; return true; &#125;&#125; 之后设置一个web拦截器，并注入自定义的拦截器 1234567891011121314151617181920package com.cqupt.lesson.config;import com.cqupt.lesson.interceptor.TokenInterceptor;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class WebAppConfig implements WebMvcConfigurer &#123; @Bean public TokenInterceptor tokenInterceptor()&#123; return new TokenInterceptor(); &#125; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(tokenInterceptor()).addPathPatterns("/api/**").excludePathPatterns("/api/user/login","/api/user/register","/api/user/code/*"); &#125;&#125; 登陆Service代码实现 123456789101112131415161718192021222324252627282930@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private SysUserMapper sysUserMapper; @Autowired private RedisService redisService; @Override public LoginRespVo login(LoginReqVo vo) &#123; SysUser sysUser = sysUserMapper.selectByUsername(vo.getUsername()); if(sysUser==null)&#123; throw new BusinessException(4001005,"不存在该用户,请先注册"); &#125; if(sysUser.getStatus()==2)&#123; throw new BusinessException(4001006,"该帐号已被禁用"); &#125; if(!PasswordUtils.matches(sysUser.getSalt(),vo.getPassword(),sysUser.getPassword()))&#123; throw new BusinessException(4001007,"用户名密码不匹配"); &#125; String token = UUID.randomUUID().toString(); LoginRespVo respVo = new LoginRespVo(); respVo.setUserId(sysUser.getId()); respVo.setToken(token); redisService.set(token,sysUser.getId(),60, TimeUnit.MINUTES); redisService.set(sysUser.getId(),token,60,TimeUnit.MINUTES); return respVo; &#125;&#125; 登陆Controller实现 1234567891011121314@RestController@RequestMapping("/api")@Api(tags = "用户模块",description = "用户模块相关接口")public class UserController &#123; @Autowired private UserService userService; @PostMapping("/user/login") @ApiModelProperty(value = "用户登陆接口") public LoginRespVo login(@RequestBody LoginReqVo vo)&#123; return userService.login(vo); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义RedisTemplate]]></title>
    <url>%2F2020%2F06%2F25%2F%E8%87%AA%E5%AE%9A%E4%B9%89RedisTemplate%2F</url>
    <content type="text"><![CDATA[自定义RedisTemplate在Spring Data Redis中，有一个高度封装的RedisTemplate类，实现了对Redis客户端的操作，其中提供了针对数据的StringRedisSerializer序列化方式，但这只能序列化String类型的Key和Value。在日常的数据处理中，通常会面对存储一个对象数据的任务，所以需要定义一个自己的序列化和反序列化方法。 Redis基本数据结构RedisTemplate中定义了对应的redis五种数据结构操作： opsForValue();//操作字符串 opsForHash();//操作hash opsForList(); //操作list opsForSet(); //操作set opsForZSet();//操作有序set RedisTemplate可以直接通过@Autowired获取对象引用，为什么能够直接声明获取引用呢？ 在spring boot启动后会向spring 注入两个bean RedisTemplate、StringRedisTemplate 源码中StringRedisTemplate继承自RedisTemplate RedisTemplate是一个泛型类，而StringRedisTemplate则不是 StringRedisTemplate只能对key=String，value=String的键值对进行操作，RedisTemplate可以对任何类型的key-value键值对操作 他们各自序列化的方式不同，但最终都是得到了一个字节数组，殊途同归，StringRedisTemplate使用的是StringRedisSerializer类；RedisTemplate使用的是JdkSerializationRedisSerializer类。反序列化，则是一个得到String，一个得到Object RedisTemplate在操作数据的时候，存入数据会将数据先序列化成字节数组然后在存入Redis数据库(默认JdkSerializationRedisSerializer:这个序列化方法就是Jdk提供的了,首先要求我们要被序列化的类继承自Serializeable接口，然后通过Jdk对象序列化的方法保存)，这个时候打开Redis查看的时候，你会看到你的数据不是以可读的形式，展现的，而是以字节数组显示。 而StringRedisSerializer在操作数据的时候就是通过String.getBytes()来实现的。而且在Redis中，所有存储的值都是字符串类型的。所以这种方法保存后，通过Redis-cli控制台或者Redis-Desktop-Manager图形化工具，是可以清楚的查看到我们保存了什么key,value是什么。 如当我们从以前的项目升级为RedisTemplate在不指定序列化方式的时候取不到原来的值 12345678@Autowired private RedisTemplate redisTemplate; @Test public void testRedisTemplate() &#123; System.out.println(redisTemplate.opsForValue().get("username")); &#125; 输出：null 这是因为升级成RedisTemplate他的默认使用序列化是JdkSerializationRedisSerializer，所以当需要获取数据的时候就找不到数据了(因为拿key去匹配的时候两种序列化得到的byte数组是不一样的)。 我们把RedisTemplate序列化方式设置成StringRedisSerializer看看效果 12345678910@Autowired @Test public void testRedisTemplate() &#123; stringRedisTemplate.opsForValue().set("username","张三"); StringRedisSerializer stringRedisSerializer=new StringRedisSerializer(); redisTemplate.setKeySerializer(stringRedisSerializer); redisTemplate.setValueSerializer(stringRedisSerializer); System.out.println(redisTemplate.opsForValue().get("username")); &#125;输出：张三 当我们指定使用StringRedisSerializer做value的序列化时，StringRedisSerializer的泛型指定的是String，传其他对象就会报类不能转换为String的异常 我们希望redis能够保存对象数据，就应该要自定义StringRedisSerializer 在StringRedisSerializer的源码中，它继承了RedisSerializer&lt;String&gt;，如下所示： 123456789101112131415161718192021222324252627282930313233//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package org.springframework.data.redis.serializer;import java.nio.charset.Charset;import java.nio.charset.StandardCharsets;import org.springframework.lang.Nullable;import org.springframework.util.Assert;public class StringRedisSerializer implements RedisSerializer&lt;String&gt; &#123; private final Charset charset; public static final StringRedisSerializer US_ASCII; public static final StringRedisSerializer ISO_8859_1; public static final StringRedisSerializer UTF_8; public StringRedisSerializer() &#123; this(StandardCharsets.UTF_8); &#125; public StringRedisSerializer(Charset charset) &#123; Assert.notNull(charset, "Charset must not be null!"); this.charset = charset; &#125; public String deserialize(@Nullable byte[] bytes) &#123; return bytes == null ? null : new String(bytes, this.charset); &#125; public byte[] serialize(@Nullable String string) &#123; return string == null ? null : string.getBytes(this.charset); &#125; static &#123; US_ASCII = new StringRedisSerializer(StandardCharsets.US_ASCII); ISO_8859_1 = new StringRedisSerializer(StandardCharsets.ISO_8859_1); UTF_8 = new StringRedisSerializer(StandardCharsets.UTF_8); &#125;&#125; 自定义redis序列化工具类将传入的Object对象转化为JSON字符串，之后再变为字节数组 1234567891011121314151617181920212223242526272829303132333435363738394041package com.cqupt.lesson.serializer;import com.alibaba.fastjson.JSON;import org.springframework.data.redis.serializer.RedisSerializer;import org.springframework.data.redis.serializer.SerializationException;import org.springframework.util.Assert;import java.nio.charset.Charset;import java.nio.charset.StandardCharsets;public class MyStringRedisSerializer implements RedisSerializer&lt;Object&gt; &#123; private final Charset charset; public MyStringRedisSerializer() &#123; this(StandardCharsets.UTF_8); &#125; public MyStringRedisSerializer(Charset charset) &#123; Assert.notNull(charset, "Charset must not be null!"); this.charset = charset; &#125; @Override public byte[] serialize(Object object) throws SerializationException &#123; if(object==null)&#123; return new byte[0]; &#125; if(object instanceof String)&#123; return object.toString().getBytes(charset); &#125;else&#123; String string = JSON.toJSONString(object); return string.getBytes(charset); &#125; &#125; @Override public Object deserialize(byte[] bytes) throws SerializationException &#123; return (bytes == null ? null : new String(bytes, charset)); &#125;&#125; 同时需要加入fastjson依赖，创建一个RedisConfig配置类，设置2种key-value的序列化方式 1234567891011121314151617181920212223package com.cqupt.lesson.config;import com.cqupt.lesson.serializer.MyStringRedisSerializer;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.StringRedisSerializer;@Configurationpublic class RedisConfig &#123; @Bean public RedisTemplate&lt;String,Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory)&#123; RedisTemplate&lt;String,Object&gt; redisTemplate = new RedisTemplate&lt;&gt;(); redisTemplate.setConnectionFactory(redisConnectionFactory); redisTemplate.setKeySerializer(new StringRedisSerializer()); redisTemplate.setHashKeySerializer(new StringRedisSerializer()); redisTemplate.setValueSerializer(new MyStringRedisSerializer()); redisTemplate.setHashValueSerializer(new MyStringRedisSerializer()); return redisTemplate; &#125;&#125; 之后自定义一个RedisService类，接管RedisTemplate的功能，并在此基础上进行一点判空修改(代码过长，只贴一部分) 1234567891011121314151617181920212223242526272829303132333435363738@Servicepublic class RedisService &#123; @Autowired private RedisTemplate&lt;String,Object&gt; redisTemplate; /** -------------------key相关操作--------------------- */ /** * 是否存在key * @Author: YuanMing * @UpdateUser: * @Version: 0.0.1 * @param key * @return java.lang.Boolean * @throws */ public Boolean hasKey(String key) &#123; if (null==key)&#123; return false; &#125; return redisTemplate.hasKey(key); &#125; /** * 删除key * @Author: YuanMing * @UpdateUser: * @Version: 0.0.1 * @param key * @return Boolean 成功返回true 失败返回false * @throws */ public Boolean delete(String key) &#123; if (null==key)&#123; return false; &#125; return redisTemplate.delete(key); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-17-电话号码的字母组合]]></title>
    <url>%2F2020%2F06%2F24%2FLeetCode-17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%2F</url>
    <content type="text"><![CDATA[LeetCode-17-电话号码的字母组合给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例 1: 12输入：&quot;23&quot;输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. 说明:尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。 解题思路方法1、回溯： 首先需要建立一个map，存储数字到字符串的映射 排列组合问题一般想象成树形问题，可以进行回溯选择 本题中回溯的停止条件是当深度达到输入字符长度的时候 回溯流程： 选择第一个输入的数字 找到这个数字对应的字母列表，并选择第一个字母加入到tmp中 开启下一层递归 当加入过一个答案之后，进行回溯，即删除刚选择的最后一个字符，选择另外的路走 Java代码123456789101112131415161718192021222324252627282930313233class Solution &#123; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;() &#123;&#123; put("2", "abc"); put("3", "def"); put("4", "ghi"); put("5", "jkl"); put("6", "mno"); put("7", "pqrs"); put("8", "tuv"); put("9", "wxyz"); &#125;&#125;; List&lt;String&gt; res = new ArrayList&lt;String&gt;(); StringBuilder tmp = new StringBuilder(); public List&lt;String&gt; letterCombinations(String digits) &#123; if(digits==null||digits.length()==0) return res; backtrack(digits,0); return res; &#125; public void backtrack(String digits,int index)&#123; if(index&gt;=digits.length())&#123; res.add(tmp.toString()); return; &#125; String letter = map.get(digits.substring(index,index+1)); for(int i=0;i&lt;letter.length();i++)&#123; tmp.append(letter.charAt(i)); backtrack(digits,index+1); tmp.deleteCharAt(tmp.length()-1); &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-215-数组中的第K个最大元素]]></title>
    <url>%2F2020%2F06%2F24%2FLeetCode-215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[LeetCode-215-数组中的第K个最大元素在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1: 12输入: [3,2,1,5,6,4] 和 k = 2输出: 5 示例2： 12输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4 说明: 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 解题思路方法1、优先队列： 首先想到的是给数组进行排序，排序之后就很容易找到第k个最大的元素 那么有没有不排序的方法，自然就会想到建立堆来进行操作 我们可以建立一个大顶堆，最大的数在建堆的过程中排最上面，一次遍历就能完成数组从大到小的构建 寻找排序之后的第k个最大的元素，也就是寻找大顶堆的正序第k个元素 之后一直弹出到k-1为止，下一个位置就是第k个最大的元素 方法2、暴力破解： 排序之后，倒置一下，第k-1个位置就是第k个最大的元素，不倒置就是nums.length-k个位置 方法3、快速选择： 摘自LeetCode官方题解 就像快速排序那样，本算法也是 Tony Hoare 发明的，因此也被称为 Hoare选择算法。 本方法大致上与快速排序相同。简便起见，注意到第 k 个最大元素也就是第 N - k 个最小元素，因此可以用第 k 小算法来解决本问题。 首先，我们选择一个枢轴，并在线性时间内定义其在排序数组中的位置。这可以通过 划分算法 的帮助来完成。 为了实现划分，沿着数组移动，将每个元素与枢轴进行比较，并将小于枢轴的所有元素移动到枢轴的左侧。 这样，在输出的数组中，枢轴达到其合适位置。所有小于枢轴的元素都在其左侧，所有大于或等于的元素都在其右侧。 这样，数组就被分成了两部分。如果是快速排序算法，会在这里递归地对两部分进行快速排序。 而在这里，由于知道要找的第 N - k 小的元素在哪部分中，我们不需要对两部分都做处理。 最终的算法十分直接了当 : 随机选择一个枢轴。 使用划分算法将枢轴放在数组中的合适位置 pos。将小于枢轴的元素移到左边，大于等于枢轴的元素移到右边。 比较 pos 和 N - k 以决定在哪边继续递归处理。 Java代码12345678910111213141516171819202122class Solution &#123; public int findKthLargest(int[] nums, int k) &#123; int len = nums.length; if (len == 1) &#123; return nums[0]; &#125; if (len &lt;= 2) &#123; Arrays.sort(nums); return nums[len - k]; &#125; Queue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;((v1,v2)-&gt;v2-v1); for (int i = 0; i &lt; len; i++) &#123; queue.add(nums[i]); &#125; int i=0; while (!queue.isEmpty()&amp;&amp;i&lt;k-1)&#123; queue.poll(); i++; &#125; return queue.poll(); &#125;&#125; Python代码1234class Solution: def findKthLargest(self, nums: List[int], k: int) -&gt; int: nums.sort(reverse=True) return nums[k-1] Java代码21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution &#123; int[] nums; public void swap(int a, int b) &#123; int tmp = this.nums[a]; this.nums[a] = this.nums[b]; this.nums[b] = tmp; &#125; public int partition(int left, int right, int pivot_index) &#123; // 优化之后的快排，比枢轴元素大的理论应该放右边，但右边这部分甚至不需要排序 // 只需要找到N-k个位置就可以了 int pivot = this.nums[pivot_index]; // 1. 移动枢轴到最右 swap(pivot_index, right); int store_index = left; // 2. 移动所有小的元素到枢轴左边 for (int i = left; i &lt;= right; i++) &#123; if (this.nums[i] &lt; pivot) &#123; swap(store_index, i); store_index++; &#125; &#125; // 3. 还原枢轴到最终位置，左边的元素全部比他小 swap(store_index, right); return store_index; &#125; public int quickselect(int left, int right, int k_smallest) &#123; if (left == right) // 如果list只包含一个元素 return this.nums[left]; // 则返回这个元素 // 选择一个随机的枢轴 Random random_num = new Random(); int pivot_index = left + random_num.nextInt(right - left); pivot_index = partition(left, right, pivot_index); // 枢轴在N-k小的位置上，比较pos和N-k if (k_smallest == pivot_index) return this.nums[k_smallest]; // 左递归 else if (k_smallest &lt; pivot_index) return quickselect(left, pivot_index - 1, k_smallest); // 右递归 return quickselect(pivot_index + 1, right, k_smallest); &#125; public int findKthLargest(int[] nums, int k) &#123; this.nums = nums; int size = nums.length; // 第k个最大的元素，也就是第N-k个最小的元素 return quickselect(0, size - 1, size - k); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-20-有效的括号]]></title>
    <url>%2F2020%2F06%2F24%2FLeetCode-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[LeetCode-20-有效的括号给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1: 12输入: &quot;()&quot;输出: true 示例2： 12输入: &quot;()[]&#123;&#125;&quot;输出: true 示例3： 12输入: &quot;(]&quot;输出: false 示例4： 12输入: &quot;([)]&quot;输出: false 示例5： 12输入: &quot;&#123;[]&#125;&quot;输出: true 解题思路方法1、栈： 观察题目可知，要想构成有效的括号，最开始加入的(括号的反)必须是最后加入 这种规律符合栈的先进后出的方式，于是可以用栈来模拟 当扫描到前括号(、{、[的时候，在栈中加入对应的反括号),},] 当全部匹配时，栈为空等于true 特例处理当输入的字符为null的时候，直接返回true 当输入的字符为[的时候，栈中会加入反括号]，此时栈不为空，返回false 当输入的字符为]的时候，栈中不会加入反括号，此时如果直接返回栈是否为空，会返回true，但这是一个错误的结果 所以新增一个新的判断，else if(stack.isEmpty()||c!=stack.pop())联合判别反括号和栈空的情况，都是false Java代码12345678910111213141516171819class Solution &#123; public boolean isValid(String s) &#123; if(s==null||s.length()==0) return true; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); char[] cs = s.toCharArray(); for(char c:cs)&#123; if(c=='(')&#123; stack.push(')'); &#125;else if(c=='&#123;')&#123; stack.push('&#125;'); &#125;else if(c=='[')&#123; stack.push(']'); &#125;else if(stack.isEmpty()||c!=stack.pop())&#123; return false; &#125; &#125; return stack.isEmpty(); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>字符串</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-15-三数之和]]></title>
    <url>%2F2020%2F06%2F23%2FLeetCode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[LeetCode-15-三数之和给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例 1: 1234567给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 解题思路方法1、双指针： 不重复问题首先一步是要对数组进行排序 排序之后固定一个数nums[i]，之后利用左右指针找nums[left]+nums[right]+nums[i]==0的数，就可以添加进入结果集合 但过程中需要考虑数据重复的问题 如果nums[i]&gt;0，则说明三数之和必然无法等于0，直接跳出循环 如果nums[i]==nums[i-1]，则说明该数字重复，会导致重复的结果，所以直接跳过 之后当left&lt;right的时候，且 sum==0，nums[left]==nums[left+1]会导致重复的结果，应该跳过，所以left++ sum==0，nums[right]==nums[right-1]时，会导致重复的，应该跳过，所以right— Java代码12345678910111213141516171819202122232425262728class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; int len = nums.length; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(len&lt;3) return res; Arrays.sort(nums); for(int i=0;i&lt;len-2;i++)&#123; if(nums[i]&gt;0) break; if(i&gt;0&amp;&amp;nums[i]==nums[i-1]) continue; int left = i+1; int right = len-1; while(left&lt;right)&#123; if(nums[i]+nums[left]+nums[right]==0)&#123; res.add(Arrays.asList(nums[i],nums[left],nums[right])); while(left&lt;right&amp;&amp;nums[left]==nums[left+1]) left++; while(left&lt;right&amp;&amp;nums[right]==nums[right-1]) right--; left++; right--; &#125;else if(nums[i]+nums[left]+nums[right]&gt;0)&#123; right--; &#125;else&#123; left++; &#125; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-105-从前序与中序遍历构造二叉树]]></title>
    <url>%2F2020%2F06%2F22%2FLeetCode-105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[LeetCode-105-从前序与中序遍历构造二叉树根据一棵树的前序遍历与中序遍历构造二叉树。 注意:你可以假设树中没有重复的元素。 示例 1: 例如，给出 12前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 12345 3 / \9 20 / \ 15 7 解题思路方法1、递归： 前序遍历：根左右 中序遍历：左根右 对于任意一棵树而言，前序遍历的形式总是 1[根节点，[左子树的前序遍历结果],[右子树的前序遍历结果]] 根节点总是，前序遍历中的第一个节点 中序遍历的形式总是 1[[左子树的中序遍历结果],根节点,[右子树的中序遍历结果]] 只要能够在中序遍历中定位到根节点，那么就可以得到对应的左右子树的节点数目 由于前序遍历和中序遍历的长度是相同的，所以我们也能知道前序遍历的左右字数的区间范围 之后进行递归，问题就变为了： 知道左子树的前序和中序遍历，重建左子树；知道右子树的前序和中序遍历，重建右子树； 定位优化： 在中序遍历中需要根据前序遍历的根节点，定位到中序遍历中的根节点 直接进行扫描匹配的耗时比较大，可以在一开始对中序遍历建立hash表，Key代表元素的值，value代表在中序遍历中出现的位置。之后寻找对应值就能够快速定位了 方法2、迭代： https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/ Java代码112345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; if(preorder==null||preorder.length==0)&#123; return null; &#125; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int i=0;i&lt;inorder.length;i++)&#123; map.put(inorder[i],i); &#125; int length = preorder.length-1; TreeNode root = reconstrTree(preorder,0,length,inorder,0,length,map); return root; &#125; public TreeNode reconstrTree(int[] preorder,int postart,int poend,int[] inorder,int instart,int inend,Map&lt;Integer,Integer&gt; map)&#123; if(postart&gt;poend)&#123; return null; &#125; int rootNode = preorder[postart]; TreeNode root = new TreeNode(rootNode); if(postart==poend)&#123; return root; &#125;else&#123; int rootIndex = map.get(rootNode); int leftRange = rootIndex - instart; int rightRange = inend - rootIndex; TreeNode leftTree = reconstrTree(preorder,postart+1,postart+leftRange,inorder,instart,rootIndex-1,map); TreeNode rightTree = reconstrTree(preorder,poend-rightRange+1,poend,inorder,rootIndex+1,inend,map); root.left = leftTree; root.right = rightTree; return root; &#125; &#125;&#125; Java代码2123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; if (preorder == null || preorder.length == 0) &#123; return null; &#125; TreeNode root = new TreeNode(preorder[0]); Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); stack.push(root); int inorderIndex = 0; for (int i = 1; i &lt; preorder.length; i++) &#123; int preorderVal = preorder[i]; TreeNode node = stack.peek(); if (node.val != inorder[inorderIndex]) &#123; node.left = new TreeNode(preorderVal); stack.push(node.left); &#125; else &#123; while (!stack.isEmpty() &amp;&amp; stack.peek().val == inorder[inorderIndex]) &#123; node = stack.pop(); inorderIndex++; &#125; node.right = new TreeNode(preorderVal); stack.push(node.right); &#125; &#125; return root; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>树</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-70-爬楼梯]]></title>
    <url>%2F2020%2F06%2F20%2FLeetCode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF%2F</url>
    <content type="text"><![CDATA[LeetCode-70-爬楼梯假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1: 12345输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶 示例 2: 123456输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 解题思路方法1、动态规划： 当n等于1的时候，只需要跳一次即可，只有一种跳法，记f(1)=1 当n等于2的时候，可以先跳一级再跳一级，或者直接跳二级，共有2种跳法，记f(2)=2 当n等于3的时候，他可以从一级台阶上跳两步上来，也可以从二级台阶上跳一步上来，所以总共有f(3)=f(2)+f(1)； 所以当等于n(n&gt;2)的时候，总共有f(n)=f(n-1)+f(n-2)种跳法 此时的状态: 为n的时候，可能的跳法有多少种 状态转移方程：f(n)=f(n-1)+f(n-2) 方法2、优化的动态规划： 上一个方法需要开辟一个n的数组，其实可以直接用双指针完成状态的转移，不再需要开辟多余的空间 Java代码12345678910111213class Solution &#123; public int climbStairs(int n) &#123; if (n &lt;= 1) return 1; int[] dp = new int[n + 1]; dp[1] = 1; dp[2] = 2; for (int i = 3; i &lt;= n; i++) &#123; dp[i] = dp[i - 1] + dp[i - 2]; &#125; return dp[n]; &#125;&#125; Java代码21234567891011121314151617class Solution &#123; public int climbStairs(int n) &#123; int[] result = new int[]&#123;1, 1&#125;; if (n &lt; 2) &#123; return result[n]; &#125; int sum = 0; int f1 = 1; int f2 = 1; for (int i = 2; i &lt;= n; i++) &#123; sum = (f1 + f2); f1 = f2; f2 = sum; &#125; return sum; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Easy</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-11-盛最多水的容器]]></title>
    <url>%2F2020%2F06%2F19%2FLeetCode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[LeetCode-11-盛最多水的容器给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 示例 1: 12输入：[1,8,6,2,5,4,8,3,7]输出：49 解题思路方法1、双指针： 根据题目的意思，最大面积=左右两个内板较低的一个高度*左右两个内板的间隔 利用双指针解决，初始化首尾指针，现在的问题是怎么样去移动首尾指针，才能够使得面积最大 想象一下，无论首尾指针谁大，我们都需要移动一次首尾指针，依次判断面积谁更大，此时无论是移动首还是尾指针，底部长度的变化都是1。于是我们只需要知道，移动哪个指针能让面积增大就行了。经过思考，移动值较小的那个指针，保留值较大的指针，可以使得面积更大的概率更大。所以当其中一个指针的值小于另外一个的时候，移动那个指针即可 Java代码12345678910111213class Solution &#123; public int maxArea(int[] height) &#123; int left = 0; int right = height.length-1; int max = 0; while(left&lt;right)&#123; max = Math.max(max,(right-left)*Math.min(height[left],height[right])); if(height[left]&lt;height[right]) left++; else right--; &#125; return max; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-4-寻找两个正序数组的中位数]]></title>
    <url>%2F2020%2F06%2F19%2FLeetCode-4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[LeetCode-4-寻找两个正序数组的中位数给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。 请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1: 1234nums1 = [1, 3]nums2 = [2]则中位数是 2.0 示例2： 1234nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5 解题思路方法1、归并排序思想： 这种方法的复杂度不符合题意，属于备用解法 对于两个有序的数组，想要找到对应的中位数，最简单的方法就是将两个数组合并为1个，之后找中位数就很简单 只需要知道中间位置即可，奇数情况是一个数，偶数情况是两个数 方法2、二分查找思想： 不会做….答案出自官方题解 Java代码1234567891011121314151617181920212223class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int[] merge = new int[nums1.length + nums2.length]; int i = 0; int j = 0; int m = 0; while (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123; if (nums1[i] &lt;= nums2[j]) &#123; merge[m++] = nums1[i++]; &#125; else &#123; merge[m++] = nums2[j++]; &#125; &#125; while (i &lt; nums1.length) &#123; merge[m++] = nums1[i++]; &#125; while (j &lt; nums2.length) &#123; merge[m++] = nums2[j++]; &#125; return (m % 2 == 0) ? ((double) merge[m / 2] + (double) merge[m / 2 - 1]) / 2 : (double) merge[m / 2]; &#125;&#125; Java代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int leftLength = nums1.length; int rightLength = nums2.length; // 为了保证第一个数组比第二个数组小(或者相等) if (leftLength &gt; rightLength) &#123; return findMedianSortedArrays(nums2, nums1); &#125; // 分割线左边的所有元素需要满足的个数 m + (n - m + 1) / 2; // 两个数组长度之和为偶数时，当在长度之和上+1时，由于整除是向下取整，所以不会改变结果 // 两个数组长度之和为奇数时，按照分割线的左边比右边多一个元素的要求，此时在长度之和上+1，就会被2整除，会在原来的数 //的基础上+1，于是多出来的那个1就是左边比右边多出来的一个元素 int totalLeft = (leftLength + rightLength + 1) / 2; // 在 nums1 的区间 [0, leftLength] 里查找恰当的分割线， // 使得 nums1[i - 1] &lt;= nums2[j] &amp;&amp; nums2[j - 1] &lt;= nums1[i] int left = 0; int right = leftLength; // nums1[i - 1] &lt;= nums2[j] // 此处要求第一个数组中分割线的左边的值 不大于(小于等于) 第二个数组中分割线的右边的值 // nums2[j - 1] &lt;= nums1[i] // 此处要求第二个数组中分割线的左边的值 不大于(小于等于) 第一个数组中分割线的右边的值 // 循环条件结束的条件为指针重合，即分割线已找到 while (left &lt; right) &#123; // 二分查找，此处为取第一个数组中左右指针下标的中位数，决定起始位置 // 此处+1首先是为了不出现死循环，即left永远小于right的情况 // left和right最小差距是1，此时下面的计算结果如果不加1会出现i一直=left的情况，而+1之后i才会=right // 于是在left=i的时候可以破坏循环条件，其次下标+1还会保证下标不会越界，因为+1之后向上取整，保证了 // i不会取到0值，即i-1不会小于0 // 此时i也代表着在一个数组中左边的元素的个数 int i = left + (right - left + 1) / 2; // 第一个数组中左边的元素个数确定后，用左边元素的总和-第一个数组中元素的总和=第二个元素中左边的元素的总和 // 此时j就是第二个元素中左边的元素的个数 int j = totalLeft - i; // 此处用了nums1[i - 1] &lt;= nums2[j]的取反，当第一个数组中分割线的左边的值大于第二个数组中分割线的右边的值 // 说明又指针应该左移，即-1 if (nums1[i - 1] &gt; nums2[j]) &#123; // 下一轮搜索的区间 [left, i - 1] right = i - 1; // 此时说明条件满足，应当将左指针右移到i的位置，至于为什么是右移，请看i的定义 &#125; else &#123; // 下一轮搜索的区间 [i, right] left = i; &#125; &#125; // 退出循环时left一定等于right，所以此时等于left和right都可以 // 为什么left一定不会大于right?因为left=i。 // 此时i代表分割线在第一个数组中所在的位置 // nums1[i]为第一个数组中分割线右边的第一个值 // nums[i-1]即第一个数组中分割线左边的第一个值 int i = left; // 此时j代表分割线在第二个数组中的位置 // nums2[j]为第一个数组中分割线右边的第一个值 // nums2[j-1]即第一个数组中分割线左边的第一个值 int j = totalLeft - i; // 当i=0时，说明第一个数组分割线左边没有值，为了不影响 // nums1[i - 1] &lt;= nums2[j] 和 Math.max(nums1LeftMax, nums2LeftMax) // 的判断，所以将它设置为int的最小值 int nums1LeftMax = i == 0 ? Integer.MIN_VALUE : nums1[i - 1]; // 等i=第一个数组的长度时，说明第一个数组分割线右边没有值，为了不影响 // nums2[j - 1] &lt;= nums1[i] 和 Math.min(nums1RightMin, nums2RightMin) // 的判断，所以将它设置为int的最大值 int nums1RightMin = i == leftLength ? Integer.MAX_VALUE : nums1[i]; // 当j=0时，说明第二个数组分割线左边没有值，为了不影响 // nums2[j - 1] &lt;= nums1[i] 和 Math.max(nums1LeftMax, nums2LeftMax) // 的判断，所以将它设置为int的最小值 int nums2LeftMax = j == 0 ? Integer.MIN_VALUE : nums2[j - 1]; // 等j=第二个数组的长度时，说明第二个数组分割线右边没有值，为了不影响 // nums1[i - 1] &lt;= nums2[j] 和 Math.min(nums1RightMin, nums2RightMin) // 的判断，所以将它设置为int的最大值 int nums2RightMin = j == rightLength ? Integer.MAX_VALUE : nums2[j]; // 如果两个数组的长度之和为奇数，直接返回两个数组在分割线左边的最大值即可 if (((leftLength + rightLength) % 2) == 1) &#123; return Math.max(nums1LeftMax, nums2LeftMax); &#125; else &#123; // 如果两个数组的长度之和为偶数，返回的是两个数组在左边的最大值和两个数组在右边的最小值的和的二分之一 // 此处不能被向下取整，所以要强制转换为double类型 return (double) ((Math.max(nums1LeftMax, nums2LeftMax) + Math.min(nums1RightMin, nums2RightMin))) / 2; &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-136-只出现一次的数字]]></title>
    <url>%2F2020%2F06%2F18%2FLeetCode-136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[LeetCode-136-只出现一次的数字给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 12输入: [2,2,1]输出: 1 示例2： 12输入: [4,1,2,1,2]输出: 4 解题思路方法1、异或运算： 异或运算的特点 任何数和0做异或运算，结果是原来的数 任何数和其自身做异或运算，结果是自身 异或运算满足交换律和结合律，即a^b^a=b^a^a=b^(a^a)=b^0=b 根据这个特点可以直接用异或运算得出出现一次的字符 方法2、哈希表： 这个解法不符合题意，用到了一个哈希表来存储数字出现的次数 之后取出出现次数为1的数字即可 Java代码123456789class Solution &#123; public int singleNumber(int[] nums) &#123; int single = 0; for (int num : nums) &#123; single ^= num; &#125; return single; &#125;&#125; Python代码123456789class Solution: def singleNumber(self, nums: List[int]) -&gt; int: dict1 = dict() for i in nums: if i in dict1: dict1[i]+=1 else: dict1[i]=1 return list(dict1.keys())[list(dict1.values()).index(1)]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Easy</tag>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-413-等差数列划分]]></title>
    <url>%2F2020%2F06%2F18%2FLeetCode-413-%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86%2F</url>
    <content type="text"><![CDATA[LeetCode-413-等差数列划分如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。 例如，以下数列为等差数列: 1231, 3, 5, 7, 97, 7, 7, 73, -1, -5, -9 以下数列不是等差数列 11, 1, 2, 5, 7 数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0&lt;=P&lt;Q&lt;N 。 如果满足以下条件，则称子数组(P, Q)为等差数组： 元素 A[P], A[p + 1], …, A[Q - 1], A[Q] 是等差的。并且 P + 1 &lt; Q 。 函数要返回数组 A 中所有为等差数组的子数组个数。 示例 1: 123A = [1, 2, 3, 4]返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。 解题思路方法1、动态规划： 状态定义为：当前的等差数组数量 如果前一个状态是等差数组，则只需要判断后一个数字前两个的差值是否满足等差数组，如果满足则+1 如1，2，3是等差数组，指针后移到4时仍然满足等差数组的条件，此时不需要往前判断到1，只需要判断到前2位即可，2，3，4是等差数组，之前的1，2，3，4同样也是 所以状态转移方程为：dp[i]=dp[i-1]+1 之后返回dp数组的和就是等差数组的数量 方法2、暴力破解： Java代码123456789101112131415class Solution &#123; public int numberOfArithmeticSlices(int[] A) &#123; int len = A.length; if(A==null||len==0) return 0; int[] dp = new int[len]; int sum = 0; for(int i=2;i&lt;len;i++)&#123; if(A[i-1]-A[i-2]==A[i]-A[i-1])&#123; dp[i]=dp[i-1]+1; sum+=dp[i]; &#125; &#125; return sum; &#125;&#125; Java代码1234567891011121314151617class Solution &#123; public int numberOfArithmeticSlices(int[] A) &#123; int sum = 0; int len = A.length; for(int i=0;i&lt;len-2;i++)&#123; int distance = A[i+1]-A[i]; for(int j=i+2;j&lt;len;j++)&#123; if(A[j]-A[j-1]==distance)&#123; sum++; &#125;else&#123; break; &#125; &#125; &#125; return sum; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-5-最长回文字串]]></title>
    <url>%2F2020%2F06%2F18%2FLeetCode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%97%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[LeetCode-5-最长回文字串给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1: 123输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。 示例2： 12输入: &quot;cbbd&quot;输出: &quot;bb&quot; 解题思路方法1、暴力破解： 暴力破解法，判断每个串开头的所有子串中，大于最长子串的串是否是回文子串 判断回文字串的方法为，首尾往内遍历，如果首尾不相等则不是回文字串，移动左指针+1，右指针-1； 否则就是回文子串 方法2、动态规划： 参考地址1 参考地址2 方法3、中心扩散法： 枚举所有的回文中心位置，回文中心位置需要按照字符串长度分为奇数和偶数的情况 奇数情况时，回文中心仅有1个字符 偶数情况时，回文中心有2个字符 从回文中心出发进行扩散，尽可能的使得子串长度达到最大，不满足时跳出，返回扩散之后回文子串的长度j-i+1-2 判断奇数情况和偶数情况下回文子串的最大长度 之后按照最大长度找到回文子串开始的位置，截取子串返回 1234567比如奇数回文串 偶数回文串A A B C B A A A B C C B A0 1 2 3 4 5 0 1 2 3 4 5 6 begin i begin i i+1 len=5 len=6 bengin = i-(len-1)/2 Java代码12345678910111213141516171819202122232425262728class Solution &#123; public String longestPalindrome(String s) &#123; int len = s.length(); if(len&lt;2) return s; int maxlen = 1; int begin = 0; char[] charAarray = s.toCharArray(); for(int i=0;i&lt;len-1;i++)&#123; for(int j=1;j&lt;len;j++)&#123; if(j-i+1&gt;maxlen&amp;&amp;validateSubString(charAarray,i,j))&#123; begin = i; maxlen = j-i+1; &#125; &#125; &#125; return s.substring(begin,begin+maxlen); &#125; public boolean validateSubString(char[] charAarray,int left,int right)&#123; while(left&lt;right)&#123; if(charAarray[left]!=charAarray[right])&#123; return false; &#125; left++; right--; &#125; return true; &#125;&#125; Java代码21234567891011121314151617181920212223242526272829303132333435363738394041424344public class Solution &#123; public String longestPalindrome(String s) &#123; int len = s.length(); if (len &lt; 2) &#123; return s; &#125; int maxLen = 1; int begin = 0; // dp[i][j] 表示 s[i, j] 是否是回文串 // i是子串的左边界，j是子串的右边界 boolean[][] dp = new boolean[len][len]; char[] charArray = s.toCharArray(); // 对角线恒为true for (int i = 0; i &lt; len; i++) &#123; dp[i][i] = true; &#125; // 由于dp[i+1][j-1]是行+1，列减1，dp[i][j]依赖于左下方的值，这样不好计算 // 所以先升序填列，再升序填行，按列遍历 for (int j = 1; j &lt; len; j++) &#123; // 列 for (int i = 0; i &lt; j; i++) &#123;// 行 if (charArray[i] != charArray[j]) &#123; // 头尾字符不相等时 dp[i][j] = false; &#125; else &#123; // j-1-(i+1)+1&lt;2 if (j - i &lt; 3) &#123; // 如果头尾没有字符，或者只剩一个字符 dp[i][j] = true; &#125; else &#123; dp[i][j] = dp[i + 1][j - 1]; &#125; &#125; // 只要 dp[i][j] == true 成立，就表示子串 s[i..j] 是回文，此时记录回文长度和起始位置 if (dp[i][j] &amp;&amp; j - i + 1 &gt; maxLen) &#123; maxLen = j - i + 1; begin = i; &#125; &#125; &#125; return s.substring(begin, begin + maxLen); &#125;&#125; Java代码3123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Solution &#123; public String longestPalindrome(String s) &#123; int len = s.length(); if (len &lt; 2) &#123; return s; &#125; int maxLen = 1; int begin = 0; char[] charArray = s.toCharArray(); // 枚举所有回文中心 for(int i=0;i&lt;len-1;i++)&#123; int oddLen = expandAroudCenter(charArray,i,i); // 以下标i作为回文中心 int evenLen = expandAroudCenter(charArray,i,i+1); //以下标i和i+1作为回文中心 int curMaxLen = Math.max(oddLen,evenLen); if(curMaxLen&gt;maxLen)&#123; maxLen = curMaxLen; // 画图找规律 begin = i-(maxLen-1)/2; &#125; &#125; return s.substring(begin,begin+maxLen); &#125; public int expandAroudCenter(char[] charArray,int left,int right)&#123; // 当left=right的时候，回文中心是一个字符，回文串的长度是奇数 // 当right=left+1的时候，此时回文中心两个字符，回文串的长度是偶数 int len = charArray.length; int i = left; int j = right; // 从回文中心向两边扩散 while(i&gt;=0&amp;&amp;j&lt;len)&#123; if(charArray[i]==charArray[j])&#123; i--; j++; &#125;else&#123; break; &#125; &#125; // 跳出while循环时，恰好满足 s.charAt(i)!=s.charAt(j) // 回文串的长度 j-i+1-2=j-i-1 ，减2是因为不包括回文中心字符 return j-i-1; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
        <tag>字符串</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-3-无重复字符的最长字串]]></title>
    <url>%2F2020%2F06%2F16%2FLeetCode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[LeetCode-3-无重复字符的最长字串给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例2： 123输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例3： 1234输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 解题思路方法1、哈希表： 首先挨个比较i个字符和i+1结合哈希的方法是失败的，这样求的不适用于dvdf这样的测试用例 我们可以通过记录无重复字符的初始位置start，以及结尾位置end，算出最长的字串是多大 顺序遍历整个字符数组，判断当前的元素是否在hash表内，如果在则将当前元素作为key值，获取不重复元素对应位置，并更新start，此时，start到end不存在重复字符 进入下一步，计算区间内字符长度 如果当前元素不在hash表内，则添加当前字符位置+1，+1表示从当前字符位置后面一个开始不重复 方法2、滑动窗口： 窗口的最大值就是最长字串，比如dvdf这样的用例 当窗口为dv的时候，满足题目要求，当窗口为dvd时，不满足要求，此时需要向右边滑动 将左边重复的元素d移除，同时在右边新增，直到满足要求为止 当窗口变化的时候记录当前窗口的最大值 Java代码12345678910111213141516class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); char[] c = s.toCharArray(); int max = 0; int start = 0; for (int end = 0; end &lt; c.length; end++) &#123; if (map.containsKey(c[end])) &#123; start = Math.max(map.get(c[end]), start); &#125; max = Math.max(max, end - start + 1); map.put(c[end], end + 1); &#125; return max; &#125;&#125; Python代码12345678910111213141516class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: if not s: return 0 left = 0 Max,curMax = 0,0 n = len(s) hashset = set() for i in range(n): curMax += 1 while s[i] in hashset: hashset.remove(s[left]) left += 1 curMax -= 1 if curMax &gt; Max: Max = curMax hashset.add(s[i]) return Max]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
        <tag>字符串</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-2-两数相加]]></title>
    <url>%2F2020%2F06%2F16%2FLeetCode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[LeetCode-2-两数相加给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例 1: 123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 解题思路顺序推进+哑结点： 对于本题的测试用例，不难知道有以下三种情况： 两个链表长度一致 两个链表长度一长一短 两个链表在相加过程中产生进位，进位需要加在下一位 特例判断，当l1为空，直接返回l2；当l2为空，直接返回l1 新增l1，l2的指针t1，t2，方便链表的遍历；新增l3哑结点和对应指针t3，用于存储相加之后的链表 相加流程： 当两个链表其中一个不为空的时候，说明还没有加完； 由于相加的过程中，链表会出现一长一短的情况，所以在其中一个链表遍历完成之后，他的next就为空了，没有val值 我们可以将后续空的链表的值默认为0，这样在相加的时候就不会对后续没有遍历完的链表产生影响 所以对于t1，t2两个链表而言，他们的当前节点值是多少，可以由如下判断： 12int x = (t1!=null)?t1.val:0;int y = (t2!=null)?t2.val:0; 之后当前的和为sum = (x+y+carry); 判断进位：进位是多少可以由sum/10得到 存储节点：每个节点只能存储1位数字，多出的部分成为进位，所以sum=sum%10，利用哑结点的后一位建立一个新的节点t3.next = new ListNode(sum); 顺序移动t1，t2，t3，其中当t1，t2为空的时候就不再需要移动了，只需要下次用0相加即可 新增进位节点：如果最后遍历完毕仍然有进位，那么尾节点就是最后以进位为值的节点t3.next = new ListNode(carry) 最后返回哑结点的next就是头节点 Java代码123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; if(l1==null) return l2; if(l2==null) return l1; int carry = 0; int sum = 0; ListNode t1 = l1; ListNode t2 = l2; ListNode l3 = new ListNode(0); ListNode t3 = l3; while(t1!=null||t2!=null)&#123; int x = (t1!=null)?t1.val:0; int y = (t2!=null)?t2.val:0; sum = (x+y+carry); carry = sum/10; sum = sum%10; t3.next = new ListNode(sum); if(t1!=null) t1 = t1.next; if(t2!=null) t2 = t2.next; t3 = t3.next; &#125; if(carry&gt;0) t3.next = new ListNode(carry); return l3.next; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-1-两数之和]]></title>
    <url>%2F2020%2F06%2F16%2FLeetCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[LeetCode-1-两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例 1: 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解题思路方法1、暴力破解： 暴力破解就是固定一个往后面挨个找，时间上比较耗时 方法2、哈希表： 暴力破解比较耗时，那么有没有更快的方法，比如一次遍历搞定？ 通过思考可以发现，数字固定一个再往后面找，这种方法不变的是数字，变化的是数字加和的顺序 把数字全部存储起来，并得到target和当前数字的差值，如果这个差值在存储的数字里面，就说明和为target找到了，返回对应下标即可。 于是可以利用hash表存储对应的数字和下标，按照这个思路实现，一次遍历就可以完成target下标和的寻找 Java代码123456789101112131415class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; if(nums.length==0||nums==null) return nums; int sum = 0; for(int i=0;i&lt;nums.length-1;i++)&#123; for(int j=i+1;j&lt;nums.length;j++)&#123; sum = nums[i]+nums[j]; if(sum==target)&#123; return new int[]&#123;i,j&#125;; &#125; &#125; &#125; return new int[]&#123;0&#125;; &#125;&#125; Java代码21234567891011121314class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; if(nums.length==0||nums==null) return nums; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int i=0;i&lt;nums.length;i++)&#123; int out = target-nums[i]; if(map.containsKey(out))&#123; return new int[]&#123;map.get(out),i&#125;; &#125; map.put(nums[i],i); &#125; return new int[]&#123;0&#125;; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Easy</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-107-二叉树的层次遍历2]]></title>
    <url>%2F2020%2F06%2F11%2FLeetCode-107-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%862%2F</url>
    <content type="text"><![CDATA[LeetCode-107-二叉树的层次遍历2给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 示例 1: 给定二叉树 [3,9,20,null,null,15,7] 12345 3 / \9 20 / \ 15 7 返回其自底向上的层次遍历为： 12345[ [15,7], [9,20], [3]] 解题思路BFS层序遍历+头插法： 涉及到要加入数值的，不太好用递归的方法，采用迭代的方法更容易一点 使用queue队列进行层序遍历，每次弹出一个层的节点就将它加入到layer中，一层遍历完了之后 再将一层的结果加入到res的头部，最后返回回来的就是按层倒序的结果 Java代码123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); if(root==null) return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty())&#123; int size = queue.size(); List&lt;Integer&gt; layer = new LinkedList&lt;&gt;(); for(int i=0;i&lt;size;i++)&#123; TreeNode temp = queue.poll(); layer.add(temp.val); if(temp.left!=null)&#123; queue.add(temp.left); &#125; if(temp.right!=null)&#123; queue.add(temp.right); &#125; &#125; res.add(0,layer); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>树</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-104-二叉树的最大深度]]></title>
    <url>%2F2020%2F06%2F11%2FLeetCode-104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[LeetCode-104-二叉树的最大深度给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例 1: 给定二叉树 [3,9,20,null,null,15,7] 12345 3 / \9 20 / \ 15 7 返回它的最大深度 3 。 解题思路方法1、DFS递归： 特例：root为空直接返回0 DFS左子树深度，DFS右子树深度，树的深度=Max(左子树，右子树)+root节点 方法2、Queue迭代： 利用层序遍历的思想，一层一层遍历，每过一层深度+1 利用一个先进先出的Queue队列，先将root节点加入其中，当queue不为空的时候开始遍历 深度+1，弹出队列头部，判断头部的左右节点是否为空，不为空则加入其中 对于一层的节点，节点数为queue.size()，对于queue中的每个节点都需要进行左右节点的判断 当一层遍历完毕时，深度就+1 Java代码1234567891011121314151617/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int maxDepth(TreeNode root) &#123; if(root==null) return 0; int left = maxDepth(root.left); int right = maxDepth(root.right); return Math.max(left,right)+1; &#125;&#125; Java代码2(迭代Queue)12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int maxDepth(TreeNode root) &#123; if(root==null) return 0; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); int depth=0; while(!queue.isEmpty())&#123; depth++; int size = queue.size(); for(int i=0;i&lt;size;i++)&#123; TreeNode temp = queue.poll(); if(temp.left!=null)&#123; queue.add(temp.left); &#125; if(temp.right!=null)&#123; queue.add(temp.right); &#125; &#125; &#125; return depth; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>树</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-1367-二叉树中的列表]]></title>
    <url>%2F2020%2F06%2F11%2FLeetCode-1367-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[LeetCode-1367-二叉树中的列表给你一棵以 root 为根的二叉树和一个 head 为第一个节点的链表。 如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以 head 为首的链表中每个节点的值，那么请你返回 True ，否则返回 False 。 一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。 示例 1: 123输入：head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]输出：true解释：树中蓝色的节点构成了与链表对应的子路径。 示例 2: 12输入：head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]输出：true 示例3： 123输入：head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]输出：false解释：二叉树中不存在一一对应链表的路径。 提示: 二叉树和链表中的每个节点的值都满足 1 &lt;= node.val &lt;= 100 。 链表包含的节点数目在 1 到 100 之间。 二叉树包含的节点数目在 1 到 2500 之间。 解题思路DFS递归： 根据题意知道，head的长度&lt;=root 我们可以设计一个递归函数，如果head==null说明匹配完成，返回true，如果root==null则说明找完了也没有匹配上 首先开启root节点的递归，判断开始的路径是否和head匹配，如果匹配则进一步看是这个节点的左子树匹配？还是这个节点的右子树匹配。任意一个子树匹配成功则算匹配成功。 如果root节点匹配失败，那么需要看root节点的左子树或者root节点的右子树是否能够匹配，分别开启DFS遍历，左右子树应该和root节点进行一样的匹配，同样需要看左子节点的左右节点和右子节点的左右节点到底是哪一个匹配的 当根节点或者左右子树任意一个匹配成功，则说明包含路径，即dfs(head,root)||isSubPath(head,root.left)||isSubPath(head,root.right) Java代码123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; *//** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isSubPath(ListNode head, TreeNode root) &#123; if(head==null) return true; if(root==null) return false; // 先判断当前的节点，如果不对，就看看左子树和右子树 return dfs(head,root)||isSubPath(head,root.left)||isSubPath(head,root.right); &#125; public boolean dfs(ListNode head,TreeNode root)&#123; // 如果链表没了，那就说明匹配完了 if(head==null) return true; // 如果链表没完，树走完了，那就是没匹配上 if(root==null) return false; // 如果值不同，那肯定也是没匹配上 if(head.val!=root.val) return false; // 如果值相同，就继续看看左边右边是不是有相同的 return dfs(head.next,root.left)||dfs(head.next,root.right); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>树</tag>
        <tag>Medium</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-143-重排链表]]></title>
    <url>%2F2020%2F06%2F10%2FLeetCode-143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[LeetCode-143-重排链表给定一个单链表 L：L0→L1→…→Ln-1→Ln ，将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→… 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例1： 1给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3. 示例2： 1给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3. 解题思路方法1、存储+双指针： 用一个线性表存储所有的链表元素，之后用2个指针，分别获得链表的头尾 按照规律对于1，2，3，4这样的链表例子 1之后是4，4之后是2，2之后是3 初始化头尾指针，改变头部指针的指向到尾部，并使i指向下一位 即list.get(i).next = list.get(j);和i++ 改变尾部指针指向到原本头部的下一位，由于上面已经i++，此时线性表的i就是上一次i的下一位 所以list.get(j).next = list.get(i);，之后j-- 直到i==j时跳出循环，此时i仍然与原来的链表相连，将i.next=null完成链表构建 方法2、拆分+翻转+拼接： 这个解法复习的内容挺多的，按照题目规律，重排链表可以分为如下3个步骤 12345678910111 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6第一步，将链表平均分成两半1 -&gt; 2 -&gt; 34 -&gt; 5 -&gt; 6 第二步，将第二个链表逆序1 -&gt; 2 -&gt; 36 -&gt; 5 -&gt; 4 第三步，依次连接两个链表1 -&gt; 6 -&gt; 2 -&gt; 5 -&gt; 3 -&gt; 4 如何拆分链表，最重要的是找到拆分的中点 对于偶数链表，拆分的中点在边界左边，对于奇数链表，中点就是中间的那个 可以利用快慢指针来寻找中点，一个指针走2步，一个指针走1步，当快指针走到链表尾部的时候，慢指针的位置就是拆分的中点，由于奇数和偶数拆分点不一样，所以ListNode newHead = slow.next;和slow.next = null;在找到边界点之后，始终后移1位，这样保证了偶数情况下，拆分点始终是第二个链表的头部 但是对于奇数情况，则会让第一个链表始终比第二个链表多一个数字，这种情况在合并的时候进行处理。 链表的逆序思想和LeetCode-面试题24-反转链表相同 链表的合并思想和LeetCode-面试题25-合并两个排序的链表大致相同 稍微有点区别的地方是这里不是按照值进行合并 1234567对于slow 1 -&gt; 2 -&gt; 3fast 4 -&gt; 5而言，应该先存储slow和fast的next节点之后将slow的next变为fast，即1 -&gt; 4fast的next = 刚才存储的slow.next，即4 -&gt; 2接下来移动1位slow和fast指针，即slow = 刚才存储的slow.next，fast = 刚才存储的fast.next 而此时的第一个链表由于始终比第二个链表长，所以判断空的条件为slow!=null&amp;&amp;fast!=null，当满足此条件时，才会进行V字型拼接 Java代码123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public void reorderList(ListNode head) &#123; if (head == null) &#123; return; &#125; //存到 list 中去 List&lt;ListNode&gt; list = new ArrayList&lt;&gt;(); while (head != null) &#123; list.add(head); head = head.next; &#125; //头尾指针依次取元素 int i = 0, j = list.size() - 1; while (i &lt; j) &#123; list.get(i).next = list.get(j); i++; //偶数个节点的情况，会提前相遇 if (i == j) &#123; break; &#125; list.get(j).next = list.get(i); j--; &#125; list.get(i).next = null; &#125;&#125; Java代码2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public void reorderList(ListNode head) &#123; if (head == null || head.next == null || head.next.next == null) &#123; return; &#125; ListNode slow = head; ListNode fast = head; while(fast!=null&amp;&amp;fast.next!=null)&#123; slow = slow.next; fast = fast.next.next; &#125; ListNode newHead = slow.next; slow.next = null; fast = reversList(newHead); slow = head; while(slow!=null&amp;&amp;fast!=null)&#123; ListNode stemp = slow.next; ListNode ftemp = fast.next; slow.next = fast; fast.next = stemp; slow = stemp; fast = ftemp; &#125; &#125; public ListNode reversList(ListNode head)&#123; if(head==null||head.next==null) return head; ListNode pre = null; ListNode cur = head; while(cur!=null)&#123; ListNode temp = cur.next; cur.next = pre; pre = cur; cur = temp; &#125; return pre; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-142-环形链表2]]></title>
    <url>%2F2020%2F06%2F10%2FLeetCode-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A82%2F</url>
    <content type="text"><![CDATA[LeetCode-142-环形链表2给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 说明：不允许修改给定的链表。 示例1： 123输入：head = [3,2,0,-4], pos = 1输出：tail connects to node index 1解释：链表中有一个环，其尾部连接到第二个节点。 示例2： 123输入：head = [1,2], pos = 0输出：tail connects to node index 0解释：链表中有一个环，其尾部连接到第一个节点。 示例3： 123输入：head = [1], pos = -1输出：no cycle解释：链表中没有环。 进阶：你是否可以不用额外空间解决此题？ 解题思路相关链接： LeetCode-141-环形链表 LeetCode-面试题02.02-返回倒数第k个节点 快慢指针+双指针： 想要在环形链表中找到入环的第一个节点，首先要判断是否有环 在有环的前提下，如果能够计算出环内的节点有多少个，那么问题就变为同返回倒数第k个节点相似的问题 让其中一个指针先走n步，之后一个指针第一个指针走完n步之后开始走 两个指针继续移动1步，当第二个指针指向环的入口节点时，第一个指针已经绕了一圈回来到达了入口节点，此时第二个指针的位置就是入口 Java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode detectCycle(ListNode head) &#123; ListNode meetingNode = hasCycle(head); if(meetingNode==null) return null; int n = 1; ListNode temp = meetingNode; while(temp.next!=meetingNode)&#123; temp = temp.next; n++; &#125; ListNode start = head; temp = head; for(int i=0;i&lt;n;i++)&#123; temp = temp.next; &#125; while(temp!=start)&#123; temp = temp.next; start = start.next; &#125; return start; &#125; public ListNode hasCycle(ListNode head) &#123; if(head==null) return null; ListNode slow = head.next; if(slow==null) return null; ListNode fast = slow.next; while(fast!=null&amp;&amp;slow!=null)&#123; if(fast==slow) return fast; slow = slow.next; fast = fast.next; if(fast!=null)&#123; fast = fast.next; &#125; &#125; return null; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-141-环形链表]]></title>
    <url>%2F2020%2F06%2F10%2FLeetCode-141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[LeetCode-141-环形链表给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例1： 123输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例2： 123输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 示例3： 123输入：head = [1], pos = -1输出：false解释：链表中没有环。 进阶： 你能用 O(1)（即，常量）内存解决此问题吗？ 解题思路快慢指针： 要找到一个链表有没有环，可以通过设置快慢指针的方式 如果快的指针赶上了慢的指针说明链表中有环，如果不存在环那么其中一个指针必定会等于null 初始化慢指针slow=head.next，如果他等于null说明链表只有一个节点，不存在环，返回false 初始化快指针fast=slow.next，当快慢指针都不为空的时候，判断是否相等，相等则有环 如果不相等，则移动慢指针1步，移动快指针2步，但快指针移动一步之后需要判断是否为null，不为null才能移动第二步，否则没有环，跳出循环返回false Java代码12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public boolean hasCycle(ListNode head) &#123; if(head==null) return false; ListNode slow = head.next; if(slow==null) return false; ListNode fast = slow.next; while(fast!=null&amp;&amp;slow!=null)&#123; if(fast==slow) return true; slow = slow.next; fast = fast.next; if(fast!=null)&#123; fast = fast.next; &#125; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题02.02-返回倒数第k个节点]]></title>
    <url>%2F2020%2F06%2F10%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9802.02-%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题02.02-返回倒数第k个节点实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。 注意：本题相对原题稍作改动 示例 1: 12输入： 1-&gt;2-&gt;3-&gt;4-&gt;5 和 k = 2输出： 4 说明： 给定的 k 保证是有效的。 解题思路双指针： 根据链表的性质，要获得倒数第k个节点，就等于求n-(k-1)个节点， 但这需要知道链表的长度，意味着需要两次遍历链表。 换一种想法，想要知道倒数第k个节点，那么就让一个指针先走k-1步，另外一个指针始终和第一个指针保持k-1的距离 当第一个指针到达链表结尾时，第二个指针则正好在n-(k-1)的位置，只需要一次遍历即可完成 Java代码123456789101112131415161718192021222324/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int kthToLast(ListNode head, int k) &#123; if(head==null) return 0; ListNode fast = head; ListNode low = null; for(int i=0;i&lt;k-1;i++)&#123; fast = fast.next; &#125; low = head; while(fast.next!=null)&#123; fast = fast.next; low = low.next; &#125; return low.val; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-328-奇偶链表]]></title>
    <url>%2F2020%2F06%2F10%2FLeetCode-328-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[LeetCode-328-奇偶链表给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。 请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。 示例 1: 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL 示例2： 12输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL 输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL 说明: 应当保持奇数节点和偶数节点的相对顺序。 链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。 解题思路双指针： 一个指针指向奇数节点，一个指针指向偶数节点 间隔遍历，奇数指针只能指向奇数节点，偶数指针只能指向偶数节点 对于链表长度为奇数时，奇数指针one能够指向之后一个数字，此时偶数指针two==null，作为循环结束条件 对于链表长度为偶数时，奇数指针one会在之前遍历完毕奇数位置，此时偶数指针two.next==null，作为循环结束条件 最后进行奇偶链表拼接，one.next=tempTwo 注意：间隔遍历很重要，如果按照顺序遍历，会出现one和two指针在奇偶长度的指向不一样，即one和two在快到链表末尾时候，可能指向的奇数链表也可能指向的偶数链表，这样就无法进行最后指针拼接的判断了，间隔遍历保证了指针的奇偶性 Java代码1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode oddEvenList(ListNode head) &#123; if(head==null) return head; ListNode one = head; ListNode two = head.next; ListNode tempTwo = two; while(two!=null&amp;&amp;two.next!=null)&#123; one.next = two.next; one = one.next; two.next = one.next; two = two.next; &#125; one.next = tempTwo; return head; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-300-最长上升子序列]]></title>
    <url>%2F2020%2F06%2F09%2FLeetCode-300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[LeetCode-300-最长上升子序列给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例 1: 123输入: [10,9,2,5,3,7,101,18]输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。 说明: 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。你算法的时间复杂度应该为 O(n2) 。进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗? 解题思路动态规划： 子序列严格上升，不存在中间数字相等的情况，且不要求序列连续 状态定义为：第i个数字为结尾的最长上升子序列的长度，自身也需要统计在其中，每个位置的初始化长度为1 状态转移方程：遍历到索引是i的数字的时候，需要看i前面的i-1个数字是否小于当前的nums[i]的值，如果小于则可以构成一个更长的子序列，但i-1个数字中比nums[i]小的数字有多个，所以dp[i]位置的子序列长度，应该是前面i-1个数字的最长的那个加上1，即dp[i] = Math.max(dp[j]+1,dp[i]) 外层循环到len，控制dp[i]每个位置的初始化为1 内层循环到i，查看从数组开头到i-1个数，最长的子序列分别是多少 最后dp数组中的最大值，就是最长上升子序列的长度 贪心+二分查找： 实在是想不到这种解法….原题题解出处 Java代码12345678910111213141516171819class Solution &#123; public int lengthOfLIS(int[] nums) &#123; int len = nums.length; if(len&lt;2) return len; int[] dp = new int[len]; int res = 1; for(int i=0;i&lt;len;i++)&#123; dp[i]=1; // 看前面i-1个数字 for(int j=0;j&lt;i;j++)&#123; if(nums[j]&lt;nums[i])&#123; //可以构成更长的子序列，所以dp[j]+1 dp[i] = Math.max(dp[j]+1,dp[i]); &#125; &#125; if(res&lt;dp[i]) res=dp[i]; &#125; return res; &#125;&#125; Java代码212345678910111213141516171819202122232425class Solution &#123; public int lengthOfLIS(int[] nums) &#123; int len = nums.length; if(len&lt;2) return len; int[] dp = new int[nums.length]; int maxL = 0; for(int num:nums)&#123; int low = 0; int high = maxL; while(low&lt;high)&#123; int mid = low+(high-low)/2; if(dp[mid]&lt;num)&#123; low = mid+1; &#125; else&#123; high = mid; &#125; &#125; dp[low]=num; if(low==maxL) maxL++; &#125; return maxL; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-47-全排列2]]></title>
    <url>%2F2020%2F06%2F09%2FLeetCode-47-%E5%85%A8%E6%8E%92%E5%88%972%2F</url>
    <content type="text"><![CDATA[LeetCode-47-全排列2给定一个可包含重复数字的序列，返回所有不重复的全排列。 示例 1: 1234567输入: [1,1,2]输出:[ [1,1,2], [1,2,1], [2,1,1]] 解题思路回溯+剪枝： 基于46题LeetCode-46-全排列 对于刚开始就有重复的数字序列，首先先对数组排序，保证数据有序 之后构建递归树，因为返回的结果中不能包含重复的排列，所以在如数组1、1、2的排列过程中 选择第一个1开头和选择第二个1开头的序列将会重复，所以说需要对第二个1开头的所有序列进行剪枝 对应条件为nums[i]==num[i-1]，即第二个1等于第一个1时 同时需要考虑仅在第一个1的排列选择完毕之后回退到空path的时候，才进行第二个1的剪枝。此时判断的依据是上一个nums[i-1]刚刚在回溯的过程中被撤销选择。 对于其他可能重复的位置，如2，1，1。开头2、1都相同于是后续的排列也是重复的，上述的剪枝方法同样适用 Java代码123456789101112131415161718192021222324252627282930class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; int len = nums.length; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (len == 0) return res; Arrays.sort(nums); boolean[] visited = new boolean[len]; List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); dfs(nums, len, 0, path, visited, res); return res; &#125; public void dfs(int[] nums,int len,int depth,List&lt;Integer&gt; path,boolean[] visited,List&lt;List&lt;Integer&gt;&gt; res)&#123; if(len==depth)&#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; for(int i=0;i&lt;len;i++)&#123; if(!visited[i])&#123; // visited[i-1]是因为nums[i-1]在回退的过程中刚刚被撤销选择 if(i&gt;0&amp;&amp;nums[i]==nums[i-1]&amp;&amp;visited[i-1]==false) continue; visited[i] = true; path.add(nums[i]); dfs(nums,len,depth+1,path,visited,res); visited[i] = false; path.remove(path.size()-1); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-46-全排列]]></title>
    <url>%2F2020%2F06%2F08%2FLeetCode-46-%E5%85%A8%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[LeetCode-46-全排列给定一个 没有重复 数字的序列，返回其所有可能的全排列。 示例 1: 12345678910输入: [1,2,3]输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 解题思路方法1、回溯： 回溯问题经常会涉及到一个状态数组 基本的思路想象成一个树的问题，是从一个数字(外层循环分别固定1，2，3数字)出发，往树的更深处遍历 如果当前位置没有访问过，就将这个数加入到路径中，之后开启更深一层的遍历 如果路径的长度等于了初始的数组长度，说明找到了一个可能的排列 如果走到最后没有找到这样的排列路径，则说明此路不同进行回溯操作，将访问的位置状态还原，并同时移除还原路上已经添加的数字 Java代码1234567891011121314151617181920212223242526272829class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; int len = nums.length; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(len==0) return res; boolean[] visited = new boolean[len]; List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); dfs(nums,len,0,path,visited,res); return res; &#125; public void dfs(int[] nums, int len, int depth, List&lt;Integer&gt; path, boolean[] visited, List&lt;List&lt;Integer&gt;&gt; res)&#123; if(len==depth)&#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; for(int i=0;i&lt;len;i++)&#123; if(!visited[i])&#123; path.add(nums[i]); visited[i] = true; dfs(nums,len,depth+1,path,visited,res); visited[i] = false; path.remove(path.size()-1); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-51-N皇后]]></title>
    <url>%2F2020%2F06%2F08%2FLeetCode-51-N%E7%9A%87%E5%90%8E%2F</url>
    <content type="text"><![CDATA[LeetCode-51-N皇后n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。 每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。 示例 1: 12345678910111213输入: 4输出: [ [&quot;.Q..&quot;, // 解法 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // 解法 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]]解释: 4 皇后问题存在两个不同的解法。 提示： 皇后，是国际象棋中的棋子，意味着国王的妻子。皇后只做一件事，那就是“吃子”。当她遇见可以吃的棋子时，就迅速冲上去吃掉棋子。当然，她横、竖、斜都可走一到七步，可进可退。（引用自 百度百科 - 皇后 ） 解题思路回溯方法引用与LeetCode官方 方法1、回溯： 在建立算法之前，我们来考虑两个有用的细节。 一行只可能有一个皇后且一列也只可能有一个皇后。 这意味着没有必要再棋盘上考虑所有的方格。只需要按列循环即可。 对于所有的主对角线有 行号 + 列号 = 常数，对于所有的次对角线有 行号 - 列号 = 常数. 这可以让我们标记已经在攻击范围下的对角线并且检查一个方格 (行号, 列号) 是否处在攻击位置。 121、一行一个皇后2、每个皇后的左上方向没有其他皇后，每个皇后的上方没有其他皇后，每个皇后的右上方向没有皇后 现在已经可以写回溯函数 backtrack(row = 0). 从第一个 row = 0 开始. 循环列并且试图在每个 column 中放置皇后. 如果方格 (row, column) 不在攻击范围内 在 (row, column) 方格上放置皇后。 排除对应行，列和两个对角线的位置。 If 所有的行被考虑过，row == N 意味着我们找到了一个解 Else 继续考虑接下来的皇后放置 backtrack(row + 1). 回溯：将在 (row, column) 方格的皇后移除. Java代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394class Solution &#123; private List&lt;List&lt;String&gt;&gt; output = new ArrayList&lt;&gt;(); // 用于标记是否被列方向的皇后攻击 int[] rows; // 用于标记是否被主对角线方向的皇后攻击 int[] mains; // 用于标记是否被次对角线方向的皇后攻击 int[] secondary; // 用于存储皇后放置的位置 int[] queens; int n; public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; // 初始化 rows = new int[n]; mains = new int[2*n-1]; secondary = new int[2*n-1]; queens = new int[n]; this.n = n; // 从第一行开始回溯求解N皇后 backtrack(0); return output; &#125; // 在一行中放置一个皇后 private void backtrack(int row)&#123; if(row&gt;=n) return; // 分别尝试在row行中的每一列都放置一个皇后 for(int col=0;col&lt;n;col++)&#123; // 判断当前放置的皇后不被其他皇后攻击 if(isNotUnderAttack(row,col))&#123; // 选择，在当前的位置上放置皇后 placeQueen(row,col); // 当前行是最后一行，则找到了一个解决方案 if(row==n-1) addSolution(); // 在下一行中放置皇后 backtrack(row+1); // 回溯，将当前位置的皇后去掉 removeQueen(row,col); &#125; &#125; &#125; // 判断row行，col列这个位置有没有被其他方向的皇后攻击 private boolean isNotUnderAttack(int row,int col)&#123; // 判断的逻辑是： // 1. 当前位置的这一列方向没有皇后攻击 // 2. 当前位置的主对角线方向没有皇后攻击 // 3. 当前位置的次对角线方向没有皇后攻击 int res = rows[col]+mains[row-col+n-1]+secondary[row+col]; // 如果三个方向都没有攻击的话，则res=0 return res == 0; &#125; // 在指定的位置上放置皇后 private void placeQueen(int row,int col)&#123; // 在row行，col列放置皇后 queens[row] = col; // 当前位置的列方向已经有皇后了 rows[col] = 1; // 当前位置的主对角线方向已经有皇后了 mains[row-col+n-1] = 1; // 当前位置的次对角线方向已经有皇后了 secondary[row+col] = 1; &#125; // 移除指定位置上的皇后 private void removeQueen(int row,int col)&#123; // 移除row行上的皇后 queens[row] = 0; // 当前位置的列方向没有皇后了 rows[col] = 0; // 当前位置的主对角线方向没有皇后了 mains[row-col+n-1] = 0; // 当前位置的次对角线方向没有皇后了 secondary[row+col] = 0; &#125; // 将满足条件的皇后位置放入output中 public void addSolution()&#123; List&lt;String&gt; Solution = new ArrayList&lt;String&gt;(); for(int i=0;i&lt;n;i++)&#123; int col = queens[i]; StringBuilder sb = new StringBuilder(); for(int j=0;j&lt;col;j++) sb.append("."); sb.append("Q"); for(int j=0;j&lt;n-col-1;j++) sb.append("."); Solution.add(sb.toString()); &#125; output.add(Solution); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Hard</tag>
        <tag>矩阵</tag>
        <tag>回溯</tag>
        <tag>二维数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-23-合并K个排序链表]]></title>
    <url>%2F2020%2F06%2F07%2FLeetCode-23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[LeetCode-23-合并K个排序链表合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 示例 1: 1234567输入:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 解题思路相关链接： LeetCode-21-合并两个有序链表 方法1、分治+递归+自底向上： 利用了归并排序分治的思想，对于一组链表，如果能够将每个链表两两拆分，那么问题就会简化为对两个链表的合并，合并之后的两两链表变为一个链表，再和另外一组已经合并成一个的链表合并，这个是自底向上的过程。 两个链表的合并过程与LeetCode21一致，所以本题只需要研究如何进行链表划分，并判断返回条件 返回条件： 当链表长度为空，返回null； 当链表长度为1，返回list[0]; 当链表长度为2，需要返回两个链表的合并 链表划分： 直接进行二分即可，mid左边的给l1数组，用于存储左边的一组链表；mid右边的给l2数组，用于存储右边的一组链表 开启递归： 拆分左边的多组链表，并进行合并； 拆分右边的多组链表，并进行合并； 返回：最后的左右链表的合并 方法2、顺序遍历： 这种方法就是暴力破解，一个一个遍历链表组中的链表，然后进行合并即可，最终返回的就是顺序排序的合并链表 方法3、优先队列： 前提知识： 优先队列本身由最小堆实现，对于基础类型不需要重写Comparator接口，就可以实现默认加入数据之后队列是从小到大排序。在本题中，需要将链表从小到大的放入优先队列中，链表不是基础类型，所以需要重写Comparator接口将原本的v1.compareTo(v2)比较转化为v1.val和v2.val分别代表链表中的头结点值。这里采用匿名函数的实现方式 在Comparator接口中，排序的判断依据如下： 如果v1&gt;v2，return 1 如果v1&lt;v2，return -1 如果v1==v2，return 0 题目思路： 将所有链表的头结点放进去，由于是最小堆，所以每次就让队列中最小的出队，操作为pq.poll()，之后让出队的节点的下一个节点入队，再出队优先队列中的最小值，直到队列为空 Java代码123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; if(lists.length == 0) return null; if(lists.length == 1) return lists[0]; if(lists.length == 2) return mergeTwoLists(lists[0],lists[1]); int mid = lists.length/2; ListNode[] l1 = new ListNode[mid]; for(int i=0;i&lt;mid;i++)&#123; l1[i] = lists[i]; &#125; ListNode[] l2 = new ListNode[lists.length-mid]; for(int i=mid,j=0;i&lt;lists.length;i++,j++)&#123; l2[j] = lists[i]; &#125; return mergeTwoLists(mergeKLists(l1),mergeKLists(l2)); &#125; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1==null) return l2; if(l2==null) return l1; ListNode mergehead = null; if(l1.val&lt;l2.val)&#123; mergehead = l1; mergehead.next = mergeTwoLists(l1.next,l2); &#125;else&#123; mergehead = l2; mergehead.next = mergeTwoLists(l1,l2.next); &#125; return mergehead; &#125;&#125; Java代码212345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; ListNode res = null; for(int i=0;i&lt;lists.length;i++)&#123; res = mergeTwoLists(res,lists[i]); &#125; return res; &#125; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1==null) return l2; if(l2==null) return l1; ListNode mergehead = null; if(l1.val&lt;l2.val)&#123; mergehead = l1; mergehead.next = mergeTwoLists(l1.next,l2); &#125;else&#123; mergehead = l2; mergehead.next = mergeTwoLists(l1,l2.next); &#125; return mergehead; &#125;&#125; Java代码31234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; if(lists.length==0) return null; Queue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;((v1, v2) -&gt; v1.val - v2.val); ListNode head = new ListNode(0); ListNode cur = head; for(ListNode list:lists)&#123; if(list!=null) pq.offer(list); &#125; while(!pq.isEmpty())&#123; ListNode minNode = pq.poll(); cur.next = minNode; cur = cur.next; if(minNode.next!=null)&#123; pq.offer(minNode.next); &#125; &#125; return head.next; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Hard</tag>
        <tag>链表</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-21-合并两个有序链表]]></title>
    <url>%2F2020%2F06%2F07%2FLeetCode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[LeetCode-21-合并两个有序链表将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例 1: 12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 解题思路方法一、递归： 首先，两个链表存在长短不一致的情况 递归终止条件：当链表1为空时，合并的链表为链表2；当链表2为空时，合并的链表为链表1 之后，链表需要从小到大的有序合并 新增一个合并后链表的头部指针，判断l1和l2的链表的当前位置值谁更小，小的加入到合并链表中，之后合并链表的next就是剩下的两个链表中的最小值。 最后返回合并链表头部 方法二、迭代： 迭代的思路大致和递归一样，但需要一个新的指针，pre记录当前位置的前一个元素，并不断调整他的next指向构建整个合并链表，phead负责合并链表的头部。 如果l1.val&lt;l2.val则，把l1接在pre的后面，同时l1指针向后移动1位。否则就对l2做相同操作 不管将l1和l2中的哪个元素接在了pre后面，pre指针始终需要向后移动1位，因为接了之后next就不为空了，需要移动到下一位继续构建链表 在循环终止的时候，l1和l2可能出现长短不一的情况，至多会有一个是非空的，由于输入的链表都是有序的，所以不管是哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的元素要大，此时只需要将剩下的链表接在pre.next，之后返回合并链表的头部即可 Java代码12345678910111213141516171819202122232425/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1==null) return l2; if(l2==null) return l1; ListNode mergehead = null; if(l1.val&lt;l2.val)&#123; mergehead = l1; mergehead.next = mergeTwoLists(l1.next,l2); &#125;else&#123; mergehead = l2; mergehead.next = mergeTwoLists(l1,l2.next); &#125; return mergehead; &#125;&#125; Python代码12345678910111213141516# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode: if not l1: return l2 if not l2: return l1 if l1.val&lt;l2.val: mergeHead = l1 mergeHead.next = self.mergeTwoLists(l1.next,l2) else: mergeHead = l2 mergeHead.next = self.mergeTwoLists(l1,l2.next) return mergeHead Java代码212345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1==null) return l2; if(l2==null) return l1; ListNode phead = new ListNode(0); ListNode pre = phead; while(l1!=null&amp;&amp;l2!=null)&#123; if(l1.val&lt;l2.val)&#123; pre.next = l1; l1 = l1.next; &#125;else&#123; pre.next = l2; l2 = l2.next; &#125; pre = pre.next; &#125; if(l1==null) pre.next = l2; if(l2==null) pre.next = l1; return phead.next; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>链表</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-198-打家劫舍]]></title>
    <url>%2F2020%2F06%2F06%2FLeetCode-198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%2F</url>
    <content type="text"><![CDATA[LeetCode-198-打家劫舍你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1: 1234输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例2： 1234输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 提示： 0 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 400 解题思路动态规划： 题目和LeetCode-面试题17.16-按摩师是基本上一样的 dp数组的状态：当前位置前相隔数据的最大值 初始化：dp[0] = nums[0] ,dp[1] = Math.max(nums[0],nums[1]) 转移方程：索引从2开始，由于dp[i-1]存储前面相隔数据的最大值，所以需要比较，当前位置的num[i]和前面间隔位置的数值最大值dp[i-2]之和，与dp[i-1]之间的大小关系，即dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i]) 双指针： 多加一间房子，这个解法是经过分析之后简化的，原文来源这里 Java代码123456789101112131415class Solution &#123; public int rob(int[] nums) &#123; int len = nums.length; if(nums==null||len==0) return 0; if(len&lt;2) return nums[0]; int[] dp = new int[len]; dp[0] = nums[0]; dp[1] = Math.max(nums[0],nums[1]); for(int i=2;i&lt;len;i++)&#123; dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i]); &#125; return dp[len-1]; &#125;&#125; Python代码123456class Solution: def rob(self, nums: List[int]) -&gt; int: cur , pre = 0,0 for i in nums: cur,pre = max(pre+i,cur),cur return cur;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Easy</tag>
        <tag>LeetCode</tag>
        <tag>DP</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题17.16-按摩师]]></title>
    <url>%2F2020%2F06%2F06%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9817.16-%E6%8C%89%E6%91%A9%E5%B8%88%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题17.16-按摩师一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。 注意：本题相对原题稍作改动 示例 1: 123输入： [1,2,3,1]输出： 4解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。 示例2： 123输入： [2,7,9,3,1]输出： 12解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。 示例3： 123输入： [2,1,4,5,3,1,1,3]输出： 12解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。 解题思路动态规划： 看示例1示例2，以为是奇数位置和偶数位置的动态规划，这样就不需要额外的空间….然后发现示例3不是这样的 于是还是老老实实拿个dp数组吧 dp数组的状态：当前位置前相隔数据的最大值 初始化：dp[0] = nums[0] ,dp[1] = Math.max(nums[0],nums[1]) 转移方程：索引从2开始，由于dp[i-1]存储前面相隔数据的最大值，所以需要比较，当前位置的num[i]和前面间隔位置的数值最大值dp[i-2]之和，与dp[i-1]之间的大小关系，即dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i]) Java代码123456789101112131415class Solution &#123; public int massage(int[] nums) &#123; int len = nums.length; if(nums==null||len==0) return 0; if(len&lt;2) return nums[0]; int[] dp = new int[len]; dp[0] = nums[0]; dp[1] = Math.max(nums[0],nums[1]); for(int i=2;i&lt;len;i++)&#123; dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i]); &#125; return dp[len-1]; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Easy</tag>
        <tag>LeetCode</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-121-买卖股票的最佳时机]]></title>
    <url>%2F2020%2F06%2F05%2FLeetCode-121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[LeetCode-121-买卖股票的最佳时机给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。 注意：你不能在买入股票前卖出股票。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例2： 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解题思路方法一、线性遍历(DP思想)： 当利润是负数时，最小数应该变化为当前值，当利润为正数时，max最大利润保存，最后返回最大利润即可 前i天的最大收益= max(前i-1天的最大收益，第i天的价格-前i-1天中的最小价格) Java代码123456789101112131415class Solution &#123; public int maxProfit(int[] prices) &#123; if(prices==null||prices.length==0) return 0; int low = prices[0]; int temp = 0; for(int i=1;i&lt;prices.length;i++)&#123; if(prices[i]-low&lt;0)&#123; low = prices[i]; &#125;else&#123; temp = Math.max(temp,prices[i]-low); &#125; &#125; return temp; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Easy</tag>
        <tag>LeetCode</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-303-区域和检索-数组不可变]]></title>
    <url>%2F2020%2F05%2F31%2FLeetCode-303-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98%2F</url>
    <content type="text"><![CDATA[LeetCode-303-区域和检索-数组不可变给定一个整数数组 nums，求出数组从索引 i 到 j (i ≤ j) 范围内元素的总和，包含 i, j 两点。 示例 1: 12345给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()sumRange(0, 2) -&gt; 1sumRange(2, 5) -&gt; -1sumRange(0, 5) -&gt; -3 说明: 你可以假设数组不可变。 会多次调用 sumRange 方法。 解题思路方法1、DP暴力破解： 显然这个方法可以用一维DP解决 状态：dp[in]代表从i开始到当前位置的元素和 状态转移方程： 当是第一个元素时，直接赋值 当是元素i，且i！=0时，dp[i]由dp[i-1]个元素和决定 需要一个dp数组指针in，线性遍历一次数组，dp数组的最后位置就是元素和 这个方法勉强能通过，但是每次调用都要计算[i,j]范围的和，速度很慢 方法2、缓存： 提前计算出所有范围的累和，能不能计算出第i个元素的和 sum[k]定义为nums[0…k-1]的累和，sum[0]=0 对于上述示例数组sum数组为[0，-2，-2，1，-4，-2，-3] sumrange(i,j)=sum[j+1]-sum[i]，也就是把后面部分的和前去并集部分即可 这种方法只需要计算一次和，之后仅需要从数组取值相减即可得到结果 Java代码1234567891011121314151617181920212223242526class NumArray &#123; private int[] nums; public NumArray(int[] nums) &#123; this.nums = nums; &#125; public int sumRange(int i, int j) &#123; if(nums==null||nums.length==0) return 0; int[] dp = new int[j-i+1]; int in = 0; for(int k=i;k&lt;=j;k++)&#123; if(k==i) dp[in] = this.nums[k]; else dp[in]=dp[in-1]+this.nums[k]; in++; &#125; return dp[in-1]; &#125;&#125;/** * Your NumArray object will be instantiated and called as such: * NumArray obj = new NumArray(nums); * int param_1 = obj.sumRange(i,j); */ Java代码21234567891011121314151617181920class NumArray &#123; private int[] sum; public NumArray(int[] nums) &#123; sum = new int[nums.length + 1]; for (int i = 0; i &lt; nums.length; i++) &#123; sum[i + 1] = sum[i] + nums[i]; &#125; &#125; public int sumRange(int i, int j) &#123; return sum[j + 1] - sum[i]; &#125;&#125;/** * Your NumArray object will be instantiated and called as such: * NumArray obj = new NumArray(nums); * int param_1 = obj.sumRange(i,j); */]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Easy</tag>
        <tag>LeetCode</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-392-判断子序列]]></title>
    <url>%2F2020%2F05%2F30%2FLeetCode-392-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[LeetCode-392-判断子序列给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。 示例 1: 1s = &quot;abc&quot;, t = &quot;ahbgdc&quot; 示例2： 1s = &quot;axc&quot;, t = &quot;ahbgdc&quot; 后续挑战 : 如果有大量输入的 S，称作S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？ 解题思路方法1、顺序遍历： 固定s的第一位找t中有没有这一位，有就移动s指针，并让len++，当len达到slen的时候说明匹配上了 方法2、DP： DP不是很快，主要是为了练手该怎么做，出处来源于这里 状态dp[i][j]为s从头开始到i的子字符串是否是t从头开始到j的子字符串的子序列 状态转移公式： 当char[i]==char[j]时，则字符i一定是j的子序列，如果0~i-1子字符串是0~j-1子字符串的子序列，则dp[i][j]=true，也就是说当前的字符匹配上了，前面的也匹配上了，才是子序列，所以dp[i][j]=dp[i-1][j-1] 当char[i]!=char[j]时，即判断当前0~i子字符串是否是0~j-1的子字符串的子序列，即dp[i][j]=d[i][j-1]。如ab，eabc，虽然s的最后一个字符串和t中的最后一个字符不相等，但是ab是eab的子序列，所以ab也是eabc的子序列 初始化：空字符串一定是t的子字符串的子序列，所以dp[0][j]=true Java代码12345678910111213141516171819class Solution &#123; public boolean isSubsequence(String s, String t) &#123; if (s.length() != 0 &amp;&amp;t.length() == 0) return false; if (s.length()==0&amp;&amp;t.length()!=0) return true; if (s.length()==0&amp;&amp;t.length()==0) return true; int index = 0; int slen = s.length(); int len = 0; for (int i = 0; i &lt; t.length(); i++) &#123; if (s.charAt(index) == (t.charAt(i))) &#123; index++; len++; &#125; if (len == slen) return true; &#125; return false; &#125;&#125; Java代码2123456789101112131415161718192021class Solution &#123; public boolean isSubsequence(String s, String t) &#123; int slen = s.length(),tlen = t.length(); if(slen&gt;tlen) return false; if(slen==0) return true; boolean[][] dp = new boolean[slen+1][tlen+1]; for(int j = 0;j&lt;tlen;j++)&#123; dp[0][j] = true; &#125; for(int i =1;i&lt;=slen;i++)&#123; for(int j =1;j&lt;=tlen;j++)&#123; if(s.charAt(i-1)==t.charAt(j-1))&#123; dp[i][j] = dp[i-1][j-1]; &#125;else&#123; dp[i][j] = dp[i][j-1]; &#125; &#125; &#125; return dp[slen][tlen]; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>LeetCode</tag>
        <tag>字符串</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-53-最大子序和]]></title>
    <url>%2F2020%2F05%2F30%2FLeetCode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%2F</url>
    <content type="text"><![CDATA[LeetCode-53-最大子序和给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例 1: 123输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 解题思路方法1、DP： 当前元素存储前一个元素和当前元素之和与当前元素之间的最大值，每个位置均可以由此规则计算得出，最后返回数组的最大值即可 方法2、贪心： 如果当前元素之前的和小于0，就丢弃之前的数列，即dp[i] = num[i]，如果大于0就累加 方法3、更清楚的版本： 实际上是一样的，只是代码看得清楚点 当前和小于0，就把nums[i]赋值，如果当前值&gt;最大值 交换最大值 Java代码12345678910111213class Solution &#123; public int maxSubArray(int[] nums) &#123; if(nums==null||nums.length==0) return 0; int[] dp = new int[nums.length]; dp[0] = nums[0]; int max = nums[0]; for(int i=1;i&lt;nums.length;i++)&#123; dp[i] = Math.max(nums[i],dp[i-1]+nums[i]); max = Math.max(max,dp[i]); &#125; return max; &#125;&#125; Python代码123456class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: if not nums or len(nums)==0: return 0 for i in range(1,len(nums)): nums[i] = nums[i]+max(nums[i-1],0) return max(nums) Java代码123456789101112131415161718class Solution &#123; public int maxSubArray(int[] nums) &#123; if(nums.length==0||nums==null) return 0; int maxSum = Integer.MIN_VALUE; int curSum = 0; for(int i = 0;i&lt; nums.length;i++)&#123; if(curSum&lt;=0) curSum = nums[i]; else curSum+=nums[i]; if(curSum&gt;maxSum)&#123; maxSum = curSum; &#125; &#125; return maxSum; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>LeetCode</tag>
        <tag>DP</tag>
        <tag>Python</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题68-2-二叉搜索树的最近公共祖先]]></title>
    <url>%2F2020%2F05%2F29%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9868-2-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题68-2-二叉搜索树的最近公共祖先给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] 示例1： 123输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例2： 123输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 说明： 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉树中。 解题思路递归： 如果当前节点为空或者当前节点等于p和q的其中一个，则直接返回root，符合示例2条件 如果当前节点的左右子树分别包括了p和q，那么这个节点就是最近公共祖先root 如果左子树找不到p或者q，则说明p和q都在右子树上，返回right 如果右子树找不到p或者q，则说明p和q都在左子树上，返回left Java代码12345678910111213141516171819/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root==null||root==p||root==q) return root; TreeNode left = lowestCommonAncestor(root.left,p,q); TreeNode right = lowestCommonAncestor(root.right,p,q); if(left==null) return right; if(right==null) return left; return root; &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>剑指Offer</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题68-1-二叉搜索树的最近公共祖先]]></title>
    <url>%2F2020%2F05%2F29%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9868-1-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题68-1-二叉搜索树的最近公共祖先给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] 示例1： 123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例2： 123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 说明： 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉搜索树中。 解题思路方法1、递归： 比较当前的值和传入的2个节点值的大小，根据二叉搜索树的性质，比根节点小的数在左边，比根节点大的数在右边。如果当前值比2个节点值大，则最近的公共祖先应该在左子树 如果当前值比2个节点值小，则最近的公共祖先应该在右子树 如果当前值在2个节点值中间，或者等于2个节点值中的一个，则当前节点就是最近公共祖先 方法2、迭代： 迭代思路与递归类似，只是当找到节点时跳出循环返回即可 Java代码12345678910111213141516171819/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root.val&gt;p.val&amp;&amp;root.val&gt;q.val)&#123; return lowestCommonAncestor(root.left,p,q); &#125;else if(root.val&lt;p.val&amp;&amp;root.val&lt;q.val)&#123; return lowestCommonAncestor(root.right,p,q); &#125; return root; &#125;&#125; Python代码1234567891011121314151617# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode': while root: if root.val&gt;p.val and root.val&gt;q.val: root = root.left elif root.val&lt;p.val and root.val&lt;q.val: root = root.right else: break return root]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题67-把字符串转化成整数]]></title>
    <url>%2F2020%2F05%2F21%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9867-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E6%88%90%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题67-把字符串转化成整数写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 示例1： 12输入: &quot;42&quot;输出: 42 示例2： 1234输入: &quot; -42&quot;输出: -42解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例3： 123输入: &quot;4193 with words&quot;输出: 4193解释: 转换截止于数字 &apos;3&apos; ，因为它的下一个字符不为数字。 示例4： 1234输入: &quot;words and 987&quot;输出: 0解释: 第一个非空字符是 &apos;w&apos;, 但它不是数字或正、负号。 因此无法执行有效的转换。 示例5： 1234输入: &quot;-91283472332&quot;输出: -2147483648解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 解题思路按照题目一步一步来 首先是去掉首尾空格 之后设置一个符号位存储正负，当遇到-号就转化为-1 最重要的一步是边界处理，题目给定的数值范围在INT类型内，如果使用res边加边乘进行判断，当越界时int类型会自己触发保护削减数值，这时候就无法通过与MAX_VALUE和MIN_VALUE比大小判断到底是不是越界了。一种省事的方法是使用long类型的res，但这不符合题意。 我们可以在每一轮数字拼接前判断，当前的值是否超过 2147483647/10，如果超过则下一次拼接10*res必定是越界的。 第二种情况是当前值是2147483647/10，没有发生越界，但拼接后越界了，即当前位置&gt;7越界。 对于上界溢出，判断符号位是否是1，即正数，返回正数最大值；如果是-1，则返回负数最大值 注意：因为这里已经转化为CharArray，所以判断s[i]&gt;’7’不能写成s[i]-‘0’&gt;’7’，这会使ASCALL码减小判断失败 Java代码12345678910111213141516171819202122class Solution &#123; public int strToInt(String str) &#123; char[] s = str.trim().toCharArray(); if (s.length == 0) &#123; return 0; &#125; int sign = 1; int i = 0; int res = 0; int MAX = Integer.MAX_VALUE / 10; if (s[0] == '-') sign = -1; if (s[0] == '+' || s[0] == '-') i++; while (i &lt; s.length &amp;&amp; s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9') &#123; if (res &gt; MAX || res == MAX &amp;&amp; s[i] &gt; '7') &#123; return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE; &#125; res = res * 10 + (s[i] - '0'); i++; &#125; return res * sign; &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Medium</tag>
        <tag>字符串</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题66-构建乘积数组]]></title>
    <url>%2F2020%2F05%2F21%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9866-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题66-构建乘积数组给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。 示例1： 12输入: [1,2,3,4,5]输出: [120,60,40,30,24] 限制： 所有元素乘积之和不会溢出 32 位整数 a.length &lt;= 100000 解题思路将A[0]×A[1]×…×A[i-1]分为一个数组记为C[i]，A[i+1]×…×A[n-1]分为一个数组记为D[i]，数组B可以由这两个数组的乘积得到，把B看成一个矩阵其左对角线为全1，分开上述2个数组 B= \left\{ \begin{array}{c|cccccc} B0&1 & A1 & A2 & ... & An-2 & An-1\\ B1& A0 & 1 & A2 & ...&An-2 & An-1 \\ B2& A0 & A1 & 1 & ...&An-2 & An-1 \\ ...& A0 & A1 & ... & 1 &An-2& An-1 \\ Bn-2& A0 & A1 & ... & An-3&1 & An-1 \\ Bn-1& A0 & A1 & ... & An-3 &An-2& 1 \end{array} \right\}A[0]×A[1]×…×A[i-1]可以自上而下，从左至右的顺序计算得到，对应于C[i] = C[i-1]*A[i-1] A[i+1]×…×A[n-1]可以自下而上，从右至左的顺序计算得到，对应于D[i] = D[i+1]*A[i+1] Java代码123456789101112131415161718class Solution &#123; public int[] constructArr(int[] a) &#123; if(a.length==0) return new int[0]; int[] b = new int[a.length]; b[0]=1; int temp=1; // 循环控制从上至下，累乘从左至右 for(int i=1;i&lt;a.length;i++)&#123; b[i] = b[i-1]*a[i-1]; &#125; // 循环控制从下至上，累乘从右至左 for(int j=a.length-2;j&gt;=0;j--)&#123; temp*=a[j+1]; b[j]*=temp; &#125; return b; &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Easy</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题65-不用加减乘除做加法]]></title>
    <url>%2F2020%2F05%2F20%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9865-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题65-不用加减乘除做加法写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。 示例1： 12输入: a = 1, b = 1输出: 2 限制： a, b 均可能是负数或 0 结果不会溢出 32 位整数 解题思路不能使用加减乘除，就只能用位运算了 按照3步走： 不算进位相加 计算进位 两数相加 其中最后一步可以整合到第一步，不算进位相加符合异或逻辑，进位需要两个位置都为1，其余为0，符合与运算。之后左移一位就是进位位置。当进位不为0时，一直计算直到进位为0得到最后数值 Java代码12345678910111213class Solution &#123; public int add(int a, int b) &#123; int sum = 0; int carry = 0; do&#123; sum = a^b; // 两数相加,且不考虑进位 carry = (a&amp;b)&lt;&lt;1; //得到进位 a = sum; b = carry; &#125;while(b!=0); return a; &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>剑指Offer</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题64-求1+2+...+n]]></title>
    <url>%2F2020%2F05%2F20%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9864-%E6%B1%821%2B2%2B...%2Bn%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题64-求1+2+…+n求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 示例1： 12输入: n = 3输出: 6 示例2: 12输入: n = 9输出: 45 限制： 1 &lt;= n &lt;= 10000 解题思路很多运算不能够使用，这道题主要是考察的，能不能多角度的解决问题 不难想到for循环的方式可以有递归的实现，从n走到1就可以了 然而Python不受本题限制….一行搞定 Java代码123456class Solution &#123; public int sumNums(int n) &#123; if(n==1) return 1; return n+sumNums(n-1); &#125;&#125; Python代码123class Solution: def sumNums(self, n: int) -&gt; int: return sum(range(1,n+1));]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Medium</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题63-股票的最大利润]]></title>
    <url>%2F2020%2F05%2F20%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9863-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题63-股票的最大利润假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？ 示例1： 1234输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例2: 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 限制： 0 &lt;= 数组长度 &lt;= 10^5 解题思路始终记录当前位置前的最小数字，遇到更小的就更新min，之后看当前的最大利润和存储的最大利润谁更大 Java代码12345678910111213141516class Solution &#123; public int maxProfit(int[] prices) &#123; if(prices==null||prices.length&lt;2) return 0; int min = prices[0]; int maxPrice = 0; for(int i=1;i&lt;prices.length;i++)&#123; if(prices[i]&lt;min)&#123; min = prices[i]; &#125;else&#123; maxPrice = Math.max(maxPrice,prices[i]-min); &#125; &#125; return maxPrice; &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Easy</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题62-圆圈中最后剩下的数字]]></title>
    <url>%2F2020%2F05%2F20%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9862-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题62-圆圈中最后剩下的数字0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。 例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。 示例1： 12输入: n = 5, m = 3输出: 3 示例2: 12输入: n = 10, m = 17输出: 2 限制： 1 &lt;= n &lt;= 10^5 1 &lt;= m &lt;= 10^6 解题思路著名的约瑟夫环问题 第一轮[0,1,2,3,4]，删去2 第二轮[3,4,0,1]，删去0 第三轮[1,3,4]，删去4 第四轮[1,3]，删去1 最后一轮得到3，实际上每次删去的都是加粗部分位置，第四轮由于只有2个数，补全成环之后，实际上也是加粗部分位置，如[1,3,1,3] 原始数组是有序递增的，所以下标就是数组值 最后一轮3的下标是0，如果我们能够从最后的数字下标反推回到原始数组，就能找到最终答案 反推的方程，(curIndex+m)%上一轮剩余数字的个数 Java代码12345678910class Solution &#123; public int lastRemaining(int n, int m) &#123; if(n&lt;1||m&lt;1) return -1; int curindex = 0; for(int i=2;i&lt;=n;i++)&#123; curindex = (curindex+m)%i; &#125; return curindex; &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Easy</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题61-扑克牌中的顺子]]></title>
    <url>%2F2020%2F05%2F20%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9861-%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题61-扑克牌中的顺子从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。 示例1： 12输入: [1,2,3,4,5]输出: True 示例2: 12输入: [0,0,1,2,5]输出: True 限制： 数组长度为 5 数组的数取值为 [0, 13] 解题思路先给数组排序，统计0的个数，如果数组欠缺的几个数字个数正好等于0的个数，则数组可以变成连续的 如果从越过0开始的地方，出现两个数值相等，则说明数组不可能连续 Java代码1234567891011121314151617181920212223class Solution &#123; public boolean isStraight(int[] nums) &#123; if(nums==null||nums.length&lt;=0) return false; Arrays.sort(nums); int zeroCount = 0; int gapCount = 0; for(int i=0;i&lt;nums.length;i++)&#123; if(nums[i]==0) zeroCount++; &#125; int start = zeroCount; int end = start+1; while(end&lt;nums.length)&#123; if(nums[start]==nums[end]) return false; gapCount+=nums[end]-nums[start]-1; start=end; end++; &#125; return (gapCount&gt;zeroCount)?false:true; &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Easy</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题60-n个骰子的点数]]></title>
    <url>%2F2020%2F05%2F20%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9860-n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0%20-%20%E5%89%AF%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题60-n个骰子的点数把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。 你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。 示例1： 12输入: 1输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667] 示例2: 12输入: 2输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778] 限制： 1 &lt;= n &lt;= 11 解题思路动态规划： 问题分析 单个骰子可能的数字和是1,2,3,4,5,6 假设有n个骰子，第n个骰子数字和值域为[n,6n] n个骰子的所有排列组合次数为6^n 输出的概率就是各个数字和次数/6^n 使用一个二维数组来记录，第i个骰子的，数字和j出现的次数 第1维表示第几个骰子，第2维表示各个点数出现的次数 第1个骰子，其可能的数字和为1,2,3,4,5,6；数组中第2维存储出现的次数即1,1,1,1,1,1 第2个骰子，其可能的数字和为2-12，而2-12的数值由2组1-6分别累加而成，对于数字和7其出现的次数是6种，数字和8出现5种……数字和12出现1种 第2个骰子的数字和可以由第1个骰子数字和组合得到，相应的j次数，就是组合位置次数相加 可以得出投掷第i个骰子后，数字和j出现的次数，可以通过第n-1个骰子，对应点数j-1,j-2,j-3,…,j-6出现的次数之和转化得到，即第2个骰子的7,8,9,10,11,12可以由第1个骰子的1,2,3,4,5,6出现的次数转化得到 由于求解第2个骰子数字和次数基于第1个骰子和次数，所以可以使用动态规划，每多一个骰子就会多出6个数字和 状态转移方程 123for(int i=1;i&lt;=6;i++)&#123; dp[i][j]+=dp[i-1][j-i]&#125; Java代码123456789101112131415161718192021222324252627282930class Solution &#123; public double[] twoSum(int n) &#123; if(n&lt;1) return new double[]&#123;0.0&#125;; // 第一维表示n个骰子，第二维表示可能的数字和出现的次数 int[][] dp = new int[n+1][6*n+1]; // 初始化第1个骰子，1-6 for(int i=1;i&lt;=6;i++) dp[1][i] = 1; for(int i=2;i&lt;=n;i++)&#123; // 第n个骰子 for(int j=i;j&lt;=6*i;j++)&#123; // 骰子和[n,6n] for(int k=1;k&lt;=6;k++)&#123; // 单个骰子可能的点数 if(j-k&lt;0) break; // 越界跳出 // 第n个骰子的和为j的值出现的次数，可以由n-1个骰子的j-1,j-2,j-3....j-6和当前数值相加得到 // 比如第1个骰子可能的和是1,2,3,4,5,6 // 第2个骰子依然是1,2,3,4,5,6，可能的数字和从2-12 // 出现7的次数是6种,出现8的次数是5种,出现9的次数是4种,出现10的次数是3种 // 出现11的次数是2种,出现12的次数是1种 // 每一个位置j都可以由当前位置前6个出现的次数相加得到 dp[i][j]+=dp[i-1][j-k]; &#125; &#125; &#125; double[] res = new double[6*n-n+1]; double total = Math.pow(6,n); for(int i=n;i&lt;=6*n;i++)&#123; res[i-n] = dp[n][i]/total; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
        <tag>DP</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题59-2-队列的最大值]]></title>
    <url>%2F2020%2F05%2F19%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9859-2-%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题59-2-队列的最大值请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。 若队列为空，pop_front 和 max_value 需要返回 -1 示例1： 1234输入: [&quot;MaxQueue&quot;,&quot;push_back&quot;,&quot;push_back&quot;,&quot;max_value&quot;,&quot;pop_front&quot;,&quot;max_value&quot;][[],[1],[2],[],[],[]]输出: [null,null,null,2,1,2] 示例2: 1234输入: [&quot;MaxQueue&quot;,&quot;pop_front&quot;,&quot;max_value&quot;][[],[],[]]输出: [null,-1,-1] 限制： 1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000 1 &lt;= value &lt;= 10^5 解题思路双队列： 利用一个队列Queue存储原本的数据，一个双端队列Deque存储最大值 两个队列联合实现一个MaxQueue 当新的值大于deque的尾部的值时，小的值都应该从deque尾部删去，添加大的值到尾部；同时queue实现常规的数值添加。这样保证了deque首位始终存储的是当前队列最大值 当需要取得队列中的最大值时，如果deque为空，根据题意返回-1，如果不为空则取得最大值(不从双端队列中删除) 当需要弹出队列首位时，需要判断原本的队列是否为空，为空则返回-1，不为空则需要判断出队的元素是否是当前最大值，如果是最大值，则原本的队列最大值出队了，deque中的最大值自然也不存在了，需要弹出首位。此时返回原本队列的首位即可 Java代码12345678910111213141516171819202122232425262728293031323334353637383940class MaxQueue &#123; Deque&lt;Integer&gt; deque; Queue&lt;Integer&gt; queue; public MaxQueue() &#123; deque = new LinkedList&lt;&gt;(); queue = new LinkedList&lt;&gt;(); &#125; public int max_value() &#123; if(deque.isEmpty()) return -1; return deque.getFirst(); &#125; public void push_back(int value) &#123; // 保证deque里面放的是最大值 while(!deque.isEmpty() &amp;&amp; deque.getLast()&lt;value) deque.removeLast(); deque.addLast(value); queue.offer(value); &#125; public int pop_front() &#123; if(queue.isEmpty()) return -1; // 如果出队的元素是当前最大值，则deque也要出队 int temp = queue.poll(); if(deque.getFirst()==temp) deque.removeFirst(); return temp; &#125;&#125;/** * Your MaxQueue object will be instantiated and called as such: * MaxQueue obj = new MaxQueue(); * int param_1 = obj.max_value(); * obj.push_back(value); * int param_3 = obj.pop_front(); */]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Medium</tag>
        <tag>剑指Offer</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题59-1-滑动窗口的最大值]]></title>
    <url>%2F2020%2F05%2F19%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9859-1-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题59-1-滑动窗口的最大值给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。 示例： 123456789101112输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3输出: [3,3,5,5,6,7] 解释: 滑动窗口的位置 最大值--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 提示： 你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。 解题思路常规的想法是滑动一次窗口遍历一次窗口值，返回最大值，但这样的时间复杂度是O(nk) 双端队列： 把有可能成为滑动窗口最大值的数字存入双端队列中，最大值始终放在队列头部 对于前k个数值，当队列不为空的情况下，如果当前遍历的元素要&gt;=队列尾部元素，则说明队列尾部的值不可能是最大值，弹出队列尾部，添加当前值 对于[k,nums.length]区间的数值，需要判断队列中的值是否仍然在滑动窗口内部，如果不在内部需要弹出队列头部。如果当前遍历的元素要&gt;=队列尾部元素，则说明队列尾部的值不可能是最大值，弹出队列尾部。遍历时恒添加当前元素到末尾。 为了便于判断队列头部是否还在滑动窗口内部，队列存储的并非是真正的元素，而是元素在数组中的下标 Java代码12345678910111213141516171819202122232425262728293031class Solution &#123; public int[] maxSlidingWindow(int[] nums, int k) &#123; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); if (nums.length &gt;= k &amp;&amp; k &gt;= 1) &#123; Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;(); // 前k个 for (int i = 0; i &lt; k; i++) &#123; // 队列不为空，且当前元素&gt;=队列尾部，则尾部不可能是最大值，弹出 while (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.getLast()]) deque.removeLast(); deque.addLast(i); &#125; // k到末尾个 for (int i = k; i &lt; nums.length; i++) &#123; // 添加最大值 res.add(nums[deque.getFirst()]); // 队列不为空，且当前元素&gt;=队列尾部，则尾部不可能是最大值，弹出 while (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.getLast()]) deque.removeLast(); // 判断队列头部是否还在滑动窗口内，如果当前处理元素的下标i减去窗口大小k&gt;=队列头部下标 // 说明头部不在滑动窗口内，需要弹出 if (!deque.isEmpty() &amp;&amp; deque.getFirst() &lt;= (i - k)) deque.removeFirst(); deque.addLast(i); &#125; // 添加最后一个滑动窗口的最大值 res.add(nums[deque.getFirst()]); &#125; return res.stream().mapToInt(Integer::intValue).toArray(); &#125;&#125; Python代码1234567891011121314class Solution: def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]: if not nums or k == 0: return [] deque = collections.deque() for i in range(k): while deque and deque[-1] &lt; nums[i]: deque.pop() deque.append(nums[i]) res = [deque[0]] for i in range(k, len(nums)): if deque[0] == nums[i - k]: deque.popleft() while deque and deque[-1] &lt; nums[i]: deque.pop() deque.append(nums[i]) res.append(deque[0]) return res]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Hard</tag>
        <tag>滑动窗口</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题58-2-左旋转字符串]]></title>
    <url>%2F2020%2F05%2F19%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9858-2-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题58-2-左旋转字符串字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。 示例1： 12输入: s = &quot;abcdefg&quot;, k = 2输出: &quot;cdefgab&quot; 示例 2: 12输入: s = &quot;lrloseumgh&quot;, k = 6输出: &quot;umghlrlose&quot; 限制： 1 &lt;= k &lt; s.length &lt;= 10000 解题思路线性遍历： n已经给出来了，第一部分字符串就是从n到字符末尾，第二部分字符串是从字符开始到n，用StringBuilder添加进去最后转化为String即可 切片： s[n:]+s[:n]搞定 Java代码123456789101112131415class Solution &#123; public String reverseLeftWords(String s, int n) &#123; if(s==null||s.length()&lt;=0) return ""; StringBuilder res = new StringBuilder(); if(s!=null)&#123; for(int i=n;i&lt;s.length();i++)&#123; res.append(s.charAt(i)); &#125; for(int j=0;j&lt;n;j++)&#123; res.append(s.charAt(j)); &#125; &#125; return res.toString(); &#125;&#125; Python代码12345class Solution: def reverseLeftWords(self, s: str, n: int) -&gt; str: if not s: return "" if s: return s[n:]+s[:n]]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>字符串</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题58-1-翻转单词顺序]]></title>
    <url>%2F2020%2F05%2F19%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9858-1-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题58-1-翻转单词顺序输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。 示例1： 12输入: &quot;the sky is blue&quot;输出: &quot;blue is sky the&quot; 示例 2: 123输入: &quot; hello world! &quot;输出: &quot;world! hello&quot;解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 示例3： 123输入: &quot;a good example&quot;输出: &quot;example good a&quot;解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 说明： 无空格字符构成一个单词。 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 解题思路双指针切割交换(Python)： 多余的空格直接用split()函数就能够处理，切分之后，利用双指针不断首尾交换，就能够固定单词，翻转单词位置，之后返回字符串即可，这种方法比较偷懒 双指针记录位置(Java)： 初始化两个指针从数组的末尾开始 当遇到的字符不是空格时，移动start指针，找到单词的开头，然后利用substring方法截取单词 当遇到的字符是空格时，继续移动start指针，找到下一个单词的末尾，将end指针移动到start位置，重复以上步骤即可 Java代码1234567891011121314151617class Solution &#123; public String reverseWords(String s) &#123; s = s.trim(); int start = s.length()-1; int end = start; StringBuilder res = new StringBuilder(); while(start&gt;=0)&#123; while(start&gt;=0&amp;&amp;s.charAt(start)!=' ') start--; res.append(s.substring(start+1,end+1)+" "); while(start&gt;=0&amp;&amp;s.charAt(start)==' ') start--; end=start; &#125; return res.toString().trim(); &#125;&#125; Python代码123456789101112class Solution: def reverseWords(self, s: str) -&gt; str: arr = s.split() start = 0 end = len(arr)-1 while start&lt;end: temp = arr[start] arr[start] = arr[end] arr[end] = temp start+=1 end-=1 return " ".join(arr)]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>字符串</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题57-2-和为s的连续正数序列]]></title>
    <url>%2F2020%2F05%2F19%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9857-2-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题57-2-和为s的连续正数序列输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。 序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。 示例1： 12输入：target = 9输出：[[2,3,4],[4,5]] 示例 2: 12输入：target = 15输出：[[1,2,3,4,5],[4,5,6],[7,8]] 限制： 1 &lt;= target &lt;= 10^5 解题思路滑动窗口： 序列至少包含2个数，窗口从1(small)，2(big)开始，且small指针不会超过中值，简单例子，比如15=8+small，small是不可能比8大的，当small都已经跨过中值，big肯定也比small大，两个的组合不可能得到target，所以small&lt;mid即可 接下来分为3种情况讨论： 当序列和curSum&lt;target时，说明需要扩大窗口，这里恒向右扩大，指针右移big++，当前序列值也需要加上big，curSum+=big 当序列和curSum&gt;target时，说明需要缩小窗口，从最小的值开始缩小，curSum-=small，之后指针左移small— 当序列和curSum==target时，说明序列和满足要求，由于要求二维数组存储，这里新开辟一个big-small+1大小的数组，存储[small,big]范围内的数字，之后添加进res中。之后使big指针右移，curSum+=big，继续下一轮的窗口计算 实际上序列和可以由公式(left+right)*(right-left+1)//2得到，Python代码返回更加轻松 Java代码123456789101112131415161718192021222324252627282930class Solution &#123; public int[][] findContinuousSequence(int target) &#123; int small = 1; int big = 2; int mid = (target+1)/2; int curSum = small+big; List&lt;int[]&gt; res = new ArrayList&lt;&gt;(); while(small&lt;mid)&#123; if(curSum==target)&#123; int[] nums = new int[big-small+1]; int i = 0; for(int k=small;k&lt;=big;k++)&#123; nums[i] = k; i++; &#125; res.add(nums); big++; curSum+=big; &#125; else if(curSum&lt;target)&#123; big++; curSum+=big; &#125;else&#123; curSum-=small; small++; &#125; &#125; return res.toArray(new int[res.size()][]); &#125;&#125; Python代码12345678910111213141516171819class Solution: def findContinuousSequence(self, target: int) -&gt; List[List[int]]: res = [] left,right = 1,2 mid = (target+1)//2 while left&lt;mid: sum = (left+right)*(right-left+1)//2 tlist = [] if sum&lt;target: right+=1 elif sum&gt;target: left+=1 else: for i in range(left,right+1): tlist.append(i) res.append(tlist) left+=1 right+=1 return res]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Easy</tag>
        <tag>Python</tag>
        <tag>滑动窗口</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题57-和为s的两个数字]]></title>
    <url>%2F2020%2F05%2F19%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9857-1-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题57-和为s的两个数字输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。 示例1： 12输入：nums = [2,7,11,15], target = 9输出：[2,7] 或者 [7,2] 示例 2: 12输入：nums = [10,26,30,31,47,60], target = 40输出：[10,30] 或者 [30,10] 限制： 1 &lt;= nums.length &lt;= 10^5 1 &lt;= nums[i] &lt;= 10^6 解题思路查找思想： 一个头指针一个尾指针，在递增排序的数组中， 如果对应位置之和大于target，说明需要取小一点，左移尾指针让数值变小 如果对应位置之和小于target，说明需要取大一点，右移头指针，让数值变大 Java代码1234567891011121314151617class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; if(nums==null||nums.length&lt;=0) return new int[0]; int start = 0; int end = nums.length-1; while(start&lt;end)&#123; if(nums[start]+nums[end]&lt;target) start+=1; else if(nums[start]+nums[end]&gt;target) end-=1; else return new int[]&#123;nums[start],nums[end]&#125;; &#125; return new int[0]; &#125;&#125; Python代码12345678910class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: start,end = 0,len(nums)-1 while start&lt;end: if nums[start]+nums[end]&gt;target: end-=1 elif nums[start]+nums[end]&lt;target: start+=1 else: return nums[start],nums[end] return []]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Easy</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题56-2-数组中数字出现的次数2]]></title>
    <url>%2F2020%2F05%2F18%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9856-2-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B02%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题56-2-数组中数字出现的次数2在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。 示例1： 12输入：nums = [3,4,3,3]输出：4 示例 2: 12输入：nums = [9,1,7,9,7,9,7]输出：1 限制： 1 &lt;= nums.length &lt;= 10000 1 &lt;= nums[i] &lt; 2^31 解题思路方法1、异或运算(单1为1，其余0)： 先对所有数字的各个位求和，求和之后的数字，能够被3整除的，则该位为0，不能够被整除的，则该位为1，之后就能够通过2进制求出对应的数字 方法2、字典： 遇到没在字典的加入，在字典就+1，最后取value为1的key即可 方法3、数组： 先给数组排序，排序之后判断当前位和后面2位是否相等，如果相等则跳过这3位，i+3 如果不相等，则说明当前为就是要找的数字 如果前面都没有找到，则最后一位必定是要找的数字 Java代码1123456789101112131415161718192021222324252627class Solution &#123; public int singleNumber(int[] nums) &#123; if(nums==null||nums.length&lt;=0) return -1; int[] bitSum = new int[32]; // 最高2^31次方数字 for(int i =0;i&lt;nums.length;i++)&#123; int bitMask = 1; // 累加各个位置的二进制表示 // 这里从数组末尾开始，对应二进制最小位 for(int j = 31;j&gt;=0;j--)&#123; int bit = nums[i]&amp;bitMask; if(bit!=0) bitSum[j]+=1; bitMask&lt;&lt;=1; &#125; &#125; int result = 0; // 从数组0位开始，对应于数字的高位，当遍历到余数为1时，res仅为1，比如数字8的二进制为0100 // 从左到右遍历，当遍历到数字1时 // 此时res为1，想要从1变成8，需要向左移动2位，而for循环剩下的次数就是需要&lt;&lt;左移的次数，最后得到res才是正确的 for(int i =0;i&lt;32;i++)&#123; result = result&lt;&lt;1; result+=bitSum[i]%3; &#125; return result; &#125;&#125; Python代码12345678910111213class Solution: def singleNumber(self, nums: List[int]) -&gt; int: if not nums: return -1 dic = &#123;&#125; for i in nums: if i not in dic: dic[i] = 1 else: dic[i] +=1 for i in dic: if dic[i]==1: return i return -1 Java代码21234567891011121314class Solution &#123; public int singleNumber(int[] nums) &#123; if(nums==null||nums.length&lt;=0) return -1; Arrays.sort(nums); for(int i = 0;i&lt;nums.length-3;)&#123; if(nums[i]==nums[i+1]&amp;&amp;nums[i+1]==nums[i+2]) i+=3; else return nums[i]; &#125; return nums[nums.length-1]; &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题56-1-数组中数字出现的次数]]></title>
    <url>%2F2020%2F05%2F18%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9856-1-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B01%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题56-1-数组中数字出现的次数一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 示例1： 12输入：nums = [4,1,4,6]输出：[1,6] 或 [6,1] 示例 2: 12输入：nums = [1,2,10,4,1,4,3,3]输出：[2,10] 或 [10,2] 限制： 2 &lt;= nums.length &lt;= 10000 解题思路异或运算(单1为1，其余0)： 根据异或运算的特点，相同的数字会在异或的时候抵消了，不相同的数字，其不相同的位会被保留 如果数组中有2个数字是不相同的，所以对数组整体异或之后，剩下的数字肯定至少有一位为1 如果能够找到第一个为1的那一位，那么就能够通过判断这一位是否为1，而划分数组为2个子数组 这样问题就分解成了，分别寻找2个子数组中，只出现一次的数字 由于判断位的条件具有二分性，当判断出一个不相同的数字位为1时，另一个数字该位则不为1，于是划分的子数组中自然一个数组会包含一个不相同数字 Java代码12345678910111213141516171819202122232425class Solution &#123; public int[] singleNumbers(int[] nums) &#123; int temp=0; // 数组整体异或 for(int i:nums) temp^=i; // 初始化mask=1 int mask = 1; // 通过mask，判断第一次出现1的位数 while((temp&amp;mask)==0)&#123; mask&lt;&lt;=1; &#125; int num1 = 0; int num2 = 0; for(int j:nums)&#123; // 通过判断1出现的位置和数组元素与运算结果是否为0，来二分数组 if((j&amp;mask)==0)&#123; // 相同的数字会分在一起，但不同的数字会因此隔开 num1^=j; &#125;else&#123; num2^=j; &#125; &#125; return new int[]&#123;num1,num2&#125;; &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题55-2-平衡二叉树]]></title>
    <url>%2F2020%2F05%2F18%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9855-2-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题55-2-平衡二叉树输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。 示例1： 给定二叉树 [3,9,20,null,null,15,7]， 12345 3 / \9 20 / \ 15 7 返回true 。 示例 2: 给定二叉树 [1,2,2,3,3,null,null,4,4] 1234567 1 / \ 2 2 / \ 3 3 / \4 4 返回 false 。 限制： 1 &lt;= 树的结点个数 &lt;= 10000 解题思路方法1、DFS分别求深度： 这种方法就是上一个题的延续了，但是由于需要对每一个节点求对应的左右子树的深度，会造成很多重复计算。这是一个简单的解法但是不是好的解法 方法2、后序遍历+剪枝： 这是一个从底至顶的解法，当节点的左右子树的深度差&lt;=1时，就返回当前子树的深度 当前子树的深度由max(left,right)+1计算得到，如果不满足深度差条件，则说明子树不平衡，直接返回-1 递归的终止条件是，当root为空，说明越过叶子节点，返回深度0 当左右子树的深度不平衡时，即left==-1||right==-1时，提前终止递归进行剪枝，返回-1 Java代码1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isBalanced(TreeNode root) &#123; if(root==null) return true; int nleft = DFS(root.left); int nright = DFS(root.right); int n = Math.abs(nleft-nright); if(n&gt;1) return false; return isBalanced(root.left)&amp;&amp;isBalanced(root.right); &#125; public int DFS(TreeNode root)&#123; if(root==null) return 0; int nleft = DFS(root.left); int nright = DFS(root.right); return Math.max(nleft,nright)+1; &#125;&#125; Python代码123456789101112131415161718# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isBalanced(self, root: TreeNode) -&gt; bool: return self.helper(root)!=-1 def helper(self,root:TreeNode)-&gt; int: if not root: return 0 left = self.helper(root.left) if left==-1: return -1 right = self.helper(root.right) if right==-1: return -1 return max(left,right)+1 if abs(left-right)&lt;=1 else -1]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>树</tag>
        <tag>DFS</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题55-1-二叉树的深度]]></title>
    <url>%2F2020%2F05%2F14%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9855-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题55-1-二叉树的深度输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。 示例1： 给定二叉树 [3,9,20,null,null,15,7]， 12345 3 / \9 20 / \ 15 7 返回它的最大深度 3 。 提示： 节点总数 &lt;= 10000 解题思路方法1、DFS： 既然要求树的深度自然少不了深度优先遍历，通过比较左子树的深度和右子树的深度判断最大深度，之后加上根节点 方法2、BFS： 层序遍历一般也就是广度优先遍历，在原本队列的实现基础上，对一个层进行循环约束即可，每遍历完一层，深度就+1 Java代码123456789101112131415161718/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int maxDepth(TreeNode root) &#123; if(root==null) return 0; int nleft = maxDepth(root.left); int nright = maxDepth(root.right); return Math.max(nleft,nright)+1; &#125;&#125; Python代码123456789101112131415161718192021# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def maxDepth(self, root: TreeNode) -&gt; int: if not root: return 0 queue , depth = [] , 0 queue.append(root) while queue: for i in range(len(queue)): temp = queue.pop(0) if temp.left: queue.append(temp.left) if temp.right: queue.append(temp.right) depth+=1 return depth]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>树</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-145-二叉树的后序遍历]]></title>
    <url>%2F2020%2F05%2F13%2FLeetCode-145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[LeetCode-145-二叉树的后序遍历给定一个二叉树，返回它的 后序 遍历。 相关链接： LeetCode-94-二叉树的中序遍历 LeetCode-144-二叉树的前序遍历 示例 1: 12345678输入: [1,null,2,3] 1 \ 2 / 3 输出: [3,2,1] 解题思路二叉树的遍历问题都有2种解法，一种是递归，一种是迭代 递归：开启左子树递归，开启右子树递归，添加根节点 迭代：后序遍历的方式是左右根，前序遍历是根左右，如果用Stack来实现根左右，那么左边先加入就会后出，右边后加入会先出，于是看似是add(left)之后add(right)，实际上会先访问到right再访问left，从而实现前序遍历得到根右左，即后序遍历的倒序，之后将列表倒序就是后序遍历的结果 迭代模拟：严格按照后序遍历的左右根访问，代码整体与中序遍历很相似，但需要注意其中两个点。 思想来源于这里 第一，stack.peek()只是取出栈顶元素，要和stack.pop()弹出栈顶元素区分开来； 第二，变量last用于保存当前栈顶所弹出的元素，判断 curr.right == last 是为了避免重复访问同一个元素而陷入死循环当中 Java代码(递归)1234567891011121314151617181920212223/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; if(root==null) return res; helper(root); return res; &#125; public void helper(TreeNode root)&#123; if(root==null) return; helper(root.left); helper(root.right); res.add(root.val); &#125;&#125; Java代码(迭代Stack)1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; LinkedList&lt;Integer&gt; res = new LinkedList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); // Stack实现根右左 if(root==null) return res; stack.add(root); while(!stack.isEmpty())&#123; TreeNode temp = stack.pop(); res.addFirst(temp.val); // 添加到头部，实现倒序 if(temp.left!=null) stack.add(temp.left); if(temp.right!=null) stack.add(temp.right); &#125; return res; &#125;&#125; Java代码(迭代模拟)123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode curr = root; TreeNode last = null; while (curr != null || !stack.isEmpty()) &#123; while (curr != null) &#123; stack.push(curr); curr = curr.left; &#125; curr = stack.peek(); if (curr.right == null || curr.right == last) &#123; res.add(curr.val); stack.pop(); last = curr; curr = null; &#125; else &#123; curr = curr.right; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>树</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>树</tag>
        <tag>BFS</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-144-二叉树的前序遍历]]></title>
    <url>%2F2020%2F05%2F13%2FLeetCode-144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[LeetCode-144-二叉树的前序遍历给定一个二叉树，返回它的 前序 遍历。 相关链接： LeetCode-94-二叉树的中序遍历 LeetCode-145-二叉树的后序遍历 示例 1: 12345678输入: [1,null,2,3] 1 \ 2 / 3输出: [1,2,3] 解题思路二叉树的遍历问题都有2种解法，一种是递归，一种是迭代 递归：添加根节点，开启左子树递归，开启右子树递归 迭代：前序遍历一般等同于BFS，一般用Queue来实现，先进先出，层序遍历即可。 不过奇怪的是这个题跑不过测试用例…….只能换成栈来做，也就是调整一下加入顺序，需要先添加右子树，再添加左子树，由于pop是后进先出，所以弹出的顺序变为了先弹出左子树，再是右子树，变成了Queue的先进先出的样子 Java代码(递归)123456789101112131415161718192021222324/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; if(root==null) return res; BFS(root); return res; &#125; public void BFS(TreeNode root)&#123; if(root!=null)&#123; res.add(root.val); BFS(root.left); BFS(root.right); &#125; &#125;&#125; Java代码(迭代Queue)1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root==null) return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty())&#123; TreeNode temp = queue.poll(); res.add(temp.val); if(temp.left!=null) queue.add(temp.left); if(temp.right!=null) queue.add(temp.right); &#125; return res; &#125;&#125; Java代码(迭代Stack)1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root==null) return res; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.add(root); while(!stack.isEmpty())&#123; TreeNode temp = stack.pop(); res.add(temp.val); if(temp.right!=null) stack.add(temp.right); if(temp.left!=null) stack.add(temp.left); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>树</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>树</tag>
        <tag>Medium</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-94-二叉树的中序遍历]]></title>
    <url>%2F2020%2F05%2F13%2FLeetCode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[LeetCode-94-二叉树的中序遍历给定一个二叉树，返回它的中序 遍历。 相关链接： LeetCode-144-二叉树的前序遍历 LeetCode-145-二叉树的后序遍历 示例 1: 12345678输入: [1,null,2,3] 1 \ 2 / 3输出: [1,3,2] 解题思路二叉树的遍历问题都有2种解法，一种是递归，一种是迭代 递归：开启左子树递归，添加根节点，开启右子树递归 迭代：中序遍历一般等同于DFS，用Stack来实现，后进先出。迭代是先把左子树全部添加进Stack中，然后弹出一个尾部，获得对应的val之后遍历右子树，在添加左子树的时候同时也添加了根节点，所以pop弹出时再添加val实际上会对左子树和左子树的根节点进行操作 Java代码(递归)12345678910111213141516171819202122/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; DFS(root); return res; &#125; public void DFS(TreeNode root)&#123; if(root==null) return; DFS(root.left); res.add(root.val); DFS(root.right); &#125;&#125; Java代码(迭代)1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode node = root; while(node!=null||!stack.isEmpty())&#123; while(node!=null)&#123; stack.push(node); node = node.left; &#125; node = stack.pop(); res.add(node.val); node = node.right; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>树</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>树</tag>
        <tag>Medium</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题54-二叉搜索树的第k大节点]]></title>
    <url>%2F2020%2F05%2F12%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9854-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题54-二叉搜索树的第k大节点给定一棵二叉搜索树，请找出其中第k大的节点。 示例1： 1234567输入: root = [3,1,4,null,2], k = 1 3 / \ 1 4 \ 2输出: 4 示例2： 123456789输入: root = [5,3,6,2,4,null,null,1], k = 3 5 / \ 3 6 / \ 2 4 / 1输出: 4 限制： 1 ≤ k ≤ 二叉搜索树元素个数 解题思路方法1、中序遍历的倒序： 对于二叉搜索树，左节点总是比根节点小，右节点总是比根节点大 观察可以得知，中序遍历后得到的序列是递增的，求第K个大的节点可以转化为求中序遍历的倒序的第k个节点 中序遍历序列一般可以用DFS得到 对此可以先遍历右子节点，每遍历一个右子节点，计数器加1，之后遍历左子节点 当计数器等于k时，返回对应节点的值 方法2、栈式迭代： 对于DFS和BFS问题，都可以利用一个栈来进行迭代计算，这里依旧采用倒序，先把所有的右子节点加入到stack中 之后弹出栈顶元素，如果k==n，则返回当前节点值，否则，node=node.left，按照右中左的顺序遍历 Java代码123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; int res = 0, count = 0; public int kthLargest(TreeNode root, int k) &#123; if(root==null||k==0) return 0; DFS(root,k); return res; &#125; public void DFS(TreeNode root,int k)&#123; if(root == null) return; DFS(root.right,k); count++; if(count==k)&#123; res = root.val; &#125; DFS(root.left,k); &#125;&#125; Python代码12345678910111213141516171819202122# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def kthLargest(self, root: TreeNode, k: int) -&gt; int: if not root: return None stack = [] node = root while stack or node: while node: stack.append(node) node = node.right k -= 1 node = stack.pop() if k == 0: return node.val node = node.left]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>树</tag>
        <tag>DFS</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题53-2-0到n-1中缺失的数字]]></title>
    <url>%2F2020%2F05%2F12%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9853-2-0%E5%88%B0n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题53-2-0到n-1中缺失的数字一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。 示例1： 12输入: [0,1,3]输出: 2 示例2： 12输入: [0,1,2,3,4,5,6,7,9]输出: 8 限制： 1 &lt;= 数组长度 &lt;= 10000 解题思路二分查找： 递增且数字范围在0~n-1的数组，数字和它对应的下标一定是相等的，缺失的数子会造成，该数字之后的数组下标在原本相等的情况下+1 可以利用二分查找，在当前位置数字不等于index的时候，考虑特殊情况2种 当前位置==0 当前位置的前一个位置nums[mid-1]==mid-1，即前一个数字不缺失 这两种情况说明该位置就是缺失数字的位置，直接返回mid 如果不符合特殊情况，则需要在mid左半边查找，end=mid-1 如果该位置和下标相等，则表示mid左边不存在缺失，需要在右半边查找，start=mid+1 如果找完了前面所有的都没有发现缺失的数字，说明缺失数字在数组末尾，此时start=mid+1=nums.length，缺失的数字即是num.length Java代码123456789101112131415161718192021222324class Solution &#123; public int missingNumber(int[] nums) &#123; if(nums==null||nums.length==0) return -1; int start = 0; int end = nums.length-1; while(start&lt;=end)&#123; int mid = (start+end)/2; if(nums[mid]!=mid)&#123; if(mid==0||nums[mid-1]==mid-1)&#123; return mid; &#125; end = mid-1; &#125; else start = mid+1; &#125; if(start==nums.length) return nums.length; // 无效输入，比如数组不是排序的 // 或者有数字不在0-n-1范围内 return -1; &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Easy</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题53-1-在排序数组中查找数字I]]></title>
    <url>%2F2020%2F05%2F12%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9853-1-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97I%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题53-1-在排序数组中查找数字I统计一个数字在排序数组中出现的次数。 示例1： 12输入: nums = [5,7,7,8,8,10], target = 8输出: 2 示例2： 12输入: nums = [5,7,7,8,8,10], target = 6输出: 0 限制： 0 &lt;= 数组长度 &lt;= 50000 解题思路在有序的数组中二分查找，确定第一个k出现的位置和最后一个k出现的位置，然后两个位置相减即是出现次数 Java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123; public int search(int[] nums, int target) &#123; int len = nums.length; int count = 0; if(nums!=null&amp;&amp;len&gt;0)&#123; int first = GetFristK(nums,len,target,0,len-1); int last = GetLastK(nums,len,target,0,len-1); if(first&gt;-1&amp;&amp;last&gt;-1)&#123; count = last-first+1; &#125; &#125; return count; &#125; public int GetFristK(int[] nums,int len,int target,int start,int end)&#123; if(start&gt;end) return -1; int mid = (start+end)/2; int midData = nums[mid]; if(midData==target)&#123; // 找到第一个k的位置 if(mid&gt;0&amp;&amp;nums[mid-1]!=target||mid==0) return mid; else // 如果前面还有k，缩小范围继续找 end = mid-1; &#125;else if(midData&gt;target) end = mid-1; else start = mid+1; return GetFristK(nums,len,target,start,end); &#125; public int GetLastK(int[] nums,int len,int target,int start,int end)&#123; if(start&gt;end) return -1; int mid = (start+end)/2; int midData = nums[mid]; if(midData==target)&#123; // 找到最后一个k的位置 if(mid&lt;len-1&amp;&amp;nums[mid+1]!=target||mid==len-1) return mid; else start = mid+1; &#125;else if(midData&lt;target) start = mid+1; else end = mid-1; return GetLastK(nums,len,target,start,end); &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Easy</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题52-两个链表的第一个公共节点]]></title>
    <url>%2F2020%2F05%2F12%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9852-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题52-两个链表的第一个公共节点输入两个链表，找出它们的第一个公共节点。 示例1： 123输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Reference of the node with value = 8输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例2： 123输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Reference of the node with value = 2输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例3： 1234输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。解释：这两个链表不相交，因此返回 null。 说明： 如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 解题思路方法1、双指针+先遍历： 因为链表一长一短，所以先让长的一方走到和短的一方开始的位置，然后用双指针同时进行遍历，出现第一个相同的节点时就返回对应指针 方法2、双指针+重置： 同样是双指针，因为一长一短的关系，有一个指针会先到达末尾，当第一个指针pA先到末尾时，将他重置到链表B的开始位置，当第二个指针pB到达末尾时，将他重置到链表A开始的位置。由于有一个先到达先重置，在等待第二个指针走到末尾的过程中，先达到的指针pA将会走这段A比B多出的长度。这样当第二个指针重置时，两个指针都在一个位置开始，之后遍历到相同的节点返回即可 Java代码1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; int lenA = getTreelen(headA); int lenB = getTreelen(headB); int firstStep = Math.abs(lenA-lenB); ListNode pLong = headA; ListNode pShort = headB; if(lenA&lt;lenB)&#123; pLong = headB; pShort = headA; &#125; // 长的先走几步 for(int i=0;i&lt;firstStep;i++)&#123; pLong = pLong.next; &#125; while(pLong!=null&amp;&amp;pShort!=null&amp;&amp;pLong!=pShort)&#123; pLong = pLong.next; pShort = pShort.next; &#125; return pLong; &#125; public int getTreelen(ListNode head)&#123; int lenTree = 0; while(head!=null)&#123; lenTree++; head = head.next; &#125; return lenTree; &#125;&#125; Python代码12345678910111213# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode: node1, node2 = headA, headB while node1 != node2: node1 = node1.next if node1 else headB node2 = node2.next if node2 else headA return node1]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>链表</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题51-数组中的逆序对]]></title>
    <url>%2F2020%2F05%2F09%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9851-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题51-数组中的逆序对在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。 示例1： 12输入: [7,5,6,4]输出: 5 说明： 0 &lt;= 数组长度 &lt;= 50000 解题思路方法1、暴力破解(超时)： 两个指针循环判断后面的数是不是小于前面的数，是就+1，但这样超时了。算一个没办法的解法吧 方法2、归并排序： 基本上代码就是归并排序的思想，但递归的终止条件有了变化，因为分裂区间需要判断是否有逆序数的关系 当区间的left==right的时候，说明这个区间只有一个数字了，一个数字不能组成逆序数，因此这个区间的逆序数为0 在跨区间逆序数计算时，如果左边区间比较小就需要先把左边区间的数放入temp数组中，这个时候代表左边的数比又边的数小，但此时不是逆序的关系，不需要统计逆序对；只有当右边区间比左边区间小的时候，需要统计逆序对个数，此时的逆序对个数为，左边区间还剩下的数的个数即mid-left+1 Java代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution &#123; public int reversePairs(int[] nums) &#123; int len = nums.length; if (len &lt; 2) &#123; return 0; &#125; int[] copy = new int[len]; for (int i = 0; i &lt; len; i++) &#123; copy[i] = nums[i]; &#125; int[] temp = new int[len]; return MergeSort(copy, 0, len - 1, temp); &#125; private int MergeSort(int[] nums, int left, int right, int[] temp) &#123; // 当这个区间只剩一个元素时，这个子区间就不存在逆序数，返回0 if (left == right) &#123; return 0; &#125; // int mid = (left+right)/2; // 防止int溢出 int mid = left + (right - left) / 2; int leftPairs = MergeSort(nums, left, mid, temp); int rightPairs = MergeSort(nums, mid + 1, right, temp); // 如果分出来的数组本身有序，则返回左边+右边 if (nums[mid] &lt;= nums[mid + 1]) &#123; return leftPairs + rightPairs; &#125; int crossPairs = mergeAndCount(nums, left, mid, right, temp); return leftPairs + rightPairs + crossPairs; &#125; private int mergeAndCount(int[] nums, int left, int mid, int right, int[] temp) &#123; for (int i = left; i &lt;=right; i++) &#123; temp[i] = nums[i]; &#125; int i = left; int j = mid + 1; int count = 0; for (int k = left; k &lt;= right; k++) &#123; // 如果左边数组遍历完了，就直接把右边拷贝回去 if (i == mid + 1) &#123; nums[k] = temp[j]; j++; &#125; else if (j == right + 1) &#123; // 如果右边数组遍历完了，就直接把左边拷贝回去 nums[k] = temp[i]; i++; &#125; else if (temp[i] &lt;= temp[j]) &#123; nums[k] = temp[i]; i++; &#125; else &#123; nums[k] = temp[j]; j++; count += (mid - i + 1); &#125; &#125; return count; &#125;&#125; Python代码暴力破解失败….. 12345678class Solution: def reversePairs(self, nums: List[int]) -&gt; int: i,j,count = 0,0,0 for i in range(len(nums)): for j in range(1,len(nums)): if(nums[j]&lt;nums[i]): count+=1 return count]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Hard</tag>
        <tag>Python</tag>
        <tag>分治</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-归并排序]]></title>
    <url>%2F2020%2F05%2F09%2FLeetCode-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[LeetCode-归并排序归并排序算法回顾 示例1 12输入: nums = [4,0,1,2,0,5]输出: [0,0,1,2,4,5] 解题思路归并排序算法采用分治的思想 把原本的数组不断进行二分，直到分为数组元素是单个的时候，之后开始排序合并 归并排序是稳定的排序算法，时间复杂度O(nlogn) Java代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Solution&#123; public static void main(String[] args) &#123; int[] arr = &#123;9, 8, 7, 6, 5, 4, 3, 2, 1&#125;; // 创建临时数组避免重复开辟空间 int[] temp = new int[arr.length]; MergerSort(arr, 0, arr.length - 1, temp); for(int i : arr)&#123; System.out.print(i); &#125; &#125; private static void MergerSort(int[] arr, int left, int right, int[] temp) &#123; if (left &lt; right) &#123; int mid = (left + right) / 2; MergerSort(arr, left, mid, temp); // 左边归并排序，使得左子序列有序 MergerSort(arr, mid + 1, right, temp); // 右边归并排序，使得右子序列有序 Merge(arr, left, mid, right, temp); // 将两个有序子数组合并 &#125; &#125; private static void Merge(int[] arr, int left, int mid, int right, int[] temp) &#123; int i = left; // 左序列指针 int j = mid + 1; // 右序列指针 int t = 0; // 临时数组指针 while (i &lt;= mid &amp;&amp; j &lt;= right) &#123; if (arr[i] &lt; arr[j]) &#123; temp[t++] = arr[i++]; &#125; else &#123; temp[t++] = arr[j++]; &#125; &#125; // 将左边剩余元素填充进temp中 while (i &lt;= mid) &#123; temp[t++] = arr[i++]; &#125; // 将右边剩余元素填充进temp中 while (j &lt;= right) &#123; temp[t++] = arr[j++]; &#125; t = 0; // 拷贝回原数组 while (left &lt;= right) &#123; arr[left++] = temp[t++]; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题50-第一次只出现一次的字符]]></title>
    <url>%2F2020%2F05%2F08%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9850-%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题50-第一次只出现一次的字符在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 示例1： 12345s = &quot;abaccdeff&quot;返回 &quot;b&quot;s = &quot;&quot; 返回 &quot; &quot; 说明： 0 &lt;= s 的长度 &lt;= 50000 解题思路哈希表： 每出现一次字符就把字符放入hash表中，如果有重复的就把对应位置+1 遍历的时候由于hash表重新put改变了原本的先后顺序(Java的hashmap不能原地改变，Python的dict可以原地改变)，所以需要按照字符顺序遍历，当第1次value为1的时候，就返回该字符 Java代码12345678910111213141516171819202122class Solution &#123; public char firstUniqChar(String s) &#123; if (s == null || s.length() == 0) return ' '; HashMap&lt;Character, Integer&gt; maps = new HashMap&lt;&gt;(); char[] chars = s.toCharArray(); for (char c : chars) &#123; if (!maps.containsKey(c)) &#123; maps.put(c, 1); &#125; else &#123; maps.put(c, maps.get(c) + 1); &#125; &#125; for (char c : chars) &#123; if (maps.get(c) == 1) &#123; return c; &#125; &#125; return ' '; &#125;&#125; Python代码11234567891011121314class Solution: def firstUniqChar(self, s: str) -&gt; str: if not s or len(s)==0: return ' ' d = &#123;&#125; for i in s: if i not in d: d[i] = 1 else: d[i]+=1 for k,v in d.items(): if v==1: return k return ' ']]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题49-丑数]]></title>
    <url>%2F2020%2F05%2F08%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9849-%E4%B8%91%E6%95%B0%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题49-丑数我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。 示例1： 123输入: n = 10输出: 12解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 说明： 1 是丑数。 n 不超过1690。 解题思路这个题暴力破解的解法很耗时，就是循环判断一个数是否能被2，3，5整除，如果都能，则最后的因子是1，就说明这是丑数，外层还需要一个n的循环，非常耗时。更好的解法如下 三指针： 问题分析：一个丑数只有2，3，5这3个因子，1也是丑数，那么基本的3个丑数就可以由1*2、1*3、1*5得到，而其他的丑数也可以由2、3、5的乘积得到，这样问题就转化为了一个类似DP的问题，最小的问题是2、3、5，大一点的问题是乘以2、3、5得到的丑数。 由于需要从小到大的顺序排列n个丑数，所以怎么去保持丑数的顺序很重要 在每次计算出基于2、3、5的3个丑数时，始终把最小的丑数添加进dp[i]中 之后谁的结果最小，就移动那个指针 如果第i个丑数==2xp2，也就是说前面0-p2个丑数*2不可能产生比第i个丑数更大的丑数了，所以p2++ p3，p5同理 一个更好理解的例子源于https://leetcode-cn.com/u/sunrise-9/ 1234567891011121314151617181920212223242526272829丑数的排列肯定是1,2,3,4,5,6,8,10.... 然后有一个特点是，任意一个丑数都是由小于它的某一个丑数*2，*3或者*5得到的，那么如何得到所有丑数呢？ 现在假设有3个数组，分别是： A：&#123;1*2，2*2，3*2，4*2，5*2，6*2，8*2，10*2......&#125;B：&#123;1*3，2*3，3*3，4*3，5*3，6*3，8*3，10*3......&#125;C：&#123;1*5，2*5，3*5，4*5，5*5，6*5，8*5，10*5......&#125;那么所有丑数的排列，必定就是上面ABC3个数组的合并结果然后去重得到的，那么这不就转换成了三个有序数组的无重复元素合并的问题了吗？而这三个数组就刚好是&#123;1,2,3,4,5,6,8,10....&#125;乘以2,3,5得到的。合并有序数组的一个比较好的方法，就是每个数组都对应一个指针，然后比较这些指针所指的数中哪个最小，就将这个数放到结果数组中，然后该指针向后挪一位。回到本题，要求丑数ugly数组中的第n项，而目前只知道ugly[0]=1，所以此时三个有序链表分别就只有一个元素：A ： &#123;1*2......&#125;B ： &#123;1*3......&#125;C ：&#123;1*5......&#125;假设三个数组的指针分别是i,j,k，此时均是指向第一个元素，然后比较A[i]，B[j]和C[k]，得到的最小的数A[i]，就是ugly[1]，此时ugly就变成&#123;1,2&#125;了，对应的ABC数组就分别变成了：A ： &#123;1*2，2*2......&#125;B ： &#123;1*3, 2*3......&#125;C ：&#123;1*5,2*5......&#125;此时根据合并有序数组的原理，A数组指针i就指向了下一个元素，即&apos;2*2&apos;，而j和k依然分别指向B[0]和C[0]，然后进行下一轮合并，就是A[1]和B[0]和C[0]比较，最小值作为ugly[2].....如此循环n次，就可以得到ugly[n]了。此外，注意到ABC三个数组实际上就是ugly[]*2，ugly[]*3和ugly[]*5的结果，所以每次只需要比较A[i]=ugly[i]*2，B[j]=ugly[j]*3和C[k]=ugly[k]*5的大小即可。然后谁最小，就把对应的指针往后移动一个，为了去重，如果多个元素都是最小，那么这多个指针都要往后移动一个。 Java代码123456789101112131415class Solution &#123; public int nthUglyNumber(int n) &#123; int p2=0,p3=0,p5=0; // 想象初始化3个有序链表的第一个元素，分别为2、3、5为基数乘的数组 int[] dp = new int[n]; dp[0] = 1; for(int i=1;i&lt;n;i++)&#123; // 返回的下一个丑数应该是*2,*3,*5之后的最小丑数 dp[i] = Math.min(dp[p2]*2,Math.min(dp[p3]*3,dp[p5]*5)); if(dp[i]==dp[p2]*2) p2++; if(dp[i]==dp[p3]*3) p3++; if(dp[i]==dp[p5]*5) p5++; &#125; return dp[n-1]; &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Medium</tag>
        <tag>DP</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题48-最长不含重复字符的子字符串]]></title>
    <url>%2F2020%2F05%2F08%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9848-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题48-最长不含重复字符的子字符串请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。 示例1： 123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例2： 123输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例3： 1234输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 解题思路方法1、DP+哈希表： 设置右边界为j，左边界为i 当字串左边没有相同的字符时，dp[j] = dp[j-1]+1 当dp[j-1]&lt;j-i，说明字符在dp[j-1]区间之外，如acbr，对于acb而言下一个字符r不是重复的字符，其在dp[j-1]之外，所以dp[j] = dp[j-1]+1 当dp[j-1]&gt;=j-i，说明字符在dp[j-1]区间之中，含有重复字符，则dp[j]的左边界由第一次出现的重复字符的位置觉得，dp[j]=j-i 第一二种情况可以合并为一个，由于返回值取dp列表最大值，可以借助dp变量，存储dp[j]，每轮更新res 节省原本需要dp列表的空间 方法2、双指针+哈希表： 按照顺序遍历字符串，同时计算子串的长度，当到达相同的字符时候，自然希望子串的起始位置变成重复的位置。 而下一次子串的长度则=计算下一次碰到重复字符的位置end到上一次碰到重复字符位置start的差 那么如何去知道前面是否有重复的字符？ 如果不使用hash表，就需要从最开始遍历到末尾end进行判断，这样时间复杂度太高。 所以这里采用hash表的方式存储每一个字符最后出现的位置，以便于快速找到上一次start的位置，由于遍历从0开始，所以将start初始化为-1，表示第一个位置长度为1，最后取最大的字串长度 Java代码123456789101112131415class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; Map&lt;Character,Integer&gt; dict = new HashMap&lt;&gt;(); int res = 0,dp = 0; for(int j=0;j&lt;s.length();j++)&#123; int i = dict.containsKey(s.charAt(j))?dict.get(s.charAt(j)):-1; // 获取索引 dict.put(s.charAt(j),j); // 更新hash // dp[j-1] &lt; j-i时，dp[j-1]+1 // dp[j-1] &gt; j-i时，j-i dp = dp&lt;j-i?dp+1:j-i; res = Math.max(res,dp); // max(dp[j-1],dp[j]) &#125; return res; &#125;&#125; Python代码12345678910class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: start,res= -1,0 positionMap = &#123;&#125; for end in range(len(s)): if s[end] in positionMap: start = max(positionMap[s[end]],start) positionMap[s[end]] = end res = max(res,end-start) return res]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Medium</tag>
        <tag>字符串</tag>
        <tag>DP</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题47-礼物的最大价值]]></title>
    <url>%2F2020%2F05%2F07%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9847-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题47-礼物的最大价值在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？ 示例1： 12345678输入: [ [1,3,1], [1,5,1], [4,2,1]]输出: 12解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物 解题思路动态规划： 由于只能向右和向下移动，所以对于第一行和第一列而言，可能的最大值就是直接向右和向下移动 设置二维dp矩阵 第一列表示为i不等于0时，dp[i][0]仅与dp[i-1][0]有关，于是可以在原矩阵直接进行修改 第一行表示为j不等于0时，dp[0][j]仅与dp[0][j-1]有关 对于一行和一列可以先计算出来，避免循环中重复的判断 当i和j都不等于0时，dp[i][j]应该等于其左边格子的累和以及上边格子累和的最大值+当前格子的值 即dp[i][j]=Max(dp[i-1][j],dp[i][j-1])+gift(i,j) Java代码123456789101112131415161718192021class Solution &#123; public int maxValue(int[][] grid) &#123; if (grid == null||grid.length == 0||grid[0].length == 0) &#123; return 0; &#125; int m = grid.length; int n = grid[0].length; for(int i=1;i&lt;m;i++)&#123; grid[i][0]+=grid[i-1][0]; &#125; for(int j=1;j&lt;n;j++)&#123; grid[0][j]+=grid[0][j-1]; &#125; for(int i=1;i&lt;m;i++)&#123; for(int j=1;j&lt;n;j++)&#123; grid[i][j] += Math.max(grid[i-1][j],grid[i][j-1]); &#125; &#125; return grid[m-1][n-1]; &#125;&#125; Python代码1234567891011class Solution: def maxValue(self, grid: List[List[int]]) -&gt; int: if not grid or len(grid)==0 or len(grid[0])==0: return 0 for i in range(len(grid)): for j in range(len(grid[0])): if i==0 and j==0: continue if i!=0 and j==0: grid[i][j]+=grid[i-1][j] if i==0 and j!=0: grid[i][j]+=grid[i][j-1] if i!=0 and j!=0: grid[i][j]+=max(grid[i-1][j],grid[i][j-1]) return grid[len(grid)-1][len(grid[0])-1]]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
        <tag>DP</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题46-把数字翻译成字符串]]></title>
    <url>%2F2020%2F05%2F07%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9846-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题46-把数字翻译成字符串给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。 示例1： 123输入: 12258输出: 5解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot; 限制： 0 &lt;= num &lt; 2^31 解题思路动态规划： 初始化dp[0]=dp[1]=1，即翻译”无数字”和”第1位数字”的翻译方法数量均为1 当num的第1，2位的组成的数字属于[10,25]时，dp[2]=dp[1]+dp[0]=2，有2种翻译方法，显然dp[1]=1，所以dp[0]=1 当1个数被翻译为1个字母时，剩下的方案即dp[i-1]，dp[i]=dp[i-1] 当2个数组合在[10,25]的范围时，方案有2种，一是翻译1个数，二是翻译2个组合的数，dp[i] = dp[i-1]+dp[i-2] 为了优化空间，这里使用2个变量，分别代表dp[i]和dp[i-1]，当i从2开始时，dp[2]就可以通过dp0+dp1得到，之后顺序递推这两个数值 递归(回溯)： 想象成一棵二叉树，可以选择翻译1个数，也可以选择翻译1个组合数 当二叉树走的深度没有达到字符串长度时，就要进行判断 如果组合数符合[10,25]，则翻译的可能性有使用1个数字i+1和使用2个数字i+2两种可能，开启2种可能的递归调用。 如果不符合，则翻译只有一种可能，即i+1深度下的可能性 Java代码12345678910111213141516class Solution &#123; public int translateNum(int num) &#123; if(num&lt;0) return 0; String s = String.valueOf(num); int dp0 = 1; int dp1 = 1; for(int i=2;i&lt;=s.length();i++)&#123; String temp = s.substring(i-2,i); int res = temp.compareTo("10")&gt;=0&amp;&amp;temp.compareTo("25")&lt;=0 ? dp0 + dp1 : dp1; dp0 = dp1; dp1 = res; &#125; return dp1; &#125;&#125; Python代码123456789101112131415class Solution: def translateNum(self, num: int) -&gt; int: s = str(num) length = len(s)-1 return self.Sum(s,0,length) def Sum(self,s,i,length): if i &gt;=length: return 1 if i&lt;=length-1: nsum = int(s[i])*10+int(s[i+1]) if nsum&gt;=10 and nsum&lt;=25: return self.Sum(s,i+1,length)+self.Sum(s,i+2,length) else: return self.Sum(s,i+1,length)]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
        <tag>DP</tag>
        <tag>Python</tag>
        <tag>回溯</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题45-把数组排成最小的数]]></title>
    <url>%2F2020%2F05%2F06%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9845-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题45-把数组排成最小的数输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。 示例1： 12输入: [10,2]输出: &quot;102&quot; 示例2： 12输入: [3,30,34,5,9]输出: &quot;3033459&quot; 限制： 0 &lt; nums.length &lt;= 100 说明： 输出结果可能非常大，所以你需要返回一个字符串而不是整数 拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0 解题思路排序： 对于两个数字m和n，可以拼接成mn和nm，如果mn&lt;nm，那么就应该打印出mn，也就是m应该排在n之前，此时定义m”小于”n；反之，如果nm&lt;mn，应该打印nm，此时定义n”小于”m；如果mn=nm，则n”等于”m，由于组合的数字很大，所以这也是一个大数问题，用字符串来进行拼接得到结果 在Java代码中可以重写Arrays中的compareTo接口，使x+y和y+x进行大小比较，sort方法默认升序，所以比较出来的数组自然是最小的 Python代码….原来还可以根据key自定义规则，方法来自https://leetcode-cn.com/u/bigkjp97/因为默认升序，所以只需要改变大于或者小于的规则即可，其他规则富比较方法中不变不影响 Java代码123456789101112131415class Solution &#123; public String minNumber(int[] nums) &#123; if(nums==null||nums.length==0) return ""; String[] str = new String[nums.length]; for(int i =0;i&lt;nums.length;i++)&#123; str[i] = String.valueOf(nums[i]); &#125; Arrays.sort(str, (x, y) -&gt; (x + y).compareTo(y + x)); StringBuilder res = new StringBuilder(); for(String s:str) res.append(s); return res.toString(); &#125;&#125; Python代码1123456789class SmallerNumKey(str): # 定义一个类 # 富比较方法 def __lt__(x, y): return x + y &lt; y + xclass Solution: def minNumber(self, nums: List[int]) -&gt; str: smallest_num = ''.join(sorted(map(str, nums),key=SmallerNumKey)) return smallest_num Python代码2123456789class Solution: def minNumber(self, nums: List[int]) -&gt; str: def sort_rule(x, y): a, b = x + y, y + x if a &gt; b: return 1 elif a &lt; b: return -1 else: return 0 strs.sort(map(str,nums),key = functools.cmp_to_key(sort_rule)) return ''.join(strs)]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
        <tag>Python</tag>
        <tag>大数问题</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题44-数字序列中某一位的数字]]></title>
    <url>%2F2020%2F05%2F06%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9844-%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题44-数字序列中某一位的数字数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。 请写一个函数，求任意第n位对应的数字。 示例1： 12输入：n = 3输出：3 示例2： 12输入：n = 11输出：0 限制： 1 &lt;= n &lt; 2^31 解题思路找规律： 首先int类型只能表示2^31-1个数，所以存储的时候需要用long表示 数字范围 位数 数字数量 数位数量 数字范围1-9 位数=1 数字数量=9 数位数量=9 数字范围10-99 位数=2 数字数量=90 数位数量 =180 数字范围100-999 位数=3 数字数量=900 数位数量=2700 数字范围start-end 位数=digit 数字数量=9xstart 数位数量=9xstartxdigit 可以从上规律分析出，可以通过划分数字的范围，去确定输入n位在几位数的区间，之后再几位数的区间中找到这一位数字。 剑指offer的解法： 比如数字序列的1001位，由上表可知1001位的数字范围是100-999，因为1001&lt;2700，1001-180-9=881位，即数字范围100~999中的881位数字，由于这个范围数字是3位数，881/3=270，余1。即在100的基础上走过270个数字之后，再移动1位即是1001位数。可以从数字n开始出发，每排除一种位数的范围，就把n减去这个范围的位数，然后确定n应该在的范围 递推的解法： 观察上面的表格可以看出 位数递推公式digit = digit+1 起始数字公式 start=startx10 数位数量公式count=9xstartxdigit 求解分为3步： 确定n所在数字的位数，记为digit 确定n所在的数字，记为num 确定n是num中的哪一数位，返回结果 Java代码1234567891011121314151617181920212223242526272829303132333435363738394041public class Solution &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int out = findNthDigit(n); System.out.println(out); &#125; public static int findNthDigit(int n) &#123; if (n &lt; 10) return n; int digits = 1; // 代表是几位数 // 找到n位于几位数的范围中 while (true) &#123; long nums = 0; if (digits == 1) nums = 10; else nums = 9 * (long) Math.pow(10, digits - 1); if (n &lt; nums * digits) return digitsN(n, digits); n -= digits * nums; digits++; &#125; &#125; // 在几位数中找出那一位数字 // 比如811=270x3+1是从100开始的270个数字的中间1位 public static int digitsN(int n, int digits) &#123; long nums = begin(digits) + n / digits; // 求得那个数字中的第几位，如370，7是这个数字的第2位 int indexFromRight = digits - n % digits; for (int i = 1; i &lt; indexFromRight; i++) &#123; nums /= 10; &#125; return (int) nums % 10; &#125; // 找到所属位数的初始值，如3位数的初始值是100 public static long begin(int digits) &#123; if (digits == 1) return 0; return (long) Math.pow(10, digits - 1); &#125;&#125; Python代码1234567891011class Solution: def findNthDigit(self, n: int) -&gt; int: digit,start,count = 1,1,9 while n&gt;count: n-=count start*=10 digit+=1 count = 9*start*digit num = start + (n-1)//digit # 确定所求数位所在的数字 res = str(num)[(n-1)%digit]# 确定所求数位在num的哪一数位，余数即使对应位置 return int(res)]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
        <tag>Python</tag>
        <tag>大数问题</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题43-1到n整数中1出现的次数]]></title>
    <url>%2F2020%2F05%2F05%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9843-1%E5%88%B0n%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题43-1到n整数中1出现的次数输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。 例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。 示例1： 12输入：n = 12输出：5 示例2： 12输入：n = 13输出：6 限制： 1 &lt;= n &lt; 2^31 解题思路暴力破解不行，就像在做数学题TAT 递归：转自力扣评论区 f(n)函数的意思是1～n这n个整数的十进制表示中1出现的次数，将n拆分为两部分，最高一位的数字high和其他位的数字last，分别判断情况后将结果相加，看例子更加简单。 例子如n=1234，high=1, pow=1000, last=234 可以将数字范围分成两部分1~999和1000~1234 1~999这个范围1的个数是f(pow-1) 1000~1234这个范围1的个数需要分为两部分： 千分位是1的个数：千分位为1的个数刚好就是234+1(last+1)，注意，这儿只看千分位，不看其他位 其他位是1的个数：即是234中出现1的个数，为f(last) 所以全部加起来是f(pow-1) + last + 1 + f(last); —————————————————————————————————————————————————————————————— 例子如3234，high=3, pow=1000, last=234 可以将数字范围分成两部分1~999，1000~1999，2000~2999和3000~3234 1~999这个范围1的个数是f(pow-1) 1000~1999这个范围1的个数需要分为两部分： 千分位是1的个数：千分位为1的个数刚好就是pow，注意，这儿只看千分位，不看其他位 其他位是1的个数：即是999中出现1的个数，为f(pow-1) 2000~2999这个范围1的个数是f(pow-1) 3000~3234这个范围1的个数是f(last) 所以全部加起来是pow + high*f(pow-1) + f(last); Java代码123456789101112131415161718class Solution &#123; public int countDigitOne(int n) &#123; return f(n); &#125; public int f(int n)&#123; if(n&lt;=0) return 0; String s = String.valueOf(n); int high = s.charAt(0)-'0'; int pow = (int)Math.pow(10,s.length()-1); int last = n-high*pow; if(high==1)&#123; return f(pow-1)+last+1+f(last); &#125;else&#123; return pow+high*f(pow-1)+f(last); &#125; &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Hard</tag>
        <tag>Python</tag>
        <tag>大数问题</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题42-连续子数组的最大和]]></title>
    <url>%2F2020%2F05%2F05%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9842-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题42-连续子数组的最大和输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。 要求时间复杂度为O(n)。 示例1： 123输入: nums = [-2,1,-3,4,-1,2,1,-5,4]输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 限制： 1 &lt;= arr.length &lt;= 10^5 -100 &lt;= arr[i] &lt;= 100 解题思路方法1、找规律： 当累和小于等于0时，则curSum从当前数开始，如果不小于0就开始累加 如果当前和大于最大的和，就把curSum的值给maxSum 方法2、动态规划： dp[i] = dp[i-1] + nums[i] # if i != 0 and dp[i-1] &gt; 0 dp[i] = nums[i] # if i == 0 or dp[i-1] &lt; 0 公式的意义在于，当第i-1个数字结尾的子数组中 所有数字的和小于0时，如果把这个负数与第i个数累加，则得到的结果比第i个数字本身还要小，所以这个情况下第i个数字结尾的子数组就是第i个数字本身。 如果i-1个数字结尾的子数组中所有数字的和大于0，则与第i个数字累加就得到以第i个数字结尾的子数组中所有数字的和 在这里因为dp[i]只与dp[i-1]和nums[i]有关系，因此可以将原数组nums用做dp列表，即直接在nums上修改 Java代码123456789101112131415161718class Solution &#123; public int maxSubArray(int[] nums) &#123; if(nums.length==0||nums==null) return 0; int maxSum = Integer.MIN_VALUE; int curSum = 0; for(int i = 0;i&lt; nums.length;i++)&#123; if(curSum&lt;=0) curSum = nums[i]; else curSum+=nums[i]; if(curSum&gt;maxSum)&#123; maxSum = curSum; &#125; &#125; return maxSum; &#125;&#125; Python代码123456789class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: if not nums or len(nums)==0: return 0 maxSum = nums[0] for i in range(1,len(nums)): if nums[i-1]&gt;0: nums[i]+=nums[i-1] maxSum = max(maxSum,nums[i]) return maxSum]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Easy</tag>
        <tag>DP</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题41-数据流中的中位数]]></title>
    <url>%2F2020%2F05%2F04%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9841-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题41-数据流中的中位数如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。 例如， [2,3,4] 的中位数是 3 [2,3] 的中位数是 (2 + 3) / 2 = 2.5 设计一个支持以下两种操作的数据结构： void addNum(int num) - 从数据流中添加一个整数到数据结构中。 double findMedian() - 返回目前所有元素的中位数。 示例1： 1234输入：[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;][[],[1],[2],[],[3],[]]输出：[null,null,null,1.50000,null,2.00000] 示例2： 1234输入：[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;][[],[2],[],[3],[]]输出：[null,null,2.00000,null,2.50000] 限制： 最多会对 addNum、findMedia进行 50000 次调用。 解题思路最大堆+最小堆： 可以看作最大堆是普通班，最小堆是实验班。数量上时刻保持小顶-大顶&lt;=1（两堆相等或者小顶比大顶多一个）。 新学生先入普通班（最大堆），此时可能会失去平衡了，于是取最大堆的第一个（班里最好的学生）加入实验班（最小堆），判断若数量过多（不是等于或多一个），取第一个（实验班里最差的学生）到普通班（最大堆）里。 取中位数的时候，若两堆数量相等，则各取堆顶取平均，若小顶比大顶多一，则多的那一个就是中位数。 Java代码1234567891011121314151617181920212223242526272829303132333435class MedianFinder &#123; Queue&lt;Integer&gt; left; Queue&lt;Integer&gt; right; /** initialize your data structure here. */ public MedianFinder() &#123; left = new PriorityQueue&lt;&gt;((n1,n2)-&gt;n2-n1); // 最大堆 right = new PriorityQueue&lt;&gt;(); // 最小堆 &#125; public void addNum(int num) &#123; // 先插入最大堆 left.offer(num); // 之后把最大堆的最大的数字，拿出来给最小堆 right.offer(left.poll()); // 数组数目是奇数时，且小堆比大堆多时，需要平衡 // 小堆的堆顶拿出来给最大堆 if(right.size()&gt;left.size()) left.offer(right.poll()); &#125; public double findMedian() &#123; // 如果最大堆大于最小堆个数，即数组是奇数，返回最大堆堆顶 // 如果是偶数，则是（最大堆堆顶+最小堆堆顶 ）/ 2 if(left.size()&gt;right.size()) return left.peek(); else return (left.peek()+right.peek())/2.0; &#125;&#125;/** * Your MedianFinder object will be instantiated and called as such: * MedianFinder obj = new MedianFinder(); * obj.addNum(num); * double param_2 = obj.findMedian(); */]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Hard</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题40-最小的k个数]]></title>
    <url>%2F2020%2F05%2F04%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9840-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题40-最小的k个数输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。 示例1： 12输入：arr = [3,2,1], k = 2输出：[1,2] 或者 [2,1] 示例2： 12输入：arr = [0,1,2,1], k = 1输出：[0] 限制： 0 &lt;= k &lt;= arr.length &lt;= 10000 0 &lt;= arr[i] &lt;= 10000 解题思路方法1、快排+选择： 基于之前快速排序的代码实现，现在加了几个条件，如下： 每快排切分1次，找到切分点，比较切分点和k的关系 如果相等则意味着，切分点左边的数字已经是最小数组集合，直接返回 如果k小于m说明需要在左子数组进行搜索 如果k大于m说明需要在右子数组进行搜索 方法2、最大堆： 使用Java的优先级队列PriorityQueue，实现最大堆 当队列不足k个的时候，传入一个元素 当队列大于k个的时候，判断下一个元素是否小于堆顶，如果小于就把堆顶弹出，把下一个元素传入 之后返回对应的数组 Java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution &#123; public int[] getLeastNumbers(int[] arr, int k) &#123; if(k==0) return new int[0]; else if(arr.length&lt;=k) return arr; quickSort(arr,0,arr.length-1,k); int[] res = new int[k]; for(int i = 0;i &lt; k; i++)&#123; res[i] = arr[i]; &#125; return res; &#125; public void quickSort(int[] list, int left, int right,int k) &#123; // 每快排切分1次，找到切分点，比较切分点和k的关系 int m = partition(list,left,right); // 如果相等则意味着，切分点左边的数字已经是最小数组集合，直接返回 if(k==m)&#123; return; &#125; // 如果k小于m说明需要在左子数组进行搜索 else if(k&lt;m)&#123; quickSort(list,left,m-1,k); &#125; // 如果k大于m说明需要在右子数组进行搜索 else&#123; quickSort(list,m+1,right,k); &#125; &#125; public int partition(int[] list, int left, int right) &#123; // 用数组的第一个元素作为基准数 int first = list[left]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; list[right] &gt;= first) &#123; right--; &#125; swap(list, left, right); while (left &lt; right &amp;&amp; list[left] &lt;= first) &#123; left++; &#125; swap(list, left, right); &#125; // 返回分割点所在的位置 return left; &#125; public void swap(int[] list, int left, int right) &#123; int temp; if (list != null &amp;&amp; list.length &gt; 0) &#123; temp = list[left]; list[left] = list[right]; list[right] = temp; &#125; &#125;&#125; Java代码1234567891011121314151617181920212223242526class Solution &#123; public int[] getLeastNumbers(int[] arr, int k) &#123; if(k==0||arr.length==0) return new int[0]; // 使用一个最大堆 // 默认最小堆，需要转化，默认是升序的，转化之后是降序的 Queue&lt;Integer&gt; stack = new PriorityQueue&lt;&gt;((v1,v2)-&gt;v2-v1); for(int num:arr)&#123; if(stack.size()&lt;k)&#123; stack.offer(num); &#125; // peek队首元素 else if(num&lt;stack.peek())&#123; // 因为是降序，所以poll队首是最大元素 stack.poll(); stack.offer(num); &#125; &#125; int[] res = new int[stack.size()]; int i = 0; for(int num:stack)&#123; res[i++] = num; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-快速排序]]></title>
    <url>%2F2020%2F05%2F04%2FLeetCode-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[LeetCode-快速排序快速排序算法回顾 示例1 12输入: nums = [4,0,1,2,0,5]输出: [0,0,1,2,4,5] 解题思路快速排序算法回顾，左右两个指针进行操作，判断基准数和指针位置的大小关系，使得基准数左边的数字比它小，右边的数字比它大。递归进行求解 快速排序是不稳定的排序算法，时间复杂度O(nlogn)-O(n^2) Java代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Solotion &#123; public static void main(String[] args) &#123; int[] arr = &#123;4, 0, 1, 2, 0, 5&#125;; quickSort(arr, 0, arr.length - 1); for (Integer i : arr) &#123; System.out.print(i); &#125; &#125; public static void quickSort(int[] list, int left, int right) &#123; if (left &lt; right) &#123; // 分割数组，找到分割点 int point = partition(list, left, right); // 对左子数组进行快排 quickSort(list, left, point - 1); // 对右子数组进行快排 quickSort(list, point + 1, right); &#125; &#125; public static int partition(int[] list, int left, int right) &#123; // 用数组的第一个元素作为基准数 int first = list[left]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; list[right] &gt;= first) &#123; right--; &#125; swap(list, left, right); while (left &lt; right &amp;&amp; list[left] &lt;= first) &#123; left++; &#125; swap(list, left, right); &#125; // 返回分割点所在的位置 return left; &#125; public static void swap(int[] list, int left, int right) &#123; int temp; if (list != null &amp;&amp; list.length &gt; 0) &#123; temp = list[left]; list[left] = list[right]; list[right] = temp; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题39-数组中出现次数超过一半的数字]]></title>
    <url>%2F2020%2F04%2F29%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9839-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题39-数组中出现次数超过一半的数字数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例： 12输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]输出: 2 限制： ​ 1 &lt;= 数组长度 &lt;= 50000 解题思路方法1、投票法： 把众数的票数记为+1，非众数票数记为-1，如果众数出现的次数超过数组长度的一般，则一定会有所有的数字的票数和&gt;0 方法2、哈希Map 空间换时间，没有出现在map中的数添加进去，出现过了则次数+1，之后获取次数最大的key即可 Java代码12345678910111213141516171819class Solution &#123; public int majorityElement(int[] nums) &#123; if(nums==null||nums.length==0) return 0; int result = nums[0]; int times = 1; for(int i=1;i&lt;nums.length;i++)&#123; if(times==0)&#123; result = nums[i]; times = 1; &#125; else if(nums[i]==result) times++; else times--; &#125; return result; &#125;&#125; Python代码12345678910class Solution: def majorityElement(self, nums: List[int]) -&gt; int: if not nums: return 0 numsMap = &#123;&#125; for i in nums: if i not in numsMap: numsMap[i]=1 else: numsMap[i]+=1 return max(numsMap,key=numsMap.get)]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Easy</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题38-字符串的排列]]></title>
    <url>%2F2020%2F04%2F27%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9838-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题38-字符串的排列输入一个字符串，打印出该字符串中字符的所有排列。 你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。 示例： 12输入：s = &quot;abc&quot;输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;] 限制： ​ 1 &lt;= s 的长度 &lt;= 8 解题思路方法1：DFS全排列+剪枝 基本原理通过字符交换的方式，先固定第1位，再固定第2位，一直到固定第n位。 比如固定a，找剩下bc的可能排列，再固定b，找剩下c的可能排列。 之后固定b，找ac的可能排列….直到所有的组合都被找到 特例处理：当初始的字符串有重复的字符时，如aab，需要保证字符只在此为固定一次，即遇到重复的字符时不进行交换直接跳过，即剪枝 方法2：DFS+回溯 全排列问题详解见该文 路径从空开始构建，当DFS深度达到了字符串长度时则添加进去，之后开始回溯，将访问过的状态复原，path弹出 Java代码12345678910111213141516171819202122232425262728293031class Solution &#123; List&lt;String&gt; res = new LinkedList&lt;&gt;(); public String[] permutation(String s) &#123; if(s==null||s.length()==0) return new String[0]; char[] c = s.toCharArray(); StringHelper(c,0); return res.toArray(new String[res.size()]); &#125; public void StringHelper(char[] c,int start)&#123; if(start==c.length-1)&#123; res.add(String.valueOf(c)); // 添加排列 return; &#125; HashSet&lt;Character&gt; set = new HashSet&lt;&gt;(); for(int i=start;i&lt;c.length;i++)&#123; if(set.contains(c[i])) continue; // 剪枝重复的 set.add(c[i]); // 交换，将c[i]固定在start位置，比如abc，此时固定a char temp = c[i]; c[i] = c[start]; c[start] = temp; // 递归start+1位置，比如abc，此时进入bc的固定再交换，递归 StringHelper(c,start+1); // 恢复交换 temp = c[i]; c[i] = c[start]; c[start] = temp; &#125; &#125;&#125; Python代码1234567891011121314151617181920212223242526class Solution: def permutation(self, s: str) -&gt; List[str]: def dfs(s, size, depth, visited, path, res): if depth == size: # 路径达到长度了，进行添加 res.append("".join(path[:])) return for i in range(size): if not visited[i]: # 如果当前节点和前一个节点相同，且他的前一个节点已经被遍历，则跳过 if i&gt;0 and s[i]==s[i-1] and not visited[i-1]:continue visited[i] = True # 访问过了 path.append(s[i]) # 添加进路径 dfs(s, size, depth + 1, visited, path, res) # 开启DFS visited[i] = False # 回溯，状态还原 path.pop() # 路径还原 s = list(sorted(s)) # 考虑重复问题，先进行排序 size = len(s) if size == 0: return [] res = [] path = [] visited = [False for _ in range(size)] dfs(s, size, 0, visited, path, res) return res]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Medium</tag>
        <tag>DFS</tag>
        <tag>字符串</tag>
        <tag>Python</tag>
        <tag>回溯</tag>
        <tag>剑指Offer</tag>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题37-序列化二叉树]]></title>
    <url>%2F2020%2F04%2F26%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9837-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题37-序列化二叉树请实现两个函数，分别用来序列化和反序列化二叉树。 示例： 123456789你可以将以下二叉树： 1 / \ 2 3 / \ 4 5序列化为 &quot;[1,2,3,null,null,4,5]&quot; 解题思路BFS+位置指针(队列、递归2种解法)： 队列： 序列化的过程是一个典型的BFS层序遍历，由于返回的要求是String类型，所以在遍历的同时加上字符串拼接即可 反序列化的过程，利用一个队列按层构建二叉树，并使用index指针记录节点temp的左子节点和右子节点。每构建一个节点，index就向右移动1位，只有当节点不为空时，左右节点的构建才有效。为空时index++会跳过值为null的节点 递归： 注意：递归序列化出来的序列和队列方式结果不同，递归返回的列表数据更像DFS遍历的结果，虽然两者序列化和反序列化的方式不同，但不影响构建结果。即怎么序列化，就怎么反序列化 初始化：res列表，index指针 序列化递归： 判断头节点是否为空，为空则直接返回空列表 否则开始序列化递归，序列化递归过程如下： 终止条件：当遍历到左/右子节点为空时，res添加null字符，返回 递推：res添加root节点值，开启左子树遍历self.serhelper(root.left)，之后开启右子树遍历self.serhelper(root.right) 反序列化递归： 判断头节点是否为空，为空则直接返回空列表 否则开始反序列化递归，过程如下： 终止条件：index位置为null，说明此位置是空节点，index后移一位，返回None 递推：新建Node，index指针后移指向左节点，开启左右子树递归node.left = self.deshelper(data)和node.right = self.deshelper(data) Java代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Codec &#123; // Encodes a tree to a single string. public String serialize(TreeNode root) &#123; if(root==null) return "[]"; StringBuilder res = new StringBuilder("["); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty())&#123; TreeNode temp = queue.poll(); if(temp!=null)&#123; res.append(temp.val+","); queue.add(temp.left); queue.add(temp.right); &#125; else res.append("null,"); &#125; res.deleteCharAt(res.length()-1); res.append("]"); return res.toString(); &#125; // Decodes your encoded data to tree. public TreeNode deserialize(String data) &#123; if(data.equals("[]")) return null; String[] origin = data.substring(1,data.length()-1).split(","); TreeNode root = new TreeNode(Integer.parseInt(origin[0])); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); int index = 1; while(!queue.isEmpty())&#123; TreeNode temp = queue.poll(); if(!origin[index].equals("null"))&#123; temp.left = new TreeNode(Integer.parseInt(origin[index])); queue.add(temp.left); &#125; index++; if(!origin[index].equals("null"))&#123; temp.right = new TreeNode(Integer.parseInt(origin[index])); queue.add(temp.right); &#125; index++; &#125; return root; &#125;&#125;// Your Codec object will be instantiated and called as such:// Codec codec = new Codec();// codec.deserialize(codec.serialize(root)); Python代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Codec: def __init__(self): self.res = [] self.index = 0 def serialize(self, root): """Encodes a tree to a single string. :type root: TreeNode :rtype: str """ if not root: return [] self.serhelper(root) return self.res def serhelper(self,root): if not root: self.res.append("null") return self.res.append(root.val) self.serhelper(root.left) self.serhelper(root.right) def deserialize(self, data): """Decodes your encoded data to tree. :type data: str :rtype: TreeNode """ if not data: return [] return self.deshelper(data) def deshelper(self,data): if data[self.index] == "null": self.index+=1 return None node = TreeNode(data[self.index]) self.index+=1 node.left = self.deshelper(data) node.right = self.deshelper(data) return node # Your Codec object will be instantiated and called as such:# codec = Codec()# codec.deserialize(codec.serialize(root))]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>树</tag>
        <tag>Hard</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题36-二叉搜索树与双向链表]]></title>
    <url>%2F2020%2F04%2F24%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9836-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题36-二叉搜索树与双向链表输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。 为了让您更好地理解问题，以下面的二叉搜索树为例： 我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。 下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。 特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。 解题思路DFS+修改指针： 不难发现双向链表的序列是中序遍历的结果，只是在遍历的同时需要调整指针的指向 特例处理：root==null，则返回 初始化：记录前面一个节点的指针pre 递归中序遍历： 终止条件是当节点cur为空的时候，代表越过叶子节点，直接return 之后开启左子树递归DFS(cur.left) 构建链表： 当前面一个节点pre为空时，代表正在访问链表头结点，head = cur 当前面一个节点pre不为空时，修改双向节点引用，pre.right = cur，cur.left = pre 保存cur：更新pre = cur，节点cur是pre的后继节点 递归右子树，DFS(cur.right) 完成递归之后，需要连接头尾节点，此时head指向头结点，pre指向尾节点 修改head.left = pre ，pre.right = head 之后返回头结点head即可 Java代码12345678910111213141516171819202122232425262728293031323334353637383940414243/*// Definition for a Node.class Node &#123; public int val; public Node left; public Node right; public Node() &#123;&#125; public Node(int _val) &#123; val = _val; &#125; public Node(int _val,Node _left,Node _right) &#123; val = _val; left = _left; right = _right; &#125;&#125;;*/class Solution &#123; Node pre = null; Node head = null; public Node treeToDoublyList(Node root) &#123; if(root==null) return root; DFS(root); head.left = pre; pre.right = head; return head; &#125; public void DFS(Node cur)&#123; if(cur==null) return; DFS(cur.left); if(pre!=null) pre.right = cur; else head = cur; cur.left = pre; pre = cur; DFS(cur.right); &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>树</tag>
        <tag>Medium</tag>
        <tag>DFS</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题35-复杂链表的复制]]></title>
    <url>%2F2020%2F04%2F23%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9835-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题35-复杂链表的复制请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。 示例1： 12输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]输出：[[7,null],[13,0],[11,4],[10,2],[1,0]] 示例2 12输入：head = [[1,1],[2,1]]输出：[[1,1],[2,1]] 示例3 12输入：head = [[3,null],[3,0],[3,null]]输出：[[3,null],[3,0],[3,null]] 示例4 123输入：head = []输出：[]解释：给定的链表为空（空指针），因此返回 null。 提示： -10000 &lt;= Node.val &lt;= 10000 Node.random 为空（null）或指向链表中的节点。 节点数目不超过 1000 。 解题思路方法1、哈希表： 需要2次循环，第一次循环建立原始链表Node和复制链表Node的映射关系，具体映射Node——&gt;new(Node.val)，node.val只是为了初始化最开始的数值，新节点的next和random并没有设置 第二次循环建立复制链表关系，复制节点的next就是原本节点next对应的节点，random同理 方法2、分治(剑指解法)： 把复制链表的问题分解为3个子问题，每个问题独立解决 步骤1：连接原始链表和复制链表 复制链表的next应该是原始链表的next(即pClone.next = pNode.next)，random暂时不设置，原始链表的next此时应该是复制链表的新建的Node(即pNode.next = pClone)，指针应该后移，此时复制链表的next对应着原始链表的next，所以pNode = pClone.next 步骤2：设置复制链表random指针的指向 首先需要找到原始链表Node的random指向，即node.random，由于两个链表已经合并了的关系，此时复制链表的Node的random指针，应该指向node.random.next，因为现在N-&gt;N’，N代表原始链表节点，N’代表复制链表节点 步骤3：拆分整个链表为原始链表和复制链表 把奇数位置的节点用next连接起来就是原始链表，把偶数位置的节点用next连接起来就是复制链表 Java代码1234567891011121314151617181920212223242526272829303132/*// Definition for a Node.class Node &#123; int val; Node next; Node random; public Node(int val) &#123; this.val = val; this.next = null; this.random = null; &#125;&#125;*/class Solution &#123; public Node copyRandomList(Node head) &#123; Map&lt;Node,Node&gt; map = new HashMap&lt;&gt;(); if(head==null) return head; Node first = head; while(first!=null)&#123; map.put(first,new Node(first.val)); first = first.next; &#125; first = head; while(first!=null)&#123; map.get(first).next = map.get(first.next); map.get(first).random = map.get(first.random); first = first.next; &#125; return map.get(head); &#125;&#125; Python代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849"""# Definition for a Node.class Node: def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None): self.val = int(x) self.next = next self.random = random"""class Solution: def copyRandomList(self, head: 'Node') -&gt; 'Node': self.CloneNodes(head) self.ConnectRandom(head) return self.ReconnectNodes(head) # 复制复杂链表 def CloneNodes(self,head): pNode = head while pNode: pClone = Node(pNode.val) pClone.next = pNode.next pClone.random = None pNode.next = pClone pNode = pClone.next # 复制链表random部分 def ConnectRandom(self,head): pNode = head while pNode: pClone = pNode.next if pNode.random: pClone.random = pNode.random.next pNode = pClone.next # 将复杂链表拆分成两个链表 def ReconnectNodes(self,head): pNode = head pCloneHead = None pCloneNode = None if pNode: pCloneNode = pNode.next pCloneHead = pCloneNode pNode.next = pCloneNode.next pNode = pNode.next while pNode: pCloneNode.next = pNode.next pCloneNode = pCloneNode.next pNode.next = pCloneNode.next pNode = pNode.next return pCloneHead]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Medium</tag>
        <tag>链表</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题34-二叉树中和为某一值的路径]]></title>
    <url>%2F2020%2F04%2F22%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9834-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题34-二叉树中和为某一值的路径输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。 示例： 给定如下二叉树，以及目标和 sum = 22， 1234567 5 / \ 4 8 / / \ 11 13 4 / \ / \7 2 5 1 返回 1234[ [5,4,11,2], [5,8,4,5]] 提示： 节点总数 &lt;= 10000 解题思路初始化2个全局数组，之后进行DFS递归遍历 对于TreeSearch函数： 递归参数：当前节点node，当前目标值tar 终止条件：若node为空，直接返回 递归工作： 路径更新：将node.val加入到路径path 目标值更新：tar = tar-node.val，当目标值为0时说明路径符合要求 路径记录：当node为叶子节点且路径值tar==0，则将path加入res 先序遍历：递归左右子节点 路径回溯：向上回溯前，需要将当前节点从路径path中删除，即删去path路径的最后一个节点值 Java代码123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; LinkedList&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123; TreeSearch(root,sum); return res; &#125; public void TreeSearch(TreeNode node,int tar)&#123; if(node==null) return; path.add(node.val); tar-=node.val; if(tar==0&amp;&amp;node.left==null&amp;&amp;node.right==null) res.add(new LinkedList(path)); TreeSearch(node.left,tar); TreeSearch(node.right,tar); path.removeLast(); &#125;&#125; Python代码1234567891011121314151617181920212223# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def pathSum(self, root: TreeNode, sum: int) -&gt; List[List[int]]: if not root: return []; res,stack = [],[] def TreeSearch(root,curSum): stack.append(root.val) curSum +=root.val if(curSum==sum) and not root.left and not root.right: res.append(list(stack)) if root.left: TreeSearch(root.left,curSum) if root.right: TreeSearch(root.right,curSum) stack.pop() TreeSearch(root,0) return res]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>树</tag>
        <tag>Medium</tag>
        <tag>DFS</tag>
        <tag>Python</tag>
        <tag>回溯</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题33-二叉搜索树的后序遍历序列]]></title>
    <url>%2F2020%2F04%2F22%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9833-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题33-二叉搜索树的后序遍历序列输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。 参考以下这颗二叉搜索树： 12345 5 / \ 2 6 / \1 3 示例1： 12输入: [1,6,3,2,5]输出: false 示例2： 12输入: [1,3,2,6,5]输出: true 提示： 节点总数 &lt;= 1000 解题思路递归： 二叉树中根节点的左节点始终比根节点小，右节点始终比根节点大，题目中数组末尾为根节点 通过与root节点的大小比较，能够找到左子树的边界，从而划开左右子树 在右子树中节点值始终比root节点大，如果不是，则这个序列不是后序遍历序列 当找到划分边界后进行递归，判断左子树中哪些是左节点，哪些是又节点。右子树同理 Java代码12345678910111213141516171819class Solution &#123; public boolean verifyPostorder(int[] postorder) &#123; return helper(postorder,0,postorder.length-1); &#125; public boolean helper(int[] postorder,int start,int end)&#123; if(start&gt;=end) return true; int i = 0; for(i=start;i&lt;end;i++)&#123; if(postorder[i]&gt;postorder[end]) break; &#125; for(int j = i;j&lt;end;j++)&#123; if(postorder[j]&lt;postorder[end]) return false; &#125; return helper(postorder,start,i-1)&amp;&amp;helper(postorder,i,end-1); &#125;&#125; Python代码1234567891011121314151617181920212223class Solution: def verifyPostorder(self, postorder: List[int]) -&gt; bool: length = len(postorder); if not postorder: return True root = postorder[-1] # 二叉树中左子树始终比根节点小，右子树比根节点大 # 寻找左子树边界 i = 0 for i in range(length): if postorder[i]&gt;root: break; j = i for j in range(j,length): if postorder[j]&lt;root: return False # 判断左子树是不是二叉搜索树 left = True if i&gt;0: left = self.verifyPostorder(postorder[:i]) # 判断右子树是不是二叉搜索树 right = True if i&lt;length-1: right = self.verifyPostorder(postorder[i:-1]) return left and right]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>树</tag>
        <tag>Medium</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题32-3-从上到下打印二叉树]]></title>
    <url>%2F2020%2F04%2F22%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9832-3-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题32-3-从上到下打印二叉树请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。 例如:给定二叉树: [3,9,20,null,null,15,7], ​ 3 / \ 9 20 / \ 15 7 返回其层次遍历结果： 12345[ [3], [20,9], [15,7]] 提示： 节点总数 &lt;= 1000 解题思路递推：奇数行从左到右打印，偶数行从右到左打印 用一个队列Queue保存节点，并利用一个双端队列保存行数据，如下： 将root节点放入queue 重复以下2个步骤，直到queue为空为止： 新建一个双端队列，存储行数据 当queue.size()&gt;0时开始循环： ​ 取出queue中的头结点，添加进rowList中 ​ 判断当前行是奇数行还是偶数行，由于数组是从0开始存储的，所以原本的奇数变成了偶数，偶数变成了奇 ​ 数，对于0行和2行，应该从左到右输出，所以向尾部插入新数据即可；对于1行，应该从右到左输出，所以 ​ 向头部插入新数据即可倒序 ​ 找出头结点左右子节点，依次放入queue中 添加rowList进入result数组中 Java代码12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; if (root == null) return new ArrayList(); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty()) &#123; LinkedList&lt;Integer&gt; rowlist = new LinkedList&lt;&gt;(); for (int i = queue.size(); i &gt; 0; i--) &#123; TreeNode temp = queue.poll(); //取出队列头部 if ((result.size()&amp; 0x1) == 0) &#123;// 当前是偶数行(0行2行)，行从0开始 rowlist.addLast(temp.val); //添加数据到list尾部，即从左至右顺序 &#125; else // 当前是奇数行(1行) rowlist.addFirst(temp.val);//添加数据到list头部，即从右至左顺序 if (temp.left != null) queue.add(temp.left); if (temp.right != null) queue.add(temp.right); &#125; result.add(rowlist); &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>树</tag>
        <tag>Medium</tag>
        <tag>BFS</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题32-2-从上到下打印二叉树]]></title>
    <url>%2F2020%2F04%2F22%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9832-2-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%20%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题32-2-从上到下打印二叉树从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。 例如:给定二叉树: [3,9,20,null,null,15,7], ​ 3 / \ 9 20 / \ 15 7 返回其层次遍历结果： 12345[ [3], [9,20], [15,7]] 提示： 节点总数 &lt;= 1000 解题思路方法1：递推 依然是BFS，只是要多2个List去保存结果，还需要2个变量一个记录下一层的节点数目，另一个记录当前层没有打印的节点数目 用一个队列Queue保存节点，标准BFS遍历模版如下： 将root节点放入queue，当前待打印节点数-1 重复以下2个步骤，直到queue为空为止： 取出queue中的头结点，添加进rowList中 找出头结点左右子节点，依次放入queue中，下一行节点数目+1 当前行待打印节点数==0时，说明这行节点都添加进了rowList中，将rowList添加进result，进入下一行，当前行=下一行节点数，下一行节点数清空，rowList清空，这里不能用list.clear()方法，这个方法会把对应的引用数据清掉，直接new ArrayList()即可 方法2：递归 初始化一个k作为树层数标记，对于大的list而言，每一层都是一个小list，当这个小list没有时，新建这个小list添加进头结点（大list的长度&lt;=k） 如果存在这一层的小list，就在这个小list中继续添加这一层的数据即res[depth].append(node.val) 之后进行头结点左子树和右子树的递归，每一次递归层数+1即 traversal(node.left, depth + 1) traversal(node.right, depth + 1)· Java代码12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; if(root==null) return new ArrayList(); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); List&lt;Integer&gt; row = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); int rownode = 1; int nextrow = 0; while(!queue.isEmpty())&#123; TreeNode temp = queue.poll(); row.add(temp.val); if(temp.left!=null)&#123; queue.add(temp.left); nextrow++; &#125; if(temp.right!=null)&#123; queue.add(temp.right); nextrow++; &#125; rownode--; if(rownode==0)&#123; result.add(row); rownode = nextrow; nextrow = 0; row = new ArrayList(); &#125; &#125; return result; &#125;&#125; Python代码1234567891011121314151617181920212223# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: res = [] def traversal(node, depth): if not node: return if len(res) &lt;= depth: # 如果结果集没有对应层数的列表，则先创建并将当前节点值压入 temp = [] temp.append(node.val) res.append(temp) else: # 如果有，直接压入对应层数所对应的列表 res[depth].append(node.val) traversal(node.left, depth + 1) traversal(node.right, depth + 1) traversal(root, 0) return res]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>树</tag>
        <tag>BFS</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题32-1-从上到下打印二叉树]]></title>
    <url>%2F2020%2F04%2F22%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9832-1-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题32-1-从上到下打印二叉树从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。 例如:给定二叉树: [3,9,20,null,null,15,7], ​ 3 / \ 9 20 / \ 15 7返回： 1[3,9,20,15,7] 提示： 节点总数 &lt;= 1000 解题思路BFS就完事儿了….. 用一个队列Queue保存节点，标准BFS遍历模版如下： 将root节点放入queue 重复以下2个步骤，直到queue为空为止： 取出queue中的头结点 找出头结点左右子节点，依次放入queue中 Java代码1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int[] levelOrder(TreeNode root) &#123; if(root==null) return new int[0]; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); ArrayList&lt;Integer&gt; alist = new ArrayList&lt;&gt;(); queue.add(root); while(!queue.isEmpty())&#123; TreeNode temp = queue.poll(); alist.add(temp.val); if(temp.left!=null) queue.add(temp.left); if(temp.right!=null) queue.add(temp.right); &#125; return alist.stream().mapToInt(Integer::intValue).toArray(); &#125;&#125; Python代码123456789101112131415161718# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def levelOrder(self, root: TreeNode) -&gt; List[int]: if not root: return [] quque = [root] ans = [] while quque: node = quque.pop(0) ans.append(node.val) if node.left: quque.append(node.left) if node.right: quque.append(node.right) return ans]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>树</tag>
        <tag>Medium</tag>
        <tag>BFS</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题31-栈的压入弹出序列]]></title>
    <url>%2F2020%2F04%2F21%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9831-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题31-栈的压入弹出序列输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。 示例1： 12345输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]输出：true解释：我们可以按以下顺序执行：push(1), push(2), push(3), push(4), pop() -&gt; 4,push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1 示例2： 123输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]输出：false解释：1 不能在 2 之前弹出。 限制： 0 &lt;= pushed.length == popped.length &lt;= 1000 0 &lt;= pushed[i], popped[i] &lt; 1000 pushed 是 popped 的排列。 解题思路特殊测试用例：入栈序列为空、出栈序列为空、出入栈值不相等时，返回false 辅助栈：利用一个栈来进行辅助，将入栈元素push入辅助栈，判断辅助栈内的值是否和出栈顺序相同，如果不相同就继续push入栈元素，如果相同则将辅助栈元素弹出，出栈下标加1。当入栈和出栈序列相同时，辅助栈应该为空。当找完了入栈，辅助栈不为空的情况，说明该出栈不是入栈的一个弹出序列。 Java代码12345678910111213141516class Solution &#123; public boolean validateStackSequences(int[] pushed, int[] popped) &#123; if(pushed==null||popped==null||pushed.length!=popped.length) return false; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int index = 0; for(Integer i : pushed)&#123; stack.push(i); while(!stack.isEmpty()&amp;&amp;index&lt;popped.length&amp;&amp;stack.peek().equals(popped[index]))&#123; stack.pop(); index++; &#125; &#125; return stack.isEmpty(); &#125;&#125; Python代码12345678910class Solution: def validateStackSequences(self, pushed: List[int], popped: List[int]) -&gt; bool: stack = [] j = 0 for x in pushed: stack.append(x) while stack and j &lt; len(popped) and stack[-1] == popped[j]: stack.pop() j += 1 return not stack]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Medium</tag>
        <tag>Python</tag>
        <tag>栈</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题30-包含min函数的栈]]></title>
    <url>%2F2020%2F04%2F21%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9830-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题30-包含min函数的栈定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。 示例1： 12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.min(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.min(); --&gt; 返回 -2. 提示： 各函数的调用总次数不超过 20000 次 解题思路辅助栈：数据栈再压入元素的时候与辅助栈的顶层元素(即之前数据栈的最小元素)做比较，如果比它小，就把值x同时压入数据栈和辅助栈。如果比它大，说明此时最小元素仍然是之前的最小元素，把辅助栈的栈顶取出来，数据栈压入x，辅助栈压入原本的辅助栈栈顶元素。这样就能保证辅助栈始终存放当前数据栈的最小值，在弹出数据时，同时弹出数据栈和辅助栈栈顶 Java代码123456789101112131415161718192021222324252627282930313233343536373839class MinStack &#123; private Stack&lt;Integer&gt; stack_data; private Stack&lt;Integer&gt; stack_min; /** initialize your data structure here. */ public MinStack() &#123; stack_data = new Stack&lt;&gt;(); stack_min = new Stack&lt;&gt;(); &#125; public void push(int x) &#123; stack_data.push(x); if(stack_min.size()==0||x&lt;stack_min.peek()) stack_min.push(x); else stack_min.push(stack_min.peek()); &#125; public void pop() &#123; stack_data.pop(); stack_min.pop(); &#125; public int top() &#123; return stack_data.peek(); &#125; public int min() &#123; return stack_min.peek(); &#125;&#125;/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.min(); */]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>栈</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题29-顺时针打印矩阵]]></title>
    <url>%2F2020%2F04%2F21%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9829-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题29-顺时针打印矩阵输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。本题和螺旋矩阵相同 示例1： 12输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]输出：[1,2,3,6,9,8,7,4,5] 示例2： 12输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]输出：[1,2,3,4,8,12,11,10,9,5,6,7] 限制： 0 &lt;= matrix.length &lt;= 100 0 &lt;= matrix[i].length &lt;= 100 解题思路方法1、圈层 记录左右和上下两个边界的点，按照上下左右算一圈，下一圈开始的时候初始位置+1，直到数组长度达到元素个数为止。Tips：注意几个初始点不参与遍历的变化。 首先遍历第一行，记录最左的列位置，初始化left为0，一直遍历到right为矩阵列数为止，遍历完成后此时行数应该+1，即top+1。 然后开始最右边一列的遍历，从top+1行开始，遍历到底部位置，之后应该从列数-1的位置开始下一次遍历，即right-1。然后进行底部一行的遍历，从right-1位置遍历到left位置，遍历完成之后应该从底部行向上移动开始下一次遍历，即bottom-1。 最后进行最左边一列的遍历，从bottom-1位置直到top行，这样就完成了第一圈的遍历，然后使初始left+1，到达下一圈，此时其他数个点已经缩至下一圈范围。完成之后即可得到螺旋矩阵元素。 方法2、模拟 绘制螺旋轨迹路径，我们发现当路径超出界限或者进入之前访问过的单元格时，会顺时针旋转方向。 假设数组有R 行 C 列，seen[r,c]表示第 r 行第 c 列的单元格之前已经被访问过了。当前所在位置为(r, c)，前进方向是 di。我们希望访问所有R x C 个单元格。 当我们遍历整个矩阵，下一步候选移动位置是(cr, cc)。如果这个候选位置在矩阵范围内并且没有被访问过，那么它将会变成下一步移动的位置；否则，我们将前进方向顺时针旋转之后再计算下一步的移动位置。 dx，dy分别是向右下左上移动时，行和列的变化情况，联合起来看 Java代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; public int[] spiralOrder(int[][] matrix) &#123; if(matrix.length&lt;=0) return new int[0]; int rowlen = matrix.length; int collen = matrix[0].length; int[] result = new int[rowlen*collen]; int left = 0; int right = collen-1; int top = 0; int bottom = rowlen-1; int total = 0; int x = 0; while(total!=rowlen*collen)&#123; for(int i = left;i&lt;=right;i++)&#123; result[x] = matrix[top][i]; total++; x++; &#125; if(total==rowlen*collen) break; top++; for(int i = top;i&lt;=bottom;i++)&#123; result[x] = matrix[i][right]; total++; x++; &#125; if(total==rowlen*collen) break; right--; for(int i = right;i&gt;=left;i--)&#123; result[x] = matrix[bottom][i]; total++; x++; &#125; if(total==rowlen*collen) break; bottom--; for(int i = bottom;i&gt;=top;i--)&#123; result[x] = matrix[i][left]; total++; x++; &#125; if(total==rowlen*collen) break; left++; &#125; return result; &#125;&#125; Python代码1234567891011121314151617181920class Solution: def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]: if not matrix:return [] x=y=0 # 矩阵元素位置初始化 res = [] # 初始化，存储遍历后的矩阵元素 dx = [ 0, 1, 0,-1] # 方向：右，下，左，上，x和y连起来看 dy = [ 1, 0,-1, 0] # 注：与通常平面坐标系 记号 不同 di = 0 # 初始化方向变量 visited = set() # 初始化集合，存储已走过的坐标 m,n = len(matrix),len(matrix[0]) # 矩阵的行列 for i in range(m*n): # res.append(matrix[x][y]) # 存储遍历矩阵过的元素 visited.add((x,y)) # 存储遍历过的坐标 tx,ty = x+dx[di],y+dy[di] # 先记录下一步坐标，用于判断下一步怎么走 if 0&lt;=tx&lt;m and 0&lt;=ty&lt;n and (tx,ty) not in visited: # 判断坐标是否需变向，且没有遍历过 x,y = tx,ty else: di = (di+1)%4 # 改变方向，右下左上为一圈，防止方向坐标越界 x,y = x + dx[di],y+dy[di] # 下一步坐标 return res]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>Python</tag>
        <tag>矩阵</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题28-对称的二叉树]]></title>
    <url>%2F2020%2F04%2F20%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9828-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题28-对称的二叉树请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \ 2 2 / \ / \3 4 4 3但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 / \ 2 2 \ \ 3 3 示例1： 12输入：root = [1,2,2,3,4,4,3]输出：true 示例2： 12输入：root = [1,2,2,null,3,null,3]输出：false 限制： 0 &lt;= 节点个数 &lt;= 1000 解题思路方法1：栈 利用栈一次性拿出2个节点进行比较 将左子树的left节点和右子树的right节点放入栈 之后将左子树的right节点和右子树的left节点放入栈，比较2个值是否相等 方法2：递归 终止条件： 与栈的条件类似，当L和R同时越过叶子节点(即左右子节点为null)，则这个树从顶到底都是对称的，返回True 当L和R只有一个越过叶子节点(即左/右子节点有一个为null)，则这个树不是对称的，返回False 当L和R的值不相等时，则这个树不是对称的，返回False 开启递归： 判断两个节点L.left和R.right是否是对称的 判断两个节点L.right和R.left是否是对称的 Java代码1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; if(root==null||root.left==null&amp;&amp;root.right==null) return true; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root.left); stack.push(root.right); while(!stack.isEmpty())&#123; TreeNode rightnode = stack.pop(); TreeNode leftnode = stack.pop(); // 如果两个节点都为空就跳过，说明拿出来的左右节点至少是相等的 // 如果两个节点有一个为空，则说明不是对称的，返回false if(leftnode==null&amp;&amp;rightnode==null) continue; if(leftnode==null||rightnode==null) return false; if(leftnode.val!=rightnode.val) return false; stack.push(leftnode.left); stack.push(rightnode.right); stack.push(leftnode.right); stack.push(rightnode.left); &#125; return true; &#125;&#125; Python代码123456789101112131415# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isSymmetric(self, root: TreeNode) -&gt; bool: def helper(L,R): if not L and not R: return True if not L or not R: return False if L.val != R.val: return False return helper(L.left,R.right) and helper(L.right,R.left) return helper(root.left,root.right) if root else True]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>树</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题27-二叉树的镜像]]></title>
    <url>%2F2020%2F04%2F20%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9827-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题27-二叉树的镜像请完成一个函数，输入一个二叉树，该函数输出它的镜像。 例如输入： 4 / \ 2 7 / \ / \1 3 6 9镜像输出： 4 / \ 7 2 / \ / \9 6 3 1 示例1： 12输入：root = [4,2,7,1,3,6,9]输出：[4,7,2,9,6,3,1] 限制： 0 &lt;= 节点个数 &lt;= 1000 解题思路方法1、递归： 一个二叉树的镜像就是把原本的子节点交换，一层一层来看，先要交换root节点的左右节点，然后分别交换左右节点的子节点，利用递归解决，终止条件是当遍历到左右子树为空或者头结点为空时跳出。 方法2、栈： 类似于DFS的解法，利用一个辅助栈当root为空||root的左右节点为空时返回null 初始化一个栈，存放头节点root， 然后进行循环：当stack为空的时候跳出， 之后的原理是，弹出一个节点node，找到这个节点的左右邻居节点(邻居不为空时)，并压入栈中，交换2个左右节点的值 最后返回根节点root Java代码12345678910111213141516171819202122232425/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode mirrorTree(TreeNode root) &#123; if(root==null) return root; if(root.left==null&amp;&amp;root.right==null) return root; TreeNode temp = root.left; root.left = root.right; root.right = temp; if(root.left!=null) mirrorTree(root.left); if(root.right!=null) mirrorTree(root.right); return root; &#125;&#125; Python代码123456789101112131415161718# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def mirrorTree(self, root: TreeNode) -&gt; TreeNode: if not root: return root if not root.left and not root.right: return root stack = [root] while stack: node = stack.pop() if node.left: stack.append(node.left) if node.right: stack.append(node.right) node.left,node.right = node.right,node.left return root]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>树</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题26-树的子结构]]></title>
    <url>%2F2020%2F04%2F20%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9826-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题26-树的子结构输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构) B是A的子结构， 即 A中有出现和B相同的结构和节点值。 例如:给定的树 A: 3 / \ 4 5 / \ 1 2给定的树 B： 4 / 1返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。 示例1： 12输入：A = [1,2,3], B = [3,1]输出：false 示例2： 12输入：A = [3,4,5,1,2], B = [4,1]输出：true 限制： 0 &lt;= 节点个数 &lt;= 10000 解题思路首先需要判断A和B根节点是否相同，如果相同则开启子树的匹配，如果不相同则需要判断A树的左右节点是否和B树根节点相同，再判断子树结构。 子树的判断用递归的思路来考虑，如果传入的A的根节点和B的根节点值不相同，则以A的根节点开始的子树肯定没有B子树相同的节点。如果他们的值是相同的则需要递归考虑，它们各自的左右节点的值是不是相同。 递归的终止条件是到达了树A或者树B的叶子节点，当树B的叶子节点为空的时候说明，B子树已经遍历完了，A包含B。而当A的叶子节点为空时，说明遍历完A也没有找到B子树，A不包含B Java代码1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1==null) return l2; else if(l2==null) return l1; ListNode MergeHead = null; if(l1.val&gt;l2.val)&#123; MergeHead = l2; MergeHead.next = mergeTwoLists(l1,l2.next); &#125; else&#123; MergeHead = l1; MergeHead.next = mergeTwoLists(l1.next,l2); &#125; return MergeHead; &#125;&#125; Python代码123456789101112131415161718# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode: if not l1: return l2 elif not l2: return l1 MergeHead = None if l1.val&lt;l2.val: MergeHead = l1 MergeHead.next = self.mergeTwoLists(l1.next,l2) else: MergeHead = l2 MergeHead.next = self.mergeTwoLists(l1,l2.next) return MergeHead]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>树</tag>
        <tag>Medium</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题25-合并两个排序的链表]]></title>
    <url>%2F2020%2F04%2F19%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9825-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题25-合并两个排序的链表输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。 示例： 12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 限制： 0 &lt;= 链表长度 &lt;= 1000 解题思路总共需要3个指针，一个指向链表1，一个指向链表2，一个指向头结点 首先判断两个链表的值，小的头部赋值给MergeHead，然后进行下一步的递归判断，在合并的过程中可能出现链表长短不一的情况，如果l2链表为空返回l1剩下的头部，如果l1链表为空，返回l2剩下的头部 Java代码1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1==null) return l2; else if(l2==null) return l1; ListNode MergeHead = null; if(l1.val&gt;l2.val)&#123; MergeHead = l2; MergeHead.next = mergeTwoLists(l1,l2.next); &#125; else&#123; MergeHead = l1; MergeHead.next = mergeTwoLists(l1.next,l2); &#125; return MergeHead; &#125;&#125; Python代码123456789101112131415161718# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode: if not l1: return l2 elif not l2: return l1 MergeHead = None if l1.val&lt;l2.val: MergeHead = l1 MergeHead.next = self.mergeTwoLists(l1.next,l2) else: MergeHead = l2 MergeHead.next = self.mergeTwoLists(l1,l2.next) return MergeHead]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>链表</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题24-反转链表]]></title>
    <url>%2F2020%2F04%2F19%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9824-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题24-反转链表定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。 示例： 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 限制： 0 &lt;= 节点个数 &lt;= 5000 解题思路总共需要3个指针，一个指向当前节点，一个指向前一个节点，一个指向后一个节点 局部反转，将当前节点的后一个节点保存在temp指针里，改变cur指向前一个位置pre，然后向后移动一位pre和cur Java代码1234567891011121314151617181920212223/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseList(ListNode head) &#123; if(head==null||head.next==null) return head; ListNode pre = null; ListNode cur = head; while(cur!=null)&#123; ListNode temp = cur.next; cur.next = pre; pre = cur; cur = temp; &#125; return pre; &#125;&#125; Python代码1234567891011121314151617# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def reverseList(self, head: ListNode) -&gt; ListNode: if not head or not head.next: return head pre , cur = None,head while cur: temp = cur.next cur.next = pre pre = cur cur = temp return pre]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>链表</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题22-链表中倒数第k个节点]]></title>
    <url>%2F2020%2F04%2F18%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9822-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题22-链表中倒数第k个节点输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。 示例： 123给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.返回链表 4-&gt;5. 解题思路设置2个指针，只遍历链表一次找到倒数第k个节点， 假设有n个节点，那么倒数第k个节点就是从头结点开始的第n-k+1个节点。 第一个指针从链表的头指针开始遍历向前走k-1步，第二个指针保持不动。从第k步开始，第二个指针也开始从链表的头指针开始遍历，由于两个指针的距离保持k-1，当第一个指针到达链表的尾节点时，第二个指针正好指向倒数第k个节点。 Java代码1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode getKthFromEnd(ListNode head, int k) &#123; if(head==null||k==0) return head; ListNode phead = head; ListNode pbehind = null; for(int i = 0;i&lt;k-1;i++)&#123; if(phead.next!=null) phead = phead.next; else&#123; return head; &#125; &#125; pbehind = head; while(phead.next!=null)&#123; phead = phead.next; pbehind = pbehind.next; &#125; return pbehind; &#125;&#125; Python代码1234567891011121314151617181920# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def getKthFromEnd(self, head: ListNode, k: int) -&gt; ListNode: if not head or k==0: return head phead , pafter = head,head for _ in range(k-1): if phead.next: phead = phead.next else: return head while phead.next: phead = phead.next pafter = pafter.next return pafter]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>链表</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题21-调整数组顺序使奇数位于偶数前面]]></title>
    <url>%2F2020%2F04%2F17%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9821-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题21-调整数组顺序使奇数位于偶数前面输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。 示例： 123输入：nums = [1,2,3,4]输出：[1,3,2,4] 注：[3,1,2,4] 也是正确的答案之一。 提示： 1 &lt;= nums.length &lt;= 50000 1 &lt;= nums[i] &lt;= 10000 解题思路设置2个指针，一个指向头，一个指向尾，当start&gt;end的时候，进行循环判断，前面的偶数已经和后面的奇数互换 所以前面的指针要不断寻找偶数，找到偶数位置记录下来。 后面的指针要不断寻找奇数，找到奇数的位置。 当前面是偶数后面是奇数时则满足交换条件，进行互换，这样遍历之后就将奇数全部放在了偶数之前 Java代码123456789101112131415161718192021222324class Solution &#123; public int[] exchange(int[] nums) &#123; if(nums==null||nums.length==0)&#123; return nums; &#125; int start = 0; int end = nums.length-1; while(start&lt;end)&#123; // 当前是奇数时，向后移动start，直到碰到偶数 while(start&lt;end&amp;&amp;(nums[start]&amp;0x1)!=0) start++; // 当前是偶数时，向前移动end，直到碰到奇数 while(start&lt;end&amp;&amp;(nums[end]&amp;0x1)==0) end--; // 当start和end是前偶后奇时，交换2个数位置 if(start&lt;end)&#123; int temp = nums[start]; nums[start] = nums[end]; nums[end] = temp; &#125; &#125; return nums; &#125;&#125; Python代码123456789101112131415class Solution: def exchange(self, nums: List[int]) -&gt; List[int]: if not nums or len(nums)==0: return nums; start ,end = 0, len(nums)-1 while start&lt;end: while start&lt;end and (nums[start]&amp;0x1)!=0: start +=1 while start&lt;end and (nums[end]&amp;0x1)==0: end -=1 if start&lt;end: temp = nums[start] nums[start] = nums[end] nums[end] = temp return nums]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Easy</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题20-表示数值的字符串]]></title>
    <url>%2F2020%2F04%2F17%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9820-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题20-表示数值的字符串请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”0123”及”-1E-16”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”及”12e+5.4”都不是。 解题思路一位一位进行判断，字符串遵循模式A[.[B]][e|EC]或者.[B][e|EC] 其中A和C都是可能以+或者-开头的0~9的数位串 B也是0~9的数位串，但是不能带有正负号 C紧跟着’e’或者’E’为数值的指数部分 判断一个字符串是否符合上述模式时，首先尽可能多地扫描0~9的数位(有可能在起始处有’+’或’-‘，也就是前面模式中表示数值整数的A部分)，如果遇到小数点’.’，则开始扫描表示数值小数部分的B部分，如果遇到’e’或者’E’，则开始扫描表示数值指数的C部分 Java代码123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public boolean isNumber(String s) &#123; if(s==null||s.length()==0) return false; boolean isNum = false; boolean isDot = false; boolean isE = false; char[] str = s.trim().toCharArray(); for(int i = 0;i &lt; str.length;i++)&#123; if(str[i]&gt;='0'&amp;&amp;str[i]&lt;='9')&#123; isNum = true; &#125; else if('.'==str[i])&#123; // .的前面不能有.或者E if(isDot||isE) return false; isDot = true; &#125; else if(str[i]=='e'||str[i]=='E')&#123; // e或E的前面不能有e/E，只能是数字 if(isE||isNum==false) return false; isE = true; // 越过e之后必须要有数字，重置isNum，记录后面是不是有数字出现 // 如果e是最后一位，则这个数字不合法 isNum = false; &#125; else if(str[i]=='+'||str[i]=='-')&#123; // 只有i=0或者e/E前面出现正负号的时候才合法，不然就是非法 if(i!=0&amp;&amp;str[i-1]!='e'&amp;&amp;str[i-1]!='E') return false; &#125; else&#123; // 其他非法情况 return false; &#125; &#125; return isNum; &#125;&#125; Python代码12345678910111213141516171819202122232425262728293031323334class Solution: def __init__(self): self.p = 0 def isNumber(self, s: str) -&gt; bool: s = s.strip() if not s: return False numeric = self.scanInteger(s) if self.p &gt; len(s)-1: return numeric if self.p &lt; len(s) and s[self.p] == '.': self.p +=1 if self.p &gt; len(s)-1: return numeric numeric = self.scanUnsignedIntergers(s) or numeric if self.p &lt; len(s) and s[self.p] in ['e','E']: self.p +=1 if self.p &gt; len(s)-1: return False numeric = numeric and self.scanInteger(s) if self.p &lt; len(s): return False return numeric def scanInteger(self,s): if s[self.p] in ['+','-']: self.p +=1 return self.scanUnsignedIntergers(s) def scanUnsignedIntergers(self,s): pre = self.p while(self.p &lt; len(s) and s[self.p]&gt;='0' and s[self.p]&lt;='9'): self.p +=1 return self.p&gt;pre]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Medium</tag>
        <tag>字符串</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题19-正则表达式匹配]]></title>
    <url>%2F2020%2F04%2F16%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9819-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题19-正则表达式匹配给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。 123&apos;.&apos; 匹配任意单个字符&apos;*&apos; 匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。 说明: s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。 示例1 12345输入:s = &quot;aa&quot;p = &quot;a&quot;输出: false解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。 示例2 12345输入:s = &quot;aa&quot;p = &quot;a*&quot;输出: true解释: 因为 &apos;*&apos; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &apos;a&apos;。因此，字符串 &quot;aa&quot; 可被视为 &apos;a&apos; 重复了一次。 示例3 12345输入:s = &quot;ab&quot;p = &quot;.*&quot;输出: true解释: &quot;.*&quot; 表示可匹配零个或多个（&apos;*&apos;）任意字符（&apos;.&apos;）。 示例4 12345输入:s = &quot;aab&quot;p = &quot;c*a*b&quot;输出: true解释: 因为 &apos;*&apos; 表示零个或多个，这里 &apos;c&apos; 为 0 个, &apos;a&apos; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。 示例5 1234输入:s = &quot;mississippi&quot;p = &quot;mis*is*p*.&quot;输出: false 解题思路方法1、暴力递归(Python)： 如果p为空，s也为空匹配，s不为空不匹配 s非空，p的首字母和s首字母或者.匹配，first=true 判断如果p[1]不是*，则不需要考虑p[0]位置，直接进行下一位递归匹配 如果p[1]==*，则有两种情况匹配 匹配*号前的字符0次，说明前面这个字符不需要，我们要跳过ch*去匹配后面的，即isMatch(s,p[2:]) 匹配*号前的字符1次，说明前面这个字符至少出现了一次，s移动一位，继续使用匹配后面的 方法2、动态规划(Java)： 不会写….copy自评论区 Java代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123; public boolean isMatch(String s, String p) &#123; int slen=s.length(); int plen=p.length(); if(slen==0&amp;&amp;plen==0)return true; //if(slen==0||plen==0)return false; boolean[][] dp=new boolean[slen+1][plen+1]; //dp[i][j]表示s的0到i-1和p的0到j-1是否匹配 dp[0][0]=true; //初始化s=0 for(int j=1;j&lt;=plen;j++)&#123; //当s为空时，a*b*c*可以匹配 //当判断到下标j-1是*，j-2是b，b对应f，要看之前的能否匹配 //比如a*b*下标依次为ftft，b之前的位t，所以j-1也是true //即dp[0][j]对应的下标j-1位true if(j==1)dp[0][j]=false; if(p.charAt(j-1)=='*'&amp;&amp;dp[0][j-2])dp[0][j]=true; &#125; //for循环当s长度为1时能否匹配，一直到s长度为slen for(int i=1;i&lt;=slen;i++)&#123; for(int j=1;j&lt;=plen;j++)&#123; //最简单的两种情况 字符相等或者p的字符是‘.' if(s.charAt(i-1)==p.charAt(j-1)||p.charAt(j-1)=='.')&#123; dp[i][j]=dp[i-1][j-1]; &#125; //p当前字符是*时，要判断*前边一个字符和s当前字符 else if(p.charAt(j-1)=='*')&#123; if(j&lt;2)dp[i][j]=false; //如果p的*前边字符和s当前字符相等或者p的字符是‘.' //三种可能 //匹配0个，比如aa aaa*也就是没有*和*之前的字符也可以匹配上（在你（a*）没来之前我们(aa)已经能匹配上了）dp[i][j]=dp[i][j-2] //匹配1个，比如aab aab* 也就是*和*之前一个字符只匹配s串的当前一个字符就不看*号了 即 dp[i][j]=dp[i][j-1] //匹配多个，比如aabb aab* b*匹配了bb两个b 那么看aab 和aab*是否能匹配上就行了，即dp[i][j]=dp[i-1][j] if(p.charAt(j-2)==s.charAt(i-1)||p.charAt(j-2)=='.')&#123; dp[i][j]=dp[i-1][j]||dp[i][j-1]||dp[i][j-2]; &#125; //如果p的*前边字符和s当前字符不相等或者p的字符不是‘.'，那就把*和*前边一个字符都不要了呗 //你会发现不管是这种情况还是上边的情况都会有dp[i][j]=dp[i][j-2];所以可以把下边剪枝，不用分开写了 //这里分开写是为了好理解 else if(p.charAt(j-2)!=s.charAt(i-1)&amp;&amp;p.charAt(j-2)!='.')&#123; dp[i][j]=dp[i][j-2]; &#125; &#125; //其他情况肯定不能匹配上了 直接false 比如 aba abb*c else&#123; dp[i][j]=false; &#125; &#125; &#125; return dp[slen][plen]; &#125;&#125; Python代码12345678910111213141516171819class Solution: def isMatch(self, s: str, p: str) -&gt; bool: if not p: return not s first = bool(s) and p[0] in &#123;s[0], '.'&#125; # 解释：如果发现有字符和 '*' 结合， if len(p) &gt;= 2 and p[1] == '*': # 或者匹配该字符 0 次，然后跳过该字符和 '*' return self.isMatch(s, p[2:]) or \ # 或者当 pattern[0] 和 string[0] 匹配后，移动 string first and self.isMatch(s[1:], p) else: return first and self.isMatch(s[1:], p[1:])if __name__ == '__main__': s = input().strip() p = input().strip() so = Solution() output = so.isMatch(s, p)]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>字符串</tag>
        <tag>DP</tag>
        <tag>Hard</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-83-删除排序链表中的重复元素]]></title>
    <url>%2F2020%2F04%2F15%2FLeetCode-83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[LeetCode-83-删除排序链表中的重复元素给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 示例 1: 12输入: 1-&gt;1-&gt;2输出: 1-&gt;2 示例 2: 12输入: 1-&gt;1-&gt;2-&gt;3-&gt;3输出: 1-&gt;2-&gt;3 解题思路初始化1个指针，指向头部，判断后一个数和前一个是不是相等，相等则要把后面一个数覆盖前面一个数，当发现不相等时，cur指针顺移1位，即对于1、1、2、3、3这样的数据，cur会将后一个重复的数字替换前一个重复数字，当重复数字之后一位数不和当前相等时，cur指针改变指向到下一个数，再进行重复判断。 Java代码1234567891011121314151617181920212223/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if(head==null||head.next==null) return head; ListNode cur = head; while(cur.next!=null)&#123; if(cur.next.val==cur.val)&#123; cur.next = cur.next.next; &#125; else&#123; cur = cur.next; &#125; &#125; return head; &#125;&#125; Python代码123456789101112131415# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def deleteDuplicates(self, head: ListNode) -&gt; ListNode: cur = head; while cur and cur.next: if cur.next.val==cur.val: cur.next = cur.next.next else: cur = cur.next return head]]></content>
      <categories>
        <category>链表</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>链表</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题18-删除链表的节点]]></title>
    <url>%2F2020%2F04%2F15%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9818-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题18-删除链表的节点给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。 返回删除后的链表的头节点。 示例1 123输入: head = [4,5,1,9], val = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9. 示例2 123输入: head = [4,5,1,9], val = 1输出: [4,5,9]解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9. 说明: 题目保证链表中节点的值互不相同 若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点 解题思路没有O(1)的时间复杂度要求，顺序查找，头结点是查找值直接返回，如果不是则继续找，指针指向查找数的前一个位置，如果没有找完了都没有找到，循环依然是要跳出的，此时res.next==null，就不需要对链表进行修改，所以只有！=null的时候才有删除操作 Java代码1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode deleteNode(ListNode head, int val) &#123; if (head == null) &#123; return head; &#125; if (head.val == val) &#123; return head.next; &#125; ListNode res = head; while(res.next!=null&amp;&amp;res.next.val!=val)&#123; res = res.next; &#125; if(res.next!=null)&#123; res.next = res.next.next; &#125; return head; &#125;&#125; Python代码123456789101112131415# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def deleteNode(self, head: ListNode, val: int) -&gt; ListNode: if head.val == val: return head.next res = head while res.next and res.next.val!=val: res = res.next if res.next: res.next = res.next.next return head]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>链表</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-415-字符串相加]]></title>
    <url>%2F2020%2F04%2F15%2FLeetCode-415-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[LeetCode-415-字符串相加给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。 注意： num1 和num2 的长度都小于 5100. num1 和num2 都只包含数字 0-9. num1 和num2 都不包含任何前导零。 你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。 解题思路两数相加可以看成一个大数问题，只是这里是String类型的，思路都差不多。直接从字符串尾部开始遍历，设置一个进位符号，如果三者相加比10大说明有进位，此时的数应该%10即可，符号为设置为1，当没有进位的时候设置为0。两个字符串可能不是等长的，超过遍历的情况默认为0。循环结束之后，符号位为1的话说明最高位要进1 Java代码12345678910111213141516171819202122class Solution &#123; public String addStrings(String num1, String num2) &#123; int alen = num1.length()-1,blen = num2.length()-1,carry = 0; StringBuilder res = new StringBuilder(); while(alen&gt;=0||blen&gt;=0)&#123; int n1 = alen&gt;=0?num1.charAt(alen)-'0':0; int n2 = blen&gt;=0?num2.charAt(blen)-'0':0; int sum = n1+n2+carry; if(sum&gt;=10)&#123; carry = 1; res.append(sum%10); &#125;else&#123; carry = 0; res.append(sum); &#125; alen--; blen--; &#125; if(carry==1) res.append(1); return res.reverse().toString(); &#125;&#125; Python代码12345678910111213class Solution: def addStrings(self, num1: str, num2: str) -&gt; str: alen,blen,carry = len(num1)-1,len(num2)-1,0 res = ""; while alen&gt;=0 or blen&gt;=0: n1 = int(num1[alen]) if alen&gt;=0 else 0 n2 = int(num2[blen]) if blen&gt;=0 else 0 sum = n1+n2+carry carry = sum//10 res = str(sum%10)+res alen = alen-1 blen = blen-1 return "1"+res if carry else res]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>字符串</tag>
        <tag>Python</tag>
        <tag>大数问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题17-打印从1到最大的n位数]]></title>
    <url>%2F2020%2F04%2F14%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9817-%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题17-打印从1到最大的n位数输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。 示例1 12输入: n = 1输出: [1,2,3,4,5,6,7,8,9] 说明: 用返回一个整数列表来代替打印 n 为正整数 解题思路这题本身是个大数问题，先写个不是大数的偷懒版本，10的n次方-1就是n位数的最大数，依次遍历存储即可。 大数解法：n位所有十进制数都是0~9的数字的全排列，对于不足两位的数字前面补0，固定首位，从0~9调整后面一位。用递归来进行表达，结束条件是设置了数字的最后一位。 抽象成树就是第一行表示数字首位0~9的节点，比如n=1，则根节点只有一个0。n=2，根节点有2个，一个是0，一个是1，先从0开始深度搜，再固定第一位是1，往下从0~9深度搜。直到9出现（即当前设置位=数组长度）表示设置了最后一位。 Java代码112345678910class Solution &#123; public int[] printNumbers(int n) &#123; int sum = (int)Math.pow(10,n); int[] num = new int[sum-1]; for(int i=0;i&lt;sum-1;i++)&#123; num[i]=i+1; &#125; return num; &#125;&#125; Java代码2123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; public int[] printNumbers(int n) &#123; char[] num = new char[n]; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); // 数组初始化 for(int i =0;i &lt; n;i++)&#123; num[i] = '0'; &#125; DFS(num,res,0); // 去除1位数情况开始的0 res.remove(0); int[] resInt = res.stream().mapToInt(Integer::valueOf).toArray(); return resInt; &#125; public void DFS(char[] num,List&lt;Integer&gt; res,int index)&#123; // 终止条件 if(index == num.length)&#123; int n = save(num); res.add(n); return; &#125; for(int i=0;i&lt;10;i++)&#123; // 首数字初始化 num[index] = (char)(i+'0'); // 固定首数字，找个位数可能性 DFS(num,res,index+1); &#125; &#125; public int save(char[] num)&#123; int n = 0; for(int i=0;i&lt;num.length;i++)&#123; // 首位不是补齐的0时，即位数！=1 if(num[i]!='0')&#123; for(int j=i;j&lt;num.length;j++)&#123; n = n*10+num[j]-'0'; &#125; break; &#125; &#125; return n; &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Medium</tag>
        <tag>大数问题</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题16-数值的整数次方]]></title>
    <url>%2F2020%2F04%2F14%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9816-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题16-数值的整数次方实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。 示例1 12输入: 2.00000, 10输出: 1024.00000 示例2 12输入: 2.10000, 3输出: 9.26100 示例3 123输入: 2.00000, -2输出: 0.25000解释: 2-2 = 1/22 = 1/4 = 0.25 说明: -100.0 &lt; x &lt; 100.0 n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 解题思路特殊值，x为0，n为0，没有意义返回1。n&lt;0的时候要变换符号，但是这道题有个特殊的测试用例超出了int范围，拿一个long类型的作为中间变量存储 传统的思路就是n多大就循环多少次，累乘一起就是结果，这种方法超时了。说明需要一个更加有效率的解法 于是上了递归…..栈溢出了emmmm不知道是不是写错了，又换了一个写法。具体思路如下，对于一个次方数比如32，只需要求得16，8，4，2次方的数值即可获得32次方的数值，2次方的平方是4次方，4次方的平方是8次方，8次方的平方是16次方，16次方的平方是32次方。这是偶数的情况，奇数的情况会多乘一次x本身。 奇数有一个特点就是%2==1，也可以算成与运算&amp;1==1，做除法/2也可以等价于移位&gt;&gt;1，位运算本身要更快一些。 Java代码123456789101112131415161718class Solution &#123; public double myPow(double x, int n) &#123; double result = 1.0; if (x == 0.0 &amp;&amp; n == 0.0) return 1.0; long num = n; if (num &lt; 0) &#123; num = -num; x = 1 / x; &#125; while (num &gt; 0) &#123; if ((num &amp; 1) == 1) result *= x; x *= x; num &gt;&gt;= 1; &#125; return result; &#125;&#125; Python代码12345678910class Solution: def myPow(self, x: float, n: int) -&gt; float: if x == 0: return 0 res = 1 if n &lt; 0: x, n = 1 / x, -n while n: if n &amp; 1: res *= x x *= x n &gt;&gt;= 1 return res]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Medium</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-67-二进制求和]]></title>
    <url>%2F2020%2F04%2F14%2FLeetCode-67-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C%2F</url>
    <content type="text"><![CDATA[LeetCode-67-二进制求和给你两个二进制字符串，返回它们的和（用二进制表示）。 输入为 非空 字符串且只包含数字 1 和 0。 示例 1: 12输入: a = &quot;11&quot;, b = &quot;1&quot;输出: &quot;100&quot; 示例 2: 12输入: a = &quot;1010&quot;, b = &quot;1011&quot;输出: &quot;10101&quot; 提示： 每个字符串仅由字符 ‘0’ 或 ‘1’ 组成。 1 &lt;= a.length, b.length &lt;= 10^4 字符串如果不是 “0” ，就都不含前导零。 解题思路不适用思路：二进制转十进制，十进制相加转二进制，容易溢出直接淘汰。 先把两个字符串长度对齐，设置一个进位符号falg=0，从两个字符串的末尾开始逐一相加，除此之外还要加上进位，如果3者之和&gt;=2，说明此处有进位，设置falg=1，往字符串中添加数字和对2求余的结果就是当前的位置的值。最后如果有进位则添加1，翻转字符串后就是结果。 Python偷个懒哈哈哈~ Java代码12345678910111213141516171819202122232425262728293031class Solution &#123; public String addBinary(String a, String b) &#123; int alen = a.length(); int blen = b.length(); while (alen &gt; blen) &#123; b = '0' + b; blen++; &#125; while (alen &lt; blen) &#123; a = '0' + a; alen++; &#125; StringBuilder res = new StringBuilder(); int falg = 0; for (int i = alen - 1; i &gt;= 0; i--) &#123; int sum = falg + a.charAt(i) + b.charAt(i) - '0'; if (sum&gt;= '2') &#123; res.append(sum%2); falg = 1; &#125; else &#123; res.append(sum%2); falg = 0; &#125; &#125; if (falg == 1) &#123; res.append(1); &#125; return res.reverse().toString(); &#125;&#125; Python代码123class Solution: def addBinary(self, a: str, b: str) -&gt; str: return bin(int(a,2)+int(b,2))[2:]]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>字符串</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题15-二进制中1的个数]]></title>
    <url>%2F2020%2F04%2F14%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9815-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题15-二进制中1的个数请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。 示例1 123输入：00000000000000000000000000001011输出：3解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &apos;1&apos;。 示例2 123输入：00000000000000000000000010000000输出：1解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &apos;1&apos;。 示例3 123输入：11111111111111111111111111111101输出：31解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &apos;1&apos;。 解题思路实际上把二进制不断向右移动和1求与运算就可以得到所有1了，但是这样不适用于负整数的情况。 换一个思路把1左移一位，右边始终是加0，跟n求与运算得到所有的1，这种是有多少位数循环多少次。 一种更好的方法是，把n减去1，再和原本的n做与运算，会把n最右边的1变为0，有多少1就会执行多少次。 Java代码12345678910111213public class Solution &#123; // you need to treat n as an unsigned value public int hammingWeight(int n) &#123; int count = 0; int flag = 1; while(flag!=0)&#123; if((n&amp;flag)!=0) count++; flag = flag&lt;&lt;1; &#125; return count; &#125;&#125; Python代码1234567class Solution: def hammingWeight(self, n: int) -&gt; int: count = 0 while n: n = (n-1)&amp;n count+=1 return count]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题14-2-剪绳子(大数)]]></title>
    <url>%2F2020%2F04%2F13%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9814-2-%E5%89%AA%E7%BB%B3%E5%AD%90(%E5%A4%A7%E6%95%B0)%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题14-2-剪绳子(大数)给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m] 。请问 k[0]k[1]…k[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例1 123输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1 示例2 123输入: 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36 提示: 2 &lt;= n &lt;= 1000 解题思路这个题和上个题主体一样，但是是求的大数环境下，求指数就超过int的区间了，需要求模。还是尽可能的多切长度为3的，最后把不足3的乘上就是结果，都要求余 Java代码112345678910111213class Solution &#123; public int cuttingRope(int n) &#123; if(n&lt;=3) return n-1; long product = 1; while(n&gt;4)&#123; product *=3; product = product%1000000007; n-=3; &#125; return (int)(product*n%1000000007); &#125;&#125; Python代码123456789class Solution: def cuttingRope(self, n: int) -&gt; int: if(n&lt;=3): return n-1 dp = [0 for i in range(n+1)] dp[0],dp[1],dp[2],dp[3]= 0,1,2,3 for i in range(4, n+1): for j in range(1, i // 2+1): dp[i] = max(dp[i],(dp[j]*dp[i-j])) return dp[n] % 1000000007]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Medium</tag>
        <tag>DP</tag>
        <tag>Python</tag>
        <tag>贪心算法</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题14-1-剪绳子]]></title>
    <url>%2F2020%2F04%2F13%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9814-1-%E5%89%AA%E7%BB%B3%E5%AD%90%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题14-1-剪绳子给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m] 。请问 k[0]k[1]…k[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 示例1 123输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1 示例2 123输入: 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36 提示: 2 &lt;= n &lt;= 58 解题思路方法1、动态规划 整体目标为最大化f(n)=max(f(i) x f(n-i))，可以看成递归自顶向下解决，但是这样会有很多重复计算。一个更好的方法是自底向上，把小的子问题最优解，然后再往上计算，子问题要存储起来，避免重复的计算过程。对于f(0)~f(3)，最优解的值是n-1，对于n&gt;=4的数，比如4，可以切分为1，2，3的数字组合，于是dp[1]，dp[2]，dp[3]分别等于1，2，3。这里的dp[3]不等于最优解2，因为切分4并不需要对数字3再次切分。 另外一种解释是把线切的方法分为切成2段或者切成很多段，切成2段的乘积可以表示为第一段长度j，第二段长度i-j。切成多段的乘积可以表示为第一段长度为j，第二段长度为f(j-i)。到底是切2段大还是切多段大，用max函数比较一下。同时与现存的dp[i]的值比较，取最大的值。如Java代码2所示，也能够解决。 方法2、贪心算法 切的时候尽可能的使乘积最大，当n&gt;=5时，尽可能多切长度为3的绳子；当剩下的长度为4时，切成2段长度为2的绳子，之后乘积就是切成3的次数*切成2的次数 Java代码11234567891011121314151617181920class Solution &#123; public int cuttingRope(int n) &#123; // 此处计算f(0)~f(3)的最优解 if(n &lt; 4) return n-1; int[] dp = new int[n+1]; // 当n&gt;=4时，切分的长度有1，2，3的可能，dp[3]并不是代表f(3)的最优解 // 因为长度为1、2、3的线是4的子集，不需要再切分 dp[0] = 0; dp[1] = 1; dp[2] = 2; dp[3] = 3; for(int i=4;i&lt;=n;i++)&#123; for(int j=1;j&lt;=i/2;j++)&#123; dp[i] = Math.max((dp[j]*dp[i-j]),dp[i]); &#125; &#125; return dp[n]; &#125;&#125; Java代码2123456789101112class Solution &#123; public int cuttingRope(int n) &#123; int[] dp = new int[n + 1]; dp[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; for (int j = 1; j &lt; i; j++) &#123; dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j])); &#125; &#125; return dp[n]; &#125;&#125; Python代码12345678910class Solution: def cuttingRope(self, n: int) -&gt; int: if(n&lt;=3): return n-1 # 尽可能多的剪去长度为3的绳子 count3 = n//3 # 当绳子剩下的长度为4时，不再剪去长度为3的绳子，因为2x2&gt;3x1，剪为3的次数减少1次 if(n-count3*3): count3-=1 # 重新计算差值，计算剪为2的次数 count2 = (n-count3*3)//2 return int(math.pow(3,count3)*math.pow(2,count2))]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Medium</tag>
        <tag>DP</tag>
        <tag>Python</tag>
        <tag>贪心算法</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题13-机器人的运动范围]]></title>
    <url>%2F2020%2F04%2F12%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9813-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题13-机器人的运动范围地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？ 示例1 12输入：m = 2, n = 3, k = 1输出：3 示例2 12输入：m = 3, n = 1, k = 0输出：1 提示: 1 &lt;= n,m &lt;= 100 0 &lt;= k &lt;= 20 解题思路除了边界以外，其他格子都可以上下左右移动，这道题可以简化为向右和向下移动。 这是因为随着限制条件 k 的增大，(0, 0) 所在的蓝色方格区域内新加入的非障碍方格都可以由上方或左方的格子移动一步得到。 在递归深度优先搜索的时候，需要进行数位和运算，约束不能去的格子。对于传入的数字，其对10求余得到个位数，之后除以10，类似右移一位挤掉本来的个位数，再对10求余即可得到十位数。循环下来就是单个数字的数位和。 广度优先搜索也可以，这里采用一个基本的广度优先搜索策略，步骤如下把起始节点放入queue，之后从queue中取出队列头的格子，当格子符合数位和要求的时候就添加进set中，找出与取出格子相邻的上下左右的格子(这里只需要右边和下边的格子即可)，把它们放入到queue中，重复这个过程到queue为空为止。 Java代码1234567891011121314151617181920212223242526class Solution &#123; int count = 0; public int movingCount(int m, int n, int k) &#123; boolean[][] visited = new boolean[m][n]; dfs(0,0,m,n,k,visited); return count; &#125; public void dfs(int i,int j,int m,int n,int k,boolean[][] visited)&#123; if(i&gt;=0&amp;&amp;i&lt;m&amp;&amp;j&gt;=0&amp;&amp;j&lt;n&amp;&amp;sumNum(i)+sumNum(j)&lt;=k&amp;&amp;visited[i][j]==false)&#123; count++; visited[i][j] = true; dfs(i+1,j,m,n,k,visited); dfs(i,j+1,m,n,k,visited); &#125; &#125; public int sumNum(int num)&#123; int sum = 0; while(num&gt;0)&#123; sum+=num%10; num/=10; &#125; return sum; &#125;&#125; Python代码1234567891011121314151617181920from queue import Queueclass Solution: def movingCount(self, m: int, n: int, k: int) -&gt; int: q = Queue() q.put((0,0)) s = set() while not q.empty(): i , j = q.get() if (i, j) not in s and 0&lt;=i&lt;m and 0&lt;=j&lt;n and self.sumNum(i)+self.sumNum(j)&lt;=k: s.add((i,j)) for x,y in [(i+1,j),(i,j+1)]: q.put((x,y)) return len(s) def sumNum(self,n): sum = 0 while n: sum += n % 10 n //= 10 return sum]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Medium</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题12-矩阵中的路径]]></title>
    <url>%2F2020%2F04%2F10%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9812-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题12-矩阵中的路径请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。 [[“a”,”b“,”c”,”e”],[“s”,”f“,”c“,”s”],[“a”,”d”,”e“,”e”]] 但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。 示例1 12输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;输出：true 示例2 12输入：board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word = &quot;abcd&quot;输出：false 提示： 1 &lt;= board.length &lt;= 200 1 &lt;= board[i].length &lt;= 200 解题思路找路径可以用回溯法，递归实现。在矩阵中选择任意一个格子作为路径的七点，假设矩阵中某个格子的字符为ch，并且这个格子将对应于路径上的第i个字符。如果路径上的第i个字符不是ch，那么这个格子不可能处在路径上的第i个位置。如果路径上的第i个字符正好是ch，那么到相邻的格子寻找路径上的第i+1个字符。除矩阵边界上的格子之外，其他格子都有4个相邻的格子，重复这个过程，直到路径上的所有字符都在矩阵中找到相应的位置。 需要递归的部分则是搜索一个格子的上下左右位置有没有下一个字符，如果都没有则说明当前位置不正确，范围上一个位置再进行搜索。 Java代码1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public boolean exist(char[][] board, String word) &#123; int rowlen = board.length; int collen = board[0].length; boolean[][] visited = new boolean[rowlen][collen]; int pathlen = 0; for (int row = 0; row &lt; rowlen; row++) &#123; for (int col = 0; col &lt; collen; col++) &#123; if (searchPath(board, row, rowlen, col, collen, word, visited, pathlen)) &#123; return true; &#125; &#125; &#125; return false; &#125; public boolean searchPath(char[][] board, int row, int rowlen, int col, int collen, String word, boolean[][] visited, int pathlen) &#123; if (pathlen == word.length()) return true; boolean falg = false; if (row &gt;= 0 &amp;&amp; row &lt; rowlen &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; collen &amp;&amp; board[row][col] == word.charAt(pathlen) &amp;&amp; !visited[row][col]) &#123; pathlen++; visited[row][col] = true; falg = searchPath(board, row - 1, rowlen, col, collen, word, visited, pathlen) || searchPath(board, row + 1, rowlen, col, collen, word, visited, pathlen) || searchPath(board, row, rowlen, col - 1, collen, word, visited, pathlen) || searchPath(board, row, rowlen, col + 1, collen, word, visited, pathlen); // 当都没有找到的时候，返回上一个位置 if (!falg) &#123; pathlen--; visited[row][col] = false; &#125; &#125; return falg; &#125;&#125; Python代码1234567891011121314class Solution: def exist(self, board: List[List[str]], word: str) -&gt; bool: def dfs(i, j, k): if not 0 &lt;= i &lt; len(board) or not 0 &lt;= j &lt; len(board[0]) or board[i][j] != word[k]: return False if k == len(word) - 1: return True tmp, board[i][j] = board[i][j], '/' res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1) board[i][j] = tmp return res for i in range(len(board)): for j in range(len(board[0])): if dfs(i, j, 0): return True return False]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
        <tag>Python</tag>
        <tag>回溯</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题11-旋转数组的最小数字]]></title>
    <url>%2F2020%2F04%2F10%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9811-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题11-旋转数组的最小数字把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 示例1 12输入：[3,4,5,1,2]输出：1 示例2 12输入：[2,2,2,0,1]输出：0 解题思路方法1、类似于二分查找的方法： 旋转之后的数组实际上可以划分为两个排序的子数组，最小的元素刚好是这两个子数组的分界线。知道这个之后就沿用二分查找的方法，逐渐缩小范围，结合数组的递增规律，当两个指针差值为1的时候，end位置就是最小数。 其次是两个特例： 当不需要把元素移动到后面的时候，数组为排序好的数组且是递增的，所以第一个位置就是最小的。 当前中后3个位置都是相等的时候，这时用二分查找就行不通了，转化为顺序查找 方法2、循环二分(摘自Leetcode大佬题解)： 分析见原文，j = j-1厉害了！ Java代码123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public int minArray(int[] numbers) &#123; if (numbers.length == 0) &#123; return -1; &#125; int start = 0; int end = numbers.length - 1; int middle = start; // 考虑前面0个元素搬到后面，则数组为排序数组，第一个即最小 while (numbers[start] &gt;= numbers[end]) &#123; if (end - start == 1) &#123; middle = end; break; &#125; middle = (start + end) / 2; // 当前中后相等时，这时候只能顺序搜索 if (numbers[start] == numbers[end] &amp;&amp; numbers[start] == numbers[middle]) &#123; return search(numbers, start, end); &#125; if (numbers[middle] &gt;= numbers[start]) &#123; start = middle; &#125; else if (numbers[middle] &lt;= numbers[end]) &#123; end = middle; &#125; &#125; return numbers[middle]; &#125; public int search(int[] numbers, int start, int end) &#123; int result = numbers[start]; for (int i = start + 1; i &lt;= end; i++) &#123; if (result &gt; numbers[i]) &#123; result = numbers[i]; &#125; &#125; return result; &#125;&#125; Python代码12345678910111213class Solution(object): def minArray(self, numbers): """ :type numbers: List[int] :rtype: int """ i, j = 0, len(numbers) - 1 while i &lt; j: m = (i + j) // 2 if numbers[m] &gt; numbers[j]: i = m + 1 elif numbers[m] &lt; numbers[j]: j = m else: j -= 1 return numbers[i]]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Easy</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-704-二分查找]]></title>
    <url>%2F2020%2F04%2F10%2FLeetCode-704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[LeetCode-704-二分查找给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例1 123输入: nums = [-1,0,3,5,9,12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4 示例2 123输入: nums = [-1,0,3,5,9,12], target = 2输出: -1解释: 2 不存在 nums 中因此返回 -1 提示： 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。` 解题思路二分查找是一个基本算法，简单来说就是头尾2个指针，看中间数比查找数大还是小，大的话说明要在右边范围找，小的话就要在左边范围找。 Java代码12345678910111213141516171819class Solution &#123; public int search(int[] nums, int target) &#123; if (nums.length == 0) &#123; return -1; &#125; int start = 0; int end = nums.length - 1; while (start &lt;= end) &#123; int middle = (start + end) / 2; if (target == nums[middle]) return middle; else if (target &lt; nums[middle]) end = middle - 1; else start = middle + 1; &#125; return -1; &#125;&#125; Python代码12345678910111213141516171819class Solution(object): def search(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ if (len(nums)==0): return -1 start,end = 0,len(nums)-1 while(start&lt;=end): middle = (start+end)/2 if target==nums[middle]: return middle elif target&lt;nums[middle]: end = middle-1 else: start = middle+1 return -1]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>Python</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题10-2-青蛙跳台阶]]></title>
    <url>%2F2020%2F04%2F08%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9810-2-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题10-2-青蛙跳台阶一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 一定记得取余! 示例1 12输入：n = 2输出：2 示例2 12输入：n = 7输出：21 提示： 0 &lt;= n &lt;= 100 解题思路青蛙可以跳1级台阶，也可以跳2级台阶。把跳n级台阶时的跳发看成n的函数，即为f(n)。当n&gt;2时，第一次跳有2种不同的选择：一是第一次只跳1级，此时跳法数目等于后面剩下的n-1级台阶的跳法数目，即为f(n-1)；二是第一次跳2级，此时跳法数目等于后面剩下的n-2级台阶的跳发数目，即f(n-2)。因此n级台阶的不同跳法的总数为f(n)=f(n-1)+f(n-2)。不难看出这是一个斐波那契数列问题 Java代码123456789101112131415161718class Solution &#123; public int numWays(int n) &#123; int[] result = new int[]&#123;1, 1&#125;; if (n &lt; 2) &#123; return result[n]; &#125; int sum = 0; int f1 = 1; int f2 = 1; for (int i = 2; i &lt;= n; i++) &#123; // 防止大数情况下超过int范围 sum = (f1 + f2) % 1000000007; f1 = f2; f2 = sum; &#125; return sum; &#125;&#125; Python代码12345678910class Solution(object): def numWays(self, n): """ :type n: int :rtype: int """ f0, f1 = 1, 1 for _ in range(n): f0, f1 = f1, f0 + f1 return f0 % 1000000007]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题10-1-斐波那契数列]]></title>
    <url>%2F2020%2F04%2F08%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9810-1-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题10-1-斐波那契数列写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下： 12F(0) = 0, F(1) = 1F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1. 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 一定记得取余! 示例1 12输入：n = 2输出：1 示例2 12输入：n = 5输出：5 提示： 0 &lt;= n &lt;= 100 解题思路斐波那契数列是一个非常熟悉的问题了，基本思路有2种方法 方法1、循环累加：按照f(0)+f(1)=f(2)的公式，循环累加到n即可求得 方法2、递归：递归的解法看上去很简洁，但是实际运行的时候效率特别慢，还会遇到重复计算和超出系统栈的问题，不推荐使用。基本思想是按照公式f(n)=f(n-1)+f(n-2)递归 Java代码123456789101112131415161718class Solution &#123; public int fib(int n) &#123; int[] result = new int[]&#123;0, 1&#125;; if (n &lt; 2) &#123; return result[n]; &#125; int sum = 0; int f1 = 0; int f2 = 1; for (int i = 2; i &lt;= n; i++) &#123; // 防止大数情况下超过int范围 sum = (f1 + f2) % 1000000007; f1 = f2; f2 = sum; &#125; return sum; &#125;&#125; Python代码1递归超时 123456789class Solution(object): def fib(self, n): """ :type n: int :rtype: int """ if n &lt;= 0: return 0 if n == 1: return 1 return (self.fib(n - 1) + self.fib(n - 2)) % 1000000007 Python代码212345678910class Solution(object): def fib(self, n): """ :type n: int :rtype: int """ f0, f1 = 0, 1 for _ in range(n): f0, f1 = f1, f0 + f1 return f0 % 1000000007]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题09-用两个栈实现队列]]></title>
    <url>%2F2020%2F04%2F07%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9809-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题09-用两个栈实现队列用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 示例1 1234输入：[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[3],[],[]]输出：[null,null,3,-1] 示例2 1234输入：[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[],[5],[2],[],[]]输出：[null,-1,null,null,5,2] 提示： 1 &lt;= values &lt;= 10000 最多会对 appendTail、deleteHead 进行 10000 次调用 解题思路首先，栈的特点是先进后出，队列的特点是先进先出。对于一批输入的数字，如5，2。我们保存在栈内5在栈底，2在栈顶，直接不能输出5，可以利用另外一个栈stack2将stack1的数据复制出去，当stack1不为空时就弹出复制到stack2，为2，5，此时栈顶为5，当stack2不为空时，不断弹出栈顶即可模拟先进先出。当stack2为空是，输出-1 Java代码1234567891011121314151617181920212223242526272829303132class CQueue &#123; Deque&lt;Integer&gt; stack1; Deque&lt;Integer&gt; stack2; public CQueue() &#123; stack1 = new LinkedList&lt;&gt;(); stack2 = new LinkedList&lt;&gt;(); &#125; public void appendTail(int value) &#123; stack1.push(value); &#125; public int deleteHead() &#123; while(stack1.size()&gt;0)&#123; stack2.addLast(stack1.removeLast()); return stack2.removeLast(); &#125; if(stack2.size()==0)&#123; return -1; &#125; return stack2.removeLast(); &#125;&#125;/** * Your CQueue object will be instantiated and called as such: * CQueue obj = new CQueue(); * obj.appendTail(value); * int param_2 = obj.deleteHead(); */ Python代码123456789101112131415161718192021222324252627282930class CQueue(object): def __init__(self): self.stack1,self.stack2 = [],[] def appendTail(self, value): """ :type value: int :rtype: None """ self.stack1.append(value) def deleteHead(self): """ :rtype: int """ if self.stack2: return self.stack2.pop() if not self.stack1: return -1 while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2.pop()# Your CQueue object will be instantiated and called as such:# obj = CQueue()# obj.appendTail(value)# param_2 = obj.deleteHead()]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题07-重建二叉树]]></title>
    <url>%2F2020%2F04%2F04%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9807-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题07-重建二叉树输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 例如，给出 12前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 12345678 3 / \ 9 20 / \ 15 7 限制：0 &lt;= 节点个数 &lt;= 5000 解题思路方法1、递归 前序遍历的序列第一个位置就是root节点，后面分别是左子树和右子树，一开始无法知道哪些是左子树数字，哪些是右子树数字，但数字按照左——&gt;右的顺序排列的。通过利用中序遍历序列可以得知，3的左边是左子树，3的右边是右子树。对于左子树，我们也能够获得其对应的前序和中序遍历，右子树同理。这样就将二叉树的建立转化为了一个递归问题：先在前序遍历确定根节点，然后确定中序中左子树开始和结束位置，以及右子树开始和结束位置，通过左子树前序和中序重建左子树，通过右子树前序和中序重建右子树，再向root添加左右子树的根节点，重建整个二叉树。 Java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; if (preorder == null || preorder.length == 0) &#123; return null; &#125; Map&lt;Integer, Integer&gt; dict = new HashMap&lt;&gt;(); // 建立中序map，快速获取位置 int length = preorder.length - 1; for (int i = 0; i &lt; inorder.length; i++) &#123; dict.put(inorder[i], i); &#125; TreeNode root = reconstrTree(preorder, 0, length, inorder, 0, length, dict); return root; &#125; public TreeNode reconstrTree(int[] preorder, int postart, int poend, int[] inorder, int iostart, int ioend, Map&lt;Integer, Integer&gt; dict) &#123; if (postart &gt; poend) &#123; // 二叉树没有节点 return null; &#125; int rootNode = preorder[postart]; // 对于前序序列，root节点就是第一个 TreeNode root = new TreeNode(rootNode); if (postart == poend) &#123; // 开始等于结束时，只有一个节点，就是root return root; &#125; else &#123; int rootIndex = dict.get(rootNode); // 获取root节点在中序序列的坐标 int leftRange = rootIndex - iostart; // 得到左子树个数 int rightRange = ioend - rootIndex; // 得到右子树个数 // 传递左子树的前序和中序序列，建立左子树 TreeNode leftTree = reconstrTree(preorder, postart + 1, postart + leftRange,inorder, iostart, rootIndex - 1, dict); // 传递右子树的前序和中序序列，建立右子树 TreeNode rightTree = reconstrTree(preorder, poend - rightRange + 1, poend, inorder,rootIndex + 1, ioend, dict); root.left = leftTree; root.right = rightTree; return root; &#125; &#125;&#125; Python代码123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def buildTree(self, preorder, inorder): """ :type preorder: List[int] :type inorder: List[int] :rtype: TreeNode """ self.dict1 = &#123;&#125; self.po = preorder polen = len(preorder) if (polen == 0): return for index, value in enumerate(inorder): self.dict1[value] = index return self.reconstrTree(0, 0, len(inorder) - 1) def reconstrTree(self, postart, instart, inend): if instart &gt; inend: return root = TreeNode(self.po[postart]) root_index = self.dict1[self.po[postart]] root.left = self.reconstrTree(postart + 1, instart, root_index - 1) root.right = self.reconstrTree(root_index - instart + postart + 1, root_index + 1, inend) return root]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>树</tag>
        <tag>Medium</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题06-从尾到头打印链表]]></title>
    <url>%2F2020%2F04%2F03%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9806-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题06-从尾到头打印链表输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 示例: 12输入：head = [1,3,2]输出：[2,3,1] 解题思路用ArryList或者Stack都可以，先进后出本身就是栈的特点，这里就直接用栈来做了。还有一种思路是递归，但是递归的问题就在于链表长了之后，层级过深会引起StackOverFlowerror，也就是栈溢出。 Java代码123456789101112131415161718192021222324/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int[] reversePrint(ListNode head) &#123; Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); ListNode node = head; while (node != null) &#123; stack.push(node.val); node = node.next; &#125; int size = stack.size(); int[] result = new int[size]; for (int i = 0; i &lt; size; i++) &#123; result[i] = stack.pop(); &#125; return result; &#125;&#125; Python代码123456789101112131415161718# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def reversePrint(self, head): """ :type head: ListNode :rtype: List[int] """ result = [] node = head while (node): result.append(node.val) node = node.next return result[::-1]]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>链表</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题05-替换空格]]></title>
    <url>%2F2020%2F04%2F03%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9805-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题05-替换空格请实现一个函数，把字符串 s 中的每个空格替换成”%20”。 示例: 12输入：s = &quot;We are happy.&quot;输出：&quot;We%20are%20happy.&quot; 解题思路方法1、遍历的时候直接用StringBuilder添加字符，遍历到空格的时候就添加%20，最后把char转化为String类型就可以了 方法2、利用python特点，一行解决= = Java代码123456789101112class Solution &#123; public String replaceSpace(String s) &#123; StringBuilder result = new StringBuilder(); for (char i : s.toCharArray()) &#123; if (i == ' ') &#123; result.append("%20"); &#125; else result.append(i); &#125; return result.toString(); &#125;&#125; Python代码1234567class Solution(object): def replaceSpace(self, s): """ :type s: str :rtype: str """ return ''.join(('%20' if c == ' ' else c for c in s))]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Easy</tag>
        <tag>字符串</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题04-二维数组中的查找]]></title>
    <url>%2F2020%2F04%2F03%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9804-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题04-二维数组中的查找在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例: 123456789101112131415现有矩阵 matrix 如下：[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]]给定 target = 5，返回 true。给定 target = 20，返回 false。限制：0 &lt;= n &lt;= 10000 &lt;= m &lt;= 1000 解题思路这个问题本身有一定的规律，从左到右数字是递增的，从上到下数字也是递增的。可以从第一行的最大数开始与目标数target比较，如果第一行的最大数比target大的话，这一列就可以排除不是要找的位置了，因为第一行也是一列的最小数，只有当target比第一行某一列大的时候，才需要往下面找，找到一个数之后，target的位置可能是向左或者向下的，但不可能向右了，因为右边已经被排除。整个过程一直重复下去就能找到目标数，没有就返回false Java代码123456789101112131415161718192021class Solution &#123; public boolean findNumberIn2DArray(int[][] matrix, int target) &#123; boolean falg = false; if (matrix == null || matrix.length == 0) &#123; return falg; &#125; int collen = matrix[0].length - 1; int rowlen = 0; while (rowlen &lt; matrix.length &amp;&amp; collen &gt;= 0) &#123; if (target &lt; matrix[rowlen][collen]) &#123; collen--; &#125; else if (target == matrix[rowlen][collen]) &#123; falg = true; break; &#125; else if (target &gt; matrix[rowlen][collen]) &#123; rowlen++; &#125; &#125; return falg; &#125;&#125; Python代码123456789101112131415161718192021class Solution(object): def findNumberIn2DArray(self, matrix, target): """ :type matrix: List[List[int]] :type target: int :rtype: bool """ falg = False if (matrix==None or len(matrix) == 0): return falg collen = len(matrix[0]) - 1 rowlen = 0 while (rowlen &lt; len(matrix) and collen &gt;= 0): if target &lt; matrix[rowlen][collen]: collen -= 1 elif target == matrix[rowlen][collen]: falg = True break elif target &gt; matrix[rowlen][collen]: rowlen += 1 return falg]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Easy</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题03-不修改数组找出重复的数字]]></title>
    <url>%2F2020%2F04%2F03%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9803-%E4%B8%8D%E4%BF%AE%E6%94%B9%E6%95%B0%E7%BB%84%E6%89%BE%E5%87%BA%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题03-不修改数组找出重复的数字在一个长度为n+1的数组里的所有数字都在1~n的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。 示例 1： 123456789输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 限制：2 &lt;= n &lt;= 100000 解题思路这个题和上一个题类似，但是不能修改输入的数组，可以沿用上一个题的方法，创建一个数组来复制原数组。代价是需要O(n)的辅助空间。这里主要尝试避免使用O(n)辅助空间的解法。 方法1、利用一个hash表，从头到尾扫描每个数字，不在表内的数字会成功添加，在表内的数字添加的时候会告诉已经存在，这个已经存在的数字就是要返回的数字了 方法2、假如没有重复的数组，那么在从1~n的范围里只有n个数字。由于数组里包含超过n个数字，所以一定包含了重复的数字。把从1~n的数字从中间的数字m分为两部分，前面一半为1~m，后面一半为m+1~n，如果1~m的数字的数目超过m，那么这一半的区间里一定包含重复的数字；否则，另一半m+1~n的区间里一定包含重复的数字。我们可以继续把包含重复数字的区间一分为二，直到找到一个重复的数字。这个过程和二分查找算法类似，只是多了一步统计区间里数字的数目。 Java代码12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public static int findRepeatNumber(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return -1; &#125; int start = 1; int end = nums.length - 1; // 先划区域，在统计次数 while (end &gt;= start) &#123; int middle = ((end - start) &gt;&gt; 1) + start; int count = countRange(nums, nums.length, start, middle); if (end == start) &#123; if (count &gt; 1) return start; else break; &#125; if (count &gt; (middle - start + 1)) end = middle; else start = middle + 1; &#125; return -1; &#125; public static int countRange(int[] nums, int length, int start, int end) &#123; if (nums == null) &#123; return 0; &#125; int count = 0; for (int i : nums) &#123; if (i &gt;= start &amp;&amp; i &lt;= end) ++count; &#125; return count; &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Easy</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-面试题03-数组中重复的数字]]></title>
    <url>%2F2020%2F04%2F02%2FLeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9803-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[LeetCode-面试题03-数组中重复的数字找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例 1： 123456789输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 限制：2 &lt;= n &lt;= 100000 解题思路方法1、利用一个hash表，从头到尾扫描每个数字，不在表内的数字会成功添加，在表内的数字添加的时候会告诉已经存在，这个已经存在的数字就是要返回的数字了 方法2、这个思想很巧妙，也是剑指offer上的最优解，数组的数字都在0~n-1的范围内。如果这个数组中没有重复的数字，那么当数组排序之后数字i将会出现在下标为i的位置。从头到尾依次扫描这个数组中的数字，当扫描到下标为i的数字时，首先比较这个数字(用m表示)是不是等于i。如果是，则接着扫描下一个数字；如果不是，则再拿它和第m个数字进行比较。如果它和第m个数字相等，就找到了第一个重复的数字(该数字在下标为i和m的位置都出现了)；如果它和第m个数字不相等，就把第i个数字和第m个数字交换，把m放到属于它的位置。接下来再重复这个比较、交换的过程，直到发现一个重复的数字。 Java代码12345678910111213class Solution &#123; public int findRepeatNumber(int[] nums) &#123; Set&lt;Integer&gt; s = new HashSet&lt;&gt;(); int result = -1; for (int i : nums) &#123; if (!s.add(i)) &#123; result = i; break; &#125; &#125; return result; &#125;&#125; Python代码12345678910111213class Solution(object): def findRepeatNumber(self, nums): """ :type nums: List[int] :rtype: int """ for index, i in enumerate(nums): while (index != i): if (i == nums[index]): return i temp = i i = nums[i] nums[i] = temp]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Easy</tag>
        <tag>Python</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-54-螺旋矩阵]]></title>
    <url>%2F2020%2F03%2F30%2FLeetCode-54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[LeetCode-54-螺旋矩阵给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。 示例 1: 1234567输入:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]输出: [1,2,3,6,9,8,7,4,5] 示例 2: 1234567输入:[ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12]]输出: [1,2,3,4,8,12,11,10,9,5,6,7] 解题思路方法1、圈层 记录左右和上下两个边界的点，按照上下左右算一圈，下一圈开始的时候初始位置+1，直到数组长度达到元素个数为止。Tips：注意几个初始点不参与遍历的变化。 首先遍历第一行，记录最左的列位置，初始化left为0，一直遍历到right为矩阵列数为止，遍历完成后此时行数应该+1，即top+1。 然后开始最右边一列的遍历，从top+1行开始，遍历到底部位置，之后应该从列数-1的位置开始下一次遍历，即right-1。然后进行底部一行的遍历，从right-1位置遍历到left位置，遍历完成之后应该从底部行向上移动开始下一次遍历，即bottom-1。 最后进行最左边一列的遍历，从bottom-1位置直到top行，这样就完成了第一圈的遍历，然后使初始left+1，到达下一圈，此时其他数个点已经缩至下一圈范围。完成之后即可得到螺旋矩阵元素。 方法2、模拟(官方解法) 绘制螺旋轨迹路径，我们发现当路径超出界限或者进入之前访问过的单元格时，会顺时针旋转方向。 假设数组有R 行 C 列，seen[r,c]表示第 r 行第 c 列的单元格之前已经被访问过了。当前所在位置为(r, c)，前进方向是 di。我们希望访问所有R x C 个单元格。 当我们遍历整个矩阵，下一步候选移动位置是(cr, cc)。如果这个候选位置在矩阵范围内并且没有被访问过，那么它将会变成下一步移动的位置；否则，我们将前进方向顺时针旋转之后再计算下一步的移动位置。 Java代码123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(matrix.length==0)&#123; return list; &#125; int rowlen = matrix.length; int collen = matrix[0].length; int total_num = 0; int left = 0; int right = collen - 1; int top = 0; int bottom = rowlen - 1; while (total_num != rowlen * collen) &#123; for (int i = left; i &lt;= right; i++) &#123; list.add(matrix[top][i]); total_num++; &#125; if (total_num == rowlen * collen) break; top++; for (int i = top; i &lt;= bottom; i++) &#123; list.add(matrix[i][right]); total_num++; &#125; if (total_num == rowlen * collen) break; right--; for (int i = right; i &gt;= left; i--) &#123; list.add(matrix[bottom][i]); total_num++; &#125; if (total_num == rowlen * collen) break; bottom--; for (int i = bottom; i &gt;= top; i--) &#123; list.add(matrix[i][left]); total_num++; &#125; if (total_num == rowlen * collen) break; left++; &#125; return list; &#125;&#125; Python代码12345678910111213141516171819202122232425262728def spiralOrder(matrix): if not matrix: return [] R, C = len(matrix), len(matrix[0]) seen = [[False] * C for _ in matrix] ans = [] # 改变方向时，row和col变化的数值，di仅在改变方向时移动 dr = [0, 1, 0, -1] dc = [1, 0, -1, 0] r = c = di = 0 for _ in range(R * C): ans.append(matrix[r][c]) seen[r][c] = True cr, cc = r + dr[di], c + dc[di] if 0 &lt;= cr &lt; R and 0 &lt;= cc &lt; C and not seen[cr][cc]: r, c = cr, cc else: di = (di + 1) % 4 r, c = r + dr[di], c + dc[di] return ansif __name__=='__main__': # 输入二维数组 row ,col = [int(n) for n in input().split()] list = [[0]*col]*row for i in range(row): list[i] = [int(i) for i in input().split()] result = spiralOrder(list) print(result)]]></content>
      <categories>
        <category>二维数组</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Medium</tag>
        <tag>Python</tag>
        <tag>二维数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-498-对角线遍历]]></title>
    <url>%2F2020%2F03%2F26%2FLeetCode-498-%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[LeetCode-498-对角线遍历给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。 示例: 12345678输入:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]输出: [1,2,4,7,5,3,6,8,9] 说明: 给定矩阵中的元素总数不会超过 100000 。 解题思路方法1、模拟路径，观察图可以知道对角线位置的横纵坐标之和等于第一行的该对角线元素索引号，以第一行为例，奇数往右上走，偶数往左下走，对于越界的不添加，将他按左下或右上移动，直到到矩阵位置里面进行添加。这种方法的缺点是遍历了很多没有用的位置，浪费了时间，运行时间93ms 方法2、简化问题，直接遍历每个对角线，翻转奇数对角线数值即可，外层循环为所有对角线初始点。运行时间7ms 还有一些其他更简单的方法，时间和空间上消耗都比较少，可以右转leetcode看看~ Java代码1123456789101112131415161718192021222324252627282930public static int[] findDiagonalOrder(int[][] matrix) &#123; if (matrix == null || matrix.length == 0) &#123; return new int[0]; &#125; int row = matrix.length; int col = matrix[0].length; int[] out = new int[row * col]; int k =0; List&lt;Integer&gt; in = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; row + col - 1; i++) &#123; in.clear(); // 找到对角线坐标点 int r = i &lt; col ? 0 : i - col + 1; int c = i &lt; col ? i : col - 1; // 遍历对角线元素 while (r &lt; row &amp;&amp; c &gt; -1) &#123; in.add(matrix[r][c]); ++r; --c; &#125; if (i % 2 == 0) &#123; Collections.reverse(in); &#125; // 将一个对角线元素赋值 for (int j = 0; j &lt; in.size(); j++) &#123; out[k++] = in.get(j); &#125; &#125; return out; &#125; Java代码212345678910111213141516171819202122232425262728293031323334353637383940414243444546public static int[] findDiagonalOrder(int[][] matrix) &#123; // 按索引坐标分为奇数和偶数情况，奇数右上走，偶数左下走，当前行数+当前列数=索引值 // 越界的不管到边界里面再加入 if (matrix.length == 0) &#123; return new int[0]; &#125; int rowlen = matrix.length; int collen = matrix[0].length; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(rowlen * collen); int[] out = new int[rowlen * collen]; rowlen--; collen--; for (int sum = 0; sum &lt; rowlen + collen + 1; sum++) &#123; if (sum % 2 == 0) &#123; // 偶数情况 int row = rowlen; int col = sum - row; while (row &gt;= 0 &amp;&amp; col &lt;= collen) &#123; if (col &lt; 0) &#123; col += 1; row -= 1; continue; &#125; list.add(matrix[row][col]); row -= 1; col += 1; &#125; &#125; else &#123; // 奇数情况 int row = 0; int col = sum - row; while (row &lt;= rowlen &amp;&amp; col &gt;= 0) &#123; if (col &gt; collen) &#123; col -= 1; row += 1; continue; &#125; list.add(matrix[row][col]); row = row + 1; col = col - 1; &#125; &#125; &#125; for (int i = 0; i &lt; list.size(); i++) &#123; out[i] = list.get(i); &#125; return out;&#125; Python代码123456789101112131415161718class Solution: def findDiagonalOrder(self, matrix): if not matrix or not matrix[0]: return [] N, M = len(matrix), len(matrix[0]) result, intermediate = [], [] for d in range(N + M - 1): intermediate.clear() r, c = 0 if d &lt; M else d - M + 1, d if d &lt; M else M - 1 while r &lt; N and c &gt; -1: intermediate.append(matrix[r][c]) r += 1 c -= 1 if d % 2 == 0: result.extend(intermediate[::-1]) else: result.extend(intermediate) return result]]></content>
      <categories>
        <category>二维数组</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Medium</tag>
        <tag>Python</tag>
        <tag>二维数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-66-加一]]></title>
    <url>%2F2020%2F03%2F23%2FLeetCode-66-%E5%8A%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[LeetCode-66-加一给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 123输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。 示例 2: 123输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。 解题思路方法1、先判断尾数+1是否需要进位，如果需要则将最后一位置0，其余循环遍历在加上去，如果第一位是9，那么最高位也需要进位，把最高位设置为0，数组第一个位置插入1就可以了。 方法2、从数组尾部开始遍历，设置一个初始乘数1，个位乘1、十位成10，慢慢的加上去就是最后的数字。但是这种方法在Java中最后超出了基本类型的数字范围，Python好像可以运行，这里我弃掉了。 Java代码123456789101112131415161718class Solution &#123; public int[] plusOne(int[] digits) &#123; int dig_len = digits.length; for (int i = dig_len - 1; i &gt;= 0; i--) &#123; if (digits[i] == 9) &#123; digits[i] = 0; &#125; else &#123; digits[i] += 1; return digits; &#125; &#125; if (digits[0] == 0) &#123; digits = new int[dig_len + 1]; digits[0] = 1; &#125; return digits; &#125;&#125; Python代码123456789101112131415class Solution(object): def plusOne(self, digits): """ :type digits: List[int] :rtype: List[int] """ for i in range(len(digits)-1, -1, -1): if (digits[i] == 9): digits[i] = 0 else: digits[i] += 1 return digits if digits[0] == 0: digits.insert(0, 1) return digits]]></content>
      <categories>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Easy</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-747-至少是其他数字两倍的最大数]]></title>
    <url>%2F2020%2F03%2F19%2FLeetCode-747-%E8%87%B3%E5%B0%91%E6%98%AF%E5%85%B6%E4%BB%96%E6%95%B0%E5%AD%97%E4%B8%A4%E5%80%8D%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%2F</url>
    <content type="text"><![CDATA[LeetCode-747-至少是其他数字两倍的最大数在一个给定的数组nums中，总是存在一个最大元素 。 查找数组中的最大元素是否至少是数组中每个其他数字的两倍。 如果是，则返回最大元素的索引，否则返回-1。 示例 1: 1234输入: nums = [3, 6, 1, 0]输出: 1解释: 6是最大的整数, 对于数组中的其他整数,6大于数组中其他元素的两倍。6的索引是1, 所以我们返回1. 示例 2: 123输入: nums = [1, 2, 3, 4]输出: -1解释: 4没有超过3的两倍大, 所以我们返回 -1. 提示: nums 的长度范围在[1, 50]. 每个 nums[i] 的整数范围在 [0, 100]. 解题思路想要找最大数至少大于所有其他数的两倍，只需要知道最大数比次大数大两倍就可以了，一次遍历用两个参数分别记录最大数和次大数，在当前索引比最大数大的时候，次大数的数值也应该变为原本的最大数，比最大数小的时候判断是否大于次大数即可 Java代码1234567891011121314151617class Solution &#123; public int dominantIndex(int[] nums) &#123; int max = 0; int sec_max = 0; int max_index = -1; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] &gt; max) &#123; sec_max = max; max = nums[i]; max_index = i; &#125; else if (nums[i] &gt; sec_max) &#123; sec_max = nums[i]; &#125; &#125; return max &gt;= (2 * sec_max) ? max_index : -1; &#125;&#125; Python代码123456789101112131415class Solution(object): def dominantIndex(self, nums): """ :type nums: List[int] :rtype: int """ max, sec_max, max_index = 0, 0, 0 for index, i in enumerate(nums): if i &gt; max: sec_max = max max = i max_index = index elif i &gt; sec_max: sec_max = i return (max_index if (max &gt;= 2 * sec_max) else -1)]]></content>
      <categories>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Easy</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-724-寻找数组的中心索引]]></title>
    <url>%2F2020%2F03%2F19%2FLeetCode-724-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[LeetCode-724-寻找数组的中心索引日常学习任务实在是太多，所以很久没有更新博客了，今天开始刷题，从最简单的开始吧！给定一个整数类型的数组 nums，请编写一个能够返回数组“中心索引”的方法。 我们是这样定义数组中心索引的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。 如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。 示例 1: 123456输入: nums = [1, 7, 3, 6, 5, 6]输出: 3解释: 索引3 (nums[3] = 6) 的左侧数之和(1 + 7 + 3 = 11)，与右侧数之和(5 + 6 = 11)相等。同时, 3 也是第一个符合要求的中心索引。 示例 2: 12345输入: nums = [1, 2, 3]输出: -1解释: 数组中不存在满足此条件的中心索引。 说明: nums的长度范围为 [0, 10000]。 任何一个 nums[i]将会是一个范围在 [-1000, 1000]的整数。 解题思路计算第i个位置左右两边的和比较一下就行了，右边=总和-当前位置值-当前位置左边的和 Java代码12345678910111213141516171819202122232425262728293031323334public class SearchIndex &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); String input = in.nextLine().toString(); String[] s = input.split(" "); int[] array = new int[s.length]; for (int i = 0; i &lt; array.length; i++) &#123; array[i] = Integer.parseInt(s[i]); &#125; int Output = pivotIndex(array); System.out.println(Output); &#125; public static int pivotIndex(int[] nums) &#123; int Left = 0; int Right = 0; int sum = 0; for (int n : nums) &#123; sum += n; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; if (i == 0) &#123; Left = 0; &#125; else &#123; Left += nums[i - 1]; &#125; Right = sum - Left - nums[i]; if (Left == Right) &#123; return i; &#125; &#125; return -1; &#125;&#125; Python代码1234567891011121314151617def pivotIndex(self, nums): """ :type nums: List[int] :rtype: int """ Left, Right, sum = 0, 0, 0 for i in nums: sum += i for index, j in enumerate(nums): if (index == 0): Left = 0 else: Left += nums[index - 1] Right = sum - Left - nums[index] if (Left == Right): return index return -1]]></content>
      <categories>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>Easy</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LogisticRegression(逻辑回归)]]></title>
    <url>%2F2018%2F10%2F21%2FLogisticRegression(%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92)%2F</url>
    <content type="text"><![CDATA[LogisticRegression定义logistic回归，是一种广义的线性回归分析模型，常用于数据挖掘，疾病自动诊断，经济预测等领域。例如，探讨引发疾病的危险因素，并根据危险因素预测疾病发生的概率等。以胃癌病情分析为例，选择两组人群，一组是胃癌组，一组是非胃癌组，两组人群必定具有不同的体征与生活方式等。一般来说逻辑回归用来做分类任务，本文列举的是以线性的2分类为例， 除此之外还可以拓展到多更多参数实现非线性分类，以及多分类问题等。在文章中主要写了其推导过程以及部分代码实现 构造函数h(x) 其中sigmoid函数形式为： 对应的函数图像是一个取值在0和1之间的曲线： 因为： 由上两式联立可得: 使用极大似然估计法取似然函数(离散型): 对似然函数取ln，转换为： 极大似然估计就是要求得使l(θ)取最大值时的θ，所以如果是这样的话会对应这梯度上升算法，虽然和梯度下降效果一样但是为了便于理解，将J(θ)定义为如下式子，以变化为梯度下降算法求解。 因为乘以了一个负的系数，所以J(θ)取最小值时的θ是最优参数 梯度下降算法求J(θ)的最小值根据梯度下降法可知，更新过程为： 式中α为学习率，求偏导数步骤： 所以更新过程可以写成： 因为α是常量，所以1/m可以省略，最后更新过程变为： 梯度下降的向量化(vectorization)约定训练数据的矩阵形式如下，x的每一行为一条训练样本，而每一列为不同的特称取值 ： 约定待求的参数θ的矩阵形式为: 先求x*θ并记为A : 求hθ(x)-y并记为E: g(A)的参数A为一列向量，所以实现g函数时要支持列向量作为参数，并返回列向量。由上式可知hθ(x)-y可以由g(A)-y一次计算求得。 更新过程可以转化为： 综合起来就是: 综上所述，vectorization后θ更新的步骤如下 : 求A=x*θ 求E=g(A)-y 求θ:=θ-α.x’.E,x’表示矩阵x的转置 最后，向量化的参数更新公式为: 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115# @Time : 2018/10/19 16:37# @Author : YuanMing# @File : Logistic_regression.py# @Software: PyCharmimport numpy as npimport matplotlib.pyplot as pltdef loadDataSet(): """ 取出数据和标签 :return: """ data = np.loadtxt('testSet.txt') # 取数据集的第一列到最后一列的前一列 dataMat = data[:, 0:-1] # 取数据集的最后一列 lableMat = data[:, -1] # 为dataMat添加一列1，代表所有theta0的参数，其中0代表第1列，1代表需要插入的数值，axis=1代表横轴（即列添加） dataMat = np.insert(dataMat, 0, 1, axis=1) return dataMat, lableMatdef sigmoid(Z): """ 构造sigmoid函数 :param Z: thetaT*x :return: 分类精度 """ return 1.0 / (1 + np.exp(-Z))def gradient_descent(dataMat, labelMat): """ 梯度下降算法 :param dataMat: 特征数组 :param labelMat: 标签数组 :return: 最小化的theta """ # 将特征数组转化为矩阵形式 dataMatrix = np.mat(dataMat) # 将标签数据转化为矩阵并取矩阵的转置 labelMatrix = np.mat(labelMat).transpose() # 得到特征矩阵的行数和列数 m, n = np.shape(dataMatrix) # 学习率 alpha = 0.001 # 迭代次数 iterations = 500 # 生成n行1列的全1矩阵 theta = np.ones((n, 1)) # 执行梯度下降更新 for k in range(iterations): # 求h(x)函数 h = sigmoid(dataMatrix * theta) # 求误差 error = h - labelMatrix # 按照推导的迭代公式求得新的theta theta = theta - alpha * dataMatrix.transpose() * error return thetadef plotBestFIt(theta): # 导入数据 dataMat, lableMat = loadDataSet() # 获取数据行数 n = np.shape(dataMat)[0] # 初始化坐标列表 xcord1 = [] ycord1 = [] xcord2 = [] ycord2 = [] for i in range(n): # 如果对应的类别标签对应数值1，就添加到xcord1，ycord1中 if lableMat[i] == 1: xcord1.append(dataMat[i][1]) ycord1.append(dataMat[i][2]) # 如果对应的类别标签对应数值0，就添加到xcord2，ycord2中 else: xcord2.append(dataMat[i][1]) ycord2.append(dataMat[i][2]) # 创建空图 fig = plt.figure() # 将画布分割成1行1列，图像画在从左到右从上到下的第1块 # 添加subplot，三种数据都画在一张图上 ax = fig.add_subplot(111) # 1类用红色标识，形状为正方形，s为标记点大小 ax.scatter(xcord1, ycord1, s=30, c='red', marker='s') # 0类用蓝色标识 ax.scatter(xcord2, ycord2, s=30, c='blue') # 生成一个ndarray数组范围从-3到3，步长为0.1 x = np.arange(-3, 3, 0.1) ''' 这里设置了sigmoid函数的取值为1/2，也就是说取阈值为0.5来划分最后预测的结果 根据e(−thetaTX)=1,即-thetaTX=0，可以推出x2 = (-theta0x0 - theta1x1)/theta2 因为x1和x2是两个特征，没有一定的x和y关系，这里假设y是x2,x是x1，之前x0代表1 ''' y = (-theta[0, 0] - theta[1, 0] * x) / theta[2, 0] # 画出拟合直线 ax.plot(x, y) # 规定X轴标签 plt.xlabel('X1') # 规定Y轴标签 plt.ylabel('X2') plt.show()if __name__ == '__main__': dataMat, labelMat = loadDataSet() theta = gradient_descent(dataMat, labelMat) dataMat, labelMat = loadDataSet() length = len(dataMat) for i in range(length): print("分类精度:&#123;&#125;".format(round(float(sigmoid(dataMat[i]*theta))*100,2))+"%") plotBestFIt(theta) 运行结果12345678910111213141516171819D:\Anaconda3\python.exe E:/PythonProject/MachineLeaning/logistic_regression/Logistic_regression.py分类精度:1.04%分类精度:64.06%分类精度:43.28%分类精度:28.44%分类精度:7.64%分类精度:49.0%分类精度:3.18%分类精度:21.54%分类精度:18.35%分类精度:8.94%分类精度:56.55%分类精度:3.37%分类精度:93.91%分类精度:8.76%分类精度:57.59%分类精度:97.32%.........Process finished with exit code 0]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>机器学习</tag>
        <tag>逻辑回归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Coursera课后作业——ex1]]></title>
    <url>%2F2018%2F10%2F07%2FCoursera%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E2%80%94%E2%80%94ex1%2F</url>
    <content type="text"><![CDATA[很久以前做的，还是提交一下 线性回归基础（ Linear regression ） Hypothesis: h_{\theta }(x)=\theta _{0}+\theta _{1}x Parameters: \theta _{0},\theta _{1} cost Funcition: J(\theta _{0},\theta _{1})=\frac{1}{2m}\sum_{i=1}^{m}(h_{\theta}(x^{(i)})-y^{(i)})^{2}​ goal: minimize_{\theta _{0},\theta _{1}}J(\theta _{0},\theta _{1})在最小化损失函数的过程中需要用到梯度下降算法（Gradient descent） 梯度下降算法（Gradient descent ） Have some function: J(\theta _{0},\theta _{1}) Want: minimize_{\theta _{0},\theta _{1}}J(\theta _{0},\theta _{1})Outline: start with some $\theta _{0},\theta _{1}$,(一般都取0) keep changing $\theta _{0},\theta _{1}$ to reduce $J(\theta _{0},\theta _{1})$，直到我们找到J的最小值或是局部最小值 repeat until convergence｛ \theta _{j}:=\theta _{j}-\frac{\alpha }{m}(h_{\theta^{(i)} }-y^{(i))})x_{j}^{(i)}(simultaneously update θj for all j) ｝ 代码主函数ex1.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122%% Machine Learning Online Class - Exercise 1: Linear Regression% Instructions% ------------% % This file contains code that helps you get started on the% linear exercise. You will need to complete the following functions % in this exericse:%% warmUpExercise.m% plotData.m% gradientDescent.m% computeCost.m% gradientDescentMulti.m% computeCostMulti.m% featureNormalize.m% normalEqn.m%% For this exercise, you will not need to change any code in this file,% or any other files other than those mentioned above.%% x refers to the population size in 10,000s% y refers to the profit in $10,000s%%% Initializationclear ; close all; clc%% ==================== Part 1: Basic Function ====================% Complete warmUpExercise.m fprintf('Running warmUpExercise ... \n');fprintf('5x5 Identity Matrix: \n');warmUpExercise()fprintf('Program paused. Press enter to continue.\n');pause;%% ======================= Part 2: Plotting =======================fprintf('Plotting Data ...\n')data = load('ex1data1.txt');X = data(:, 1); y = data(:, 2);%第一列数据给X，第二列数据给ym = length(y); % 训练样本的个数% Plot Data% Note: You have to complete the code in plotData.mplotData(X, y); %传入X和y进行画图fprintf('Program paused. Press enter to continue.\n');pause;%% =================== Part 3: Gradient descent ===================fprintf('Running Gradient Descent ...\n')X = [ones(m, 1), data(:,1)]; % Add a column of ones to x 考虑到截取项theta0，为X增加额外的一列theta = zeros(2, 1); % initialize fitting parameters 定义一个2行1列值为0的向量% Some gradient descent settingsiterations = 1500; %迭代次数alpha = 0.01; %学习率% compute and display initial costcomputeCost(X, y, theta) %计算代价函数J（theta）% run gradient descenttheta = gradientDescent(X, y, theta, alpha, iterations); %获得theta0和theta1% print theta to screenfprintf('Theta found by gradient descent: ');fprintf('%f %f \n', theta(1), theta(2));% Plot the linear fithold on; % keep previous plot visibleplot(X(:,2), X*theta, '-') %以X的第2列为横坐标，X*theta为纵坐标，横线为标记画图legend('Training data', 'Linear regression')hold off % don't overlay any more plots on this figure% Predict values for population sizes of 35,000 and 70,000predict1 = [1, 3.5] *theta; %预测人口为35000的时候的利润fprintf('For population = 35,000, we predict a profit of %f\n',... predict1*10000);predict2 = [1, 7] * theta; %预测人口为70000的时候的利润fprintf('For population = 70,000, we predict a profit of %f\n',... predict2*10000);fprintf('Program paused. Press enter to continue.\n');pause;%% ============= Part 4: Visualizing J(theta_0, theta_1) ============= 可视化J（theta）fprintf('Visualizing J(theta_0, theta_1) ...\n')% Grid over which we will calculate Jtheta0_vals = linspace(-10, 10, 100);% 生成-10到10之间，间距为（10-（-10)）/（100-1）的长度为100的数组（即间距为0.2020）theta1_vals = linspace(-1, 4, 100); % 生成-1到4，间距为0.051的长度为100的数组% initialize J_vals to a matrix of 0'sJ_vals = zeros(length(theta0_vals), length(theta1_vals));% Fill out J_valsfor i = 1:length(theta0_vals) for j = 1:length(theta1_vals) t = [theta0_vals(i); theta1_vals(j)]; J_vals(i,j) = computeCost(X, y, t); endend% Because of the way meshgrids work in the surf command, we need to % transpose J_vals before calling surf, or else the axes will be flippedJ_vals = J_vals';% Surface plotfigure;surf(theta0_vals, theta1_vals, J_vals) % 三维图xlabel('\theta_0'); ylabel('\theta_1');% Contour plotfigure;% Plot J_vals as 15 contours spaced logarithmically between 0.01 and 100contour(theta0_vals, theta1_vals, J_vals, logspace(-2, 3, 20)) % 等高线xlabel('\theta_0'); ylabel('\theta_1');hold on;plot(theta(1), theta(2), 'rx', 'MarkerSize', 10, 'LineWidth', 2); 计算损失函数部分computeCost.m 123456789101112131415161718192021222324function J = computeCost(X, y, theta)%COMPUTECOST Compute cost for linear regression% J = COMPUTECOST(X, y, theta) computes the cost of using theta as the% parameter for linear regression to fit the data points in X and y% Initialize some useful valuesm = length(y); % number of training examples% You need to return the following variables correctly J = 0;% ====================== YOUR CODE HERE ======================% Instructions: Compute the cost of a particular choice of theta% You should set J to the cost.predictions = X*theta; % h_theta(x)=thetaT*xsqerrors = (predictions - y).^2; J = 1/(2*m)* sum(sqerrors);% =========================================================================end 绘图部分plotData.m 12345678910111213141516171819202122232425262728function plotData(x, y)%PLOTDATA Plots the data points x and y into a new figure % PLOTDATA(x,y) plots the data points and gives the figure axes labels of% population and profit.% ====================== YOUR CODE HERE ======================% Instructions: Plot the training data into a figure using the % "figure" and "plot" commands. Set the axes labels using% the "xlabel" and "ylabel" commands. Assume the % population and revenue data have been passed in% as the x and y arguments of this function.%% Hint: You can use the 'rx' option with plot to have the markers% appear as red crosses. Furthermore, you can make the% markers larger by using plot(..., 'rx', 'MarkerSize', 10);figure; % open a new figure windowplot(x, y, 'rx', 'MarkerSize', 10); % Plot the data 用红色的大小为10的×来进行标记，横坐标是X，纵坐标是yylabel('Profit in $10,000s'); % Set the y axis labelxlabel('Population of City in 10,000s'); % Set the x axis label% ============================================================end 梯度下降gradientDescent.m 12345678910111213141516171819202122232425262728293031323334function [theta, J_history] = gradientDescent(X, y, theta, alpha, num_iters)%GRADIENTDESCENT Performs gradient descent to learn theta% theta = GRADIENTDESENT(X, y, theta, alpha, num_iters) updates theta by % taking num_iters gradient steps with learning rate alpha% Initialize some useful valuesm = length(y); % number of training examplesJ_history = zeros(num_iters, 1);for iter = 1:num_iters % ====================== YOUR CODE HERE ====================== % Instructions: Perform a single gradient step on the parameter vector % theta. % % Hint: While debugging, it can be useful to print out the values % of the cost function (computeCost) and gradient here. % predictions = X * theta; updates = X' * (predictions - y); theta = theta - alpha * (1/m) * updates; %theta = theta - alpha * (1/m) * sum(sqerrors) * X; %theta - (alpha/m) * (X' * (X * theta - y)); %theta = theta - (alpha/m) * (X' * (X * theta - y)); % ============================================================ % Save the cost J in every iteration J_history(iter) = computeCost(X, y, theta);endend 运行结果 线性回归拟合之后 绘制梯度下降等高线 判断梯度下降是否达到最低点 预测结果 上图得到$\theta _{1},\theta _{2}$的数值以及在人口为35000和70000时，分别可以获得的利润]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>matlab</tag>
        <tag>Coursera</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[域名备案成功]]></title>
    <url>%2F2018%2F09%2F17%2F%E5%9F%9F%E5%90%8D%E5%A4%87%E6%A1%88%E6%88%90%E5%8A%9F%2F</url>
    <content type="text"><![CDATA[经历十几天的备案流程，域名备案总算成功了，博客恢复更新（ps:最近比较忙，空了写= =）]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Face</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将hexo自定义域名升级https]]></title>
    <url>%2F2018%2F08%2F29%2F%E5%B0%86hexo%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%8D%87%E7%BA%A7https%2F</url>
    <content type="text"><![CDATA[前言Tips:有什么问题可以在下方留言板留言哦，留下自己的邮箱，可以保证快速回复 最近在折腾博客，发现github上很多人说个人博客支持https很重要，原本的github.io域名本来支持https协议，但是在自定义域名之后，协议变成了http。这使得网站变得不够安全，容易被劫持。 但是网上的支持https很多都是反向代理，以及SSL证书等，涉及到备案还有一些配置操作，算是比较麻烦，期间如果不对还会出现各种bug。所以针对简单想支持全站https的站长而言，我们可以选择如下操作： 对于github解析的用户 打开Github Pages页面的强制HTTPS 在此之前，请确认上图中的Custom domain已经写为你的自定义域名 然后再勾选Enforce HTTPS即可 对于coding解析的用户 打开Coding Pages服务的强制HTTPS访问 对于没有引用外部链接的同学来说，你已经获得了https认证，在谷歌浏览器中可见网站的小绿锁，但是对于大部分站长来说都有自己的云存储来保存自己的图片或者文件，于是我们需要一个图床或者云对象存储并且它支持https协议。 云存储对象的选择（腾讯云）在百度中想要支持https外链的图床有不少，如简单图床、SM.MS、imgur、路过图床等，读者如果仅仅需要引用图片文件，那么这些图床完全满足你的要求，并可以保证全站https。但是笔者需要存储的不仅仅是图片，有事还会存储文件，而这些图床只能存储图片，不能存储其他文件，这就无法保证我其他文件的https链接，笔者偶然间发现，腾讯云的对象存储具有不错的空间，并且支持https协议的外链，而且免费，于是把整个云存储搬去腾讯云，更换外链后完成了全站https。 腾讯云对象存储添加1、在云产品中选择对象存储 2、创建存储桶 2.1关于存储的容量问题：每个存储桶中的对象不限 每月免费存储额度50GB，下行流量10GB，对于一个个人博客流量还不大的情况下完全足够了 3、创建存储桶后上传自己的文件，然后点击详情，可以看到他的https外部链接 4、更换自己的md文件的外部链接即可，然后重新部署hexo，就可以看到效果了]]></content>
      <categories>
        <category>HTTPS</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将下载下来的MNIST手写数字数据集转化成为图片]]></title>
    <url>%2F2018%2F08%2F26%2F%E5%B0%86%E4%B8%8B%E8%BD%BD%E4%B8%8B%E6%9D%A5%E7%9A%84MNIST%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E6%95%B0%E6%8D%AE%E9%9B%86%E8%BD%AC%E5%8C%96%E6%88%90%E4%B8%BA%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[解析源文件下载（总共包含60000个训练数据和10000个测试数据） 训练集解析 测试集解析 对于训练集的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import numpy as npimport structfrom PIL import Imageimport osdata_file = 'MNIST_data\\train-images.idx3-ubyte' # 需要修改的路径# It's 47040016B, but we should set to 47040000Bdata_file_size = 47040016data_file_size = str(data_file_size - 16) + 'B'data_buf = open(data_file, 'rb').read()magic, numImages, numRows, numColumns = struct.unpack_from( '&gt;IIII', data_buf, 0)datas = struct.unpack_from( '&gt;' + data_file_size, data_buf, struct.calcsize('&gt;IIII'))datas = np.array(datas).astype(np.uint8).reshape( numImages, 1, numRows, numColumns)label_file = 'MNIST_data\\train-labels.idx1-ubyte' # 需要修改的路径# It's 60008B, but we should set to 60000Blabel_file_size = 60008label_file_size = str(label_file_size - 8) + 'B'label_buf = open(label_file, 'rb').read()magic, numLabels = struct.unpack_from('&gt;II', label_buf, 0)labels = struct.unpack_from( '&gt;' + label_file_size, label_buf, struct.calcsize('&gt;II'))labels = np.array(labels).astype(np.int64)datas_root = 'MNIST_data\\' # 需要修改的路径if not os.path.exists(datas_root): os.mkdir(datas_root)for i in range(10): file_name = datas_root + os.sep + str(i) if not os.path.exists(file_name): os.mkdir(file_name)for ii in range(numLabels): img = Image.fromarray(datas[ii, 0, 0:28, 0:28]) label = labels[ii] file_name = datas_root + os.sep + str(label) + os.sep + \ 'mnist_train_' + str(ii) + '.png' img.save(file_name) 对于测试集的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import numpy as npimport structfrom PIL import Imageimport osdata_file = 'MNIST_data\\t10k-images.idx3-ubyte' # 需要修改的路径# It's 7840016B, but we should set to 7840000Bdata_file_size = 7840016data_file_size = str(data_file_size - 16) + 'B'data_buf = open(data_file, 'rb').read()magic, numImages, numRows, numColumns = struct.unpack_from( '&gt;IIII', data_buf, 0)datas = struct.unpack_from( '&gt;' + data_file_size, data_buf, struct.calcsize('&gt;IIII'))datas = np.array(datas).astype(np.uint8).reshape( numImages, 1, numRows, numColumns)label_file = 'MNIST_data\\t10k-labels.idx1-ubyte' # 需要修改的路径# It's 10008B, but we should set to 10000Blabel_file_size = 10008label_file_size = str(label_file_size - 8) + 'B'label_buf = open(label_file, 'rb').read()magic, numLabels = struct.unpack_from('&gt;II', label_buf, 0)labels = struct.unpack_from( '&gt;' + label_file_size, label_buf, struct.calcsize('&gt;II'))labels = np.array(labels).astype(np.int64)datas_root = 'MNIST_data\\test_dataset' # 需要修改的路径if not os.path.exists(datas_root): os.mkdir(datas_root)for i in range(10): file_name = datas_root + os.sep + str(i) if not os.path.exists(file_name): os.mkdir(file_name)for ii in range(numLabels): img = Image.fromarray(datas[ii, 0, 0:28, 0:28]) label = labels[ii] file_name = datas_root + os.sep + str(label) + os.sep + \ 'mnist_test_' + str(ii) + '.png' img.save(file_name)]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>机器学习</tag>
        <tag>MNIST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些TensorFlow的基本操作]]></title>
    <url>%2F2018%2F08%2F26%2F%E4%B8%80%E4%BA%9BTensorFlow%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[简单用代码说明Tensor,变量,Fetch,Feed的使用 TensorTensorFlow 程序使用 tensor 数据结构来代表所有的数据, 计算图中, 操作间传递的数据都是 tensor. 你可以把 TensorFlow tensor 看作是一个 n 维的数组或列表. 一个 tensor 包含一个静态类型 rank, 和 一个 shape. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# @Time : 2018/8/26 16:08# @Author : YuanMing# @File : 变量.py# @Software: PyCharmimport tensorflow as tf# 创建一个变量，初始化变量0state = tf.Variable(0, name="counter")# 创建一个op，其作用是使state增加1one = tf.constant(1)new_value = tf.add(state, one)'''代码中 assign() 操作是图所描绘的表达式的一部分, 正如 add() 操作一样. 所以在调用 run() 执行表达式之前, 它并不会真正执行赋值操作.'''update = tf.assign(state, new_value)# 启动图后，变量必须先经过'初始化'（init）op初始化# 首先必须增加一个'初始化'op到图中init_op = tf.initialize_all_variables()# 启动图，运行opwith tf.Session() as sess: # 运行'init' op sess.run(init_op) # 打印'state'的初始值 print(sess.run(state)) # 运行op,更新'state'，并打印'state' for _ in range(3): sess.run(update) print(sess.run(state))'''Fetch为了取回操作的输出内容, 可以在使用 Session 对象的 run() 调用 执行图时, 传入一些 tensor, 这些 tensor 会帮助你取回结果. 在之前的例子里, 我们只取回了单个节点 state, 但是你也可以取回多tensor:'''input1 = tf.constant(3.0)input2 = tf.constant(2.0)input3 = tf.constant(5.0)intermed = tf.add(input2, input3)mul = tf.multiply(input1, intermed)with tf.Session() as sess: result = sess.run([mul, intermed]) print(result)'''Feedfeed 机制, 该机制 可以临时替代图中的任意操作中的 tensor可以对图中任何操作提交补丁, 直接插入一个 tensor.最常见的用例是将某些特殊的操作指定为 "feed" 操作, 标记的方法是使用 tf.placeholder() 为这些操作创建占位符.'''input1 = tf.placeholder(tf.float32)input2 = tf.placeholder(tf.float32)output = tf.multiply(input1, input2)with tf.Session() as sess: print(sess.run([output], feed_dict=&#123;input1:[7.], input2:[2.]&#125;)) 运行结果1234560123[21.0, 7.0][array([14.], dtype=float32)]]]></content>
      <categories>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>机器学习</tag>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[交互式使用]]></title>
    <url>%2F2018%2F08%2F26%2F%E4%BA%A4%E4%BA%92%E5%BC%8F%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[文档中的 Python 示例使用一个会话 Session 来 启动图, 并调用 Session.run() 方法执行操作. 为了便于使用诸如 IPython 之类的 Python 交互环境, 可以使用 InteractiveSession代替 Session 类, 使用 Tensor.eval() 和 Operation.run() 方法代替Session.run(). 这样可以避免使用一个变量来持有会话. 代码12345678910111213# 进入一个交互式TensorFlow会话import tensorflow as tfsess = tf.InteractiveSession()x = tf.Variable([1.0,2.0])a = tf.constant([3.0,3.0])# 使用初始化器 initializer op 的run()方法初始化'x'x.initializer.run()# 增加一个减法subtract op，从'x'减去'a'，运行减法op，输出结果sub = tf.subtract(x,a)print(sub.eval()) 运行结果1[-2. -1.]]]></content>
      <categories>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>机器学习</tag>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划问题——最长上升子序列(LIS)(三)]]></title>
    <url>%2F2018%2F08%2F26%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97(LIS)(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[推荐链接： 动态规划问题——最长上升子序列(LIS)(一) 动态规划问题——最长上升子序列(LIS)(二) 大佬给的思路，宝石叔叔博客里面有更多精彩！ 上一个版本用二分法优化了时间复杂度，但其实根据数据的样本观察可知，后面的数据都是重复的，我们只需要当列表遍历到一小时数据的最后时将后面数据的最大数加入到列表即可，这样可以快速跳出循环，避免后面不必要的查找 以下代码略有区别，一种是计算数目，一种是使用新列表存储，但大致思路类似。 写完之后发现可以考虑的情况还是有的，还可以继续优化，不过优化到这里应该也差不多了，列表的append方法性能上是非常好的。两个版本Java耗时0.000196s，Python耗时0.000050s Java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); while (true) &#123; int k = scan.nextInt(); int t = scan.nextInt(); int[] arr = new int[k]; for (int i = 0; i &lt; arr.length; ++i) arr[i] = scan.nextInt(); System.out.println(new Main().lengthOfLIS(arr, t)); &#125; &#125; public int lengthOfLIS(int[] nums, int count) &#123; int[] dp = new int[nums.length]; dp[0] = -1; // 获取nums数组里面的最大数字 int[] maxCount = getMaxCount(nums); int maxLen = 0, t = 1; boolean flag = true; for (; t &lt;= count; t++) &#123; int count2 = 0; if (flag) &#123; for (int i = 0; i &lt; nums.length; i++) &#123; if (maxLen == 0) &#123; dp[maxLen++] = nums[i]; &#125; else &#123; if (nums[i] &gt;= dp[maxLen - 1]) &#123; if (nums[i] == maxCount[0]) count2++; dp[maxLen++] = nums[i]; if (maxLen - 1 == nums.length - 1) &#123; flag = false; maxLen += maxCount[1] - count2; break; &#125; &#125; else &#123; int index = binarySearch(dp, maxLen - 1, nums[i]); dp[index] = nums[i]; &#125; &#125; &#125; if (!flag) break; &#125; &#125; return maxLen + (count - t) * maxCount[1]; &#125; public int binarySearch(int[] dp, int len, int target) &#123; int start = 0, end = len - 1; while (start &lt;= end) &#123; int mid = (start + end) / 2; if (dp[mid] &gt; target) end = mid - 1; else if (dp[mid] &gt; target) start = mid + 1; else return mid; &#125; return start; &#125; public int[] getMaxCount(int[] nums) &#123; int max = Integer.MIN_VALUE, count = 0; for (int i = 0; i &lt; nums.length; i++) max = Math.max(max, nums[i]); for (int i = 0; i &lt; nums.length; i++) &#123; if (max == nums[i]) count++; &#125; return new int[]&#123;max, count&#125;; &#125;&#125; Python代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162def longestIncreasingSubsequence(nums, n, m): if nums == None or len(nums) == 0: return 0 testarray = list() maxNum = max(nums) minNum = min(nums) count = 0 for i in range(len(nums)): if i == n: for j in range(m - 1): testarray.append(maxNum) break # 如果是第一个位置就直接添加进新的列表里面，如果后一个元素比新列表的最后一个元素大或者等于，则添加该元素到新列表末尾 if len(testarray) == 0 or nums[i] &gt;= testarray[len(testarray) - 1]: testarray.append(nums[i]) # 这一行的目的是保证新列表中的数据全部都是顺序递增的，不让后面的小的数据插入到前面，防止数列个数对了，但是实际上数据不是正序的情况 # 1、如果是一小时采样点的最后一个，比如8 6 7 4， 4就是一小时中最后一个采样点，而且这个数是最小值，就跳过本次循环 # 2、如果是一小时采样点的最后一个，比如10 3 7 5， 5就是一小时中最后一个采样点，而且这个数比之前数列的最后一个值小，就跳过本次循环 elif nums[i] == minNum and (i % (n - 1) == 0) or nums[i] &lt; testarray[len(testarray) - 1] and (i % (n - 1) == 0): continue else: # 如果这个新元素不大于等于最后一个元素的时候，利用二分查找找到他在新列表中应该插入的位置 index = findFirstLargeEqual(testarray, nums[i]) # 将新元素替换对应位置的列表里面的元素 testarray[index] = nums[i] return len(testarray)# 利用二分查找法def findFirstLargeEqual(testarray, target): left = 0 right = len(testarray) - 1 if testarray[0] == target: return 0 while left &lt;= right: # 双斜杠整除 mid = (left + right) // 2 if testarray[mid] &gt; target: right = mid - 1 elif testarray[mid] &lt; target: left = mid + 1 else: return mid return leftif __name__ == "__main__": a = list() # 输入n m n, m = input().split() # 输入采样点 n = int(n) a = input().split() # 截取输入的前n个（控制输入） a = a[:n] # 全部转化为整形 for i in range(n): a[i] = int(a[i]) # 按照小时数重复 a = a * int(m) count = longestIncreasingSubsequence(a, n, int(m)) print(count) 运行结果1235 105 6 7 9 113]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>DP</tag>
        <tag>Python</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划问题——最长上升子序列(LIS)(二)]]></title>
    <url>%2F2018%2F08%2F25%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97(LIS)(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[推荐链接： 动态规划问题——最长上升子序列(LIS)(一) 动态规划问题——最长上升子序列(LIS)(三) 题目描述一天，小凯同学震惊的发现，自己无内的PM2.5指标是有规律的！小凯采样了PM2.5数值，发现PM2.5数值以小时为周期循环，即任意时刻的PM2.5总是和一小时前相等！他的室友小文同学提出了这样一个问题，在t小时内的所有采样点中，选取若干采样点的数值，能否找到一个PM2.5不曾下降过的序列？这个序列最长是多少？ 输入描述第一行有两个整数n和t，表示每小时的采样点个数，和询问多少个小时的结果。第二行有n个整数，以空格分割，表示一小时内，每个采样点观测到的PM2.5数值 输出描述一个整数，表示T小时内，最长的PM2.5不曾下降过的序列的长度 输入124 310 3 7 5 输出14 说明3小时内的所有采样点为 10 3 7 5 10 3 7 5 10 3 7 5 选取第2，3，5，9个采样点，可以得到一个不曾下降过的序列 3 7 10 10 使用其他的方法也可以得到长为4的满足条件的序列，但无法得到长度超过4的结果。 备注12345对于20%的数据，t=1对于50%的数据，t&lt;=1000对于80%的数据，PM2.5数值不超过200对于100%的数据，1&lt;=n&lt;=1000,1&lt;=t&lt;=1000000，PM2.5数值为正整数，且不超过1000000000 优化时间复杂度(外层为n，内层为logn) 这里是定义一个testarray数组，存储这个升序子序列，对于新来的元素，通过二分查找，插入到这个testarray数组中，当大于或者等于testarray数组最后一个元素的时候直接在最后插入，如果在testarray数组中间位置，就直接在中间位置插入,(Tips：说明中间位置额那个数比需要插入的数字大，我们找的是最长的升序子序列，比他大的当然需要被小的替代了)，由于testarray数组是动态变化的，最后testarray数组的大小就是最长升序子序列，并且其存储的数就是这个升序子序列。 Java代码1234567891011121314151617181920212223242526272829303132public class Solution &#123; public int longestIncreasingSubsequence(int[] nums) &#123; int len = nums.length; if(nums == null || len ==0) return 0; ArrayList&lt;Integer&gt; dp = new ArrayList&lt;Integer&gt;(); for(int i=0;i&lt;len ;i++)&#123; if(dp.isEmpty() || dp.get(dp.size() - 1) &lt;= nums[i]) dp.add(nums[i]); else&#123; int index = findFirstLargeEqual(dp,nums[i]); dp.set(index,nums[i]);// 用指定的元素替代此列表中指定位置上的元素。 &#125; &#125; return dp.size(); &#125; public int findFirstLargeEqual(ArrayList&lt;Integer&gt; list,int num)&#123; int left = 0; int right = list.size() - 1; while(left &lt;=right)&#123; int mid = (left + right)/2; if(list.get(mid) &gt; num) right = mid -1; else if(list.get(mid) &lt; num) left = mid + 1; else return mid; &#125; return left; &#125;&#125; Python代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950def longestIncreasingSubsequence(nums): if nums == None or len(nums) == 0: return 0 testarray = list() for i in range(len(nums)): # 如果是第一个位置就直接添加进新的列表里面，如果后一个元素比新列表的最后一个元素大或者等于，则添加该元素到新列表末尾 if len(testarray) == 0 or nums[i] &gt;= testarray[len(testarray) - 1]: testarray.append(nums[i]) else: # 如果这个新元素不大于等于最后一个元素的时候，利用二分查找找到他在新列表中应该插入的位置 index = findFirstLargeEqual(testarray, nums[i]) # 将新元素替换对应位置的列表里面的元素 testarray[index] = nums[i] return len(testarray)# 利用二分查找法def findFirstLargeEqual(testarray, target): left = 0 right = len(testarray) - 1 if testarray[0] == target: return 0 while left &lt;= right: # 双斜杠整除 mid = (left + right) // 2 if testarray[mid] &gt; target: right = mid - 1 elif testarray[mid] &lt; target: left = mid + 1 else: return mid return leftif __name__ == "__main__": a = list() # 输入n m n, m = input().split() # 输入采样点 n = int(n) a = input().split() # 截取输入的前n个（控制输入） a = a[:n] # 全部转化为整形 for i in range(n): a[i] = int(a[i]) # 按照小时数重复 a = a * int(m) count = longestIncreasingSubsequence(a) print(count) 运行结果1234 310 3 7 54]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>DP</tag>
        <tag>Python</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划问题——最长上升子序列(LIS)(一)]]></title>
    <url>%2F2018%2F08%2F25%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97(LIS)(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[推荐链接： 动态规划问题——最长上升子序列(LIS)(二) 动态规划问题——最长上升子序列(LIS)(三) 如：求 2 7 1 5 6 4 3 8 9 的最长上升子序列。我们定义d(i) (i∈[1,n])来表示前i个数以A[i]结尾的最长上升子序列长度。 前1个数 d(1)=1 子序列为2； 前2个数 7前面有2小于7 d(2)=d(1)+1=2 子序列为2 7 前3个数 在1前面没有比1更小的，1自身组成长度为1的子序列 d(3)=1 子序列为1 前4个数 5前面有2小于5 d(4)=d(1)+1=2 子序列为2 5 前5个数 6前面有2 5小于6 d(5)=d(4)+1=3 子序列为2 5 6 前6个数 4前面有2小于4 d(6)=d(1)+1=2 子序列为2 4 前7个数 3前面有2小于3 d(3)=d(1)+1=2 子序列为2 3 前8个数 8前面有2 5 6小于8 d(8)=d(5)+1=4 子序列为2 5 6 8 前9个数 9前面有2 5 6 8小于9 d(9)=d(8)+1=5 子序列为2 5 6 8 9 d(i)=max{d(1),d(2),……,d(i)} 我们可以看出这9个数的LIS为d(9)=5 Java代码1234567891011121314151617181920212223242526272829public class Main &#123; int LIS(int A[], int n) &#123; int d[] = new int[n]; int len = 1; int i, j; for (i = 0; i &lt; n; i++) &#123; d[i] = 1; for (j = 0; j &lt; i; j++) &#123; // 当前的位置的数与之前的数比较，如果数列是上升的，且序列长度+1比当前序列长度大或相等 if (A[j] &lt;= A[i] &amp;&amp; (d[j] + 1) &gt;= d[i]) //使这个数之前的最大长度加1（最长上升序列加上这个数） d[i] = d[j] + 1; &#125; // 把当前d[i]的最大长度赋值给len if (d[i] &gt; len) len = d[i]; &#125; // 返回最长上升子序列的长度 return len; &#125; public static void main(String[] args) &#123; int A[] = &#123;2, 7, 1, 5, 6, 4, 3, 8, 9&#125;; int n = A.length; Main test = new Main(); int count = test.LIS(A, n); System.out.println(count); &#125;&#125; 运行结果15 Python代码1234567891011121314151617181920212223242526272829303132333435363738394041# 第一种写法def longestIncreasingSubsequence(nums, length): # 如果列表为空或者列表长度为0就直接返回0 if nums == None or len(nums) == 0: return 0 # 初始化列表为length个0，用来记录到当前位置的最长升序序列的长度 sublongest = [0 for i in range(length)] sublongest[0] = 1 longest = 0 for i in range(1, length): sublong = 0 for j in range(0, i): # 如果当前元素比前面的元素大 if nums[j] &lt;= nums[i]: # 则将前面元素的最长序列和当前的最长序列比较大小，把大的赋值给sublong sublong = max(sublongest[j], sublong) # 加上到自身位置那个元素 sublongest[i] = sublong + 1 # 比较长度列表末尾的元素和longest的大小，把两者大的赋值给longest longest = max(sublongest[i], longest) return longest# 第二种写法def longestIncreasingSubsequence2(Testarray, num): d = [0 for i in range(num)] longest = 1 for i in range(num): d[i] = 1 for j in range(i): if (Testarray[j] &lt;= Testarray[i]) and (d[j] + 1) &gt;= d[i]: d[i] = d[j] + 1 if d[i] &gt; longest: longest = d[i] return longestif '__name__ = __main__': a = [2, 7, 1, 5, 6, 4, 3, 8, 9] # count = longestIncreasingSubsequence(a,len(a)) count = longestIncreasingSubsequence2(a, len(a)) print(count) 运行结果15]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>DP</tag>
        <tag>Python</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一个使用Tensorflow的程序]]></title>
    <url>%2F2018%2F08%2F24%2F%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%BD%BF%E7%94%A8Tensorflow%E7%9A%84%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[构建图构建图的第一步, 是创建源 op (source op). 源 op 不需要任何输入, 例如 常量 (Constant). 源 op 的输出被传递给其它 op 做运算. Python 库中, op 构造器的返回值代表被构造出的 op 的输出, 这些返回值可以传递给其它 op 构造器作为输入. TensorFlow Python 库有一个默认图 (default graph), op 构造器可以为其增加节点 默认图现在有三个节点, 两个 constant() op, 和一个matmul() op. 为了真正进行矩阵相乘运算, 并得到矩阵乘法的 结果, 你必须在会话里启动这个图. 在一个会话中启动图构造阶段完成后, 才能启动图. 启动图的第一步是创建一个 Session 对象, 如果无任何创建参数, 会话构造器将启动默认图. 代码123456789101112131415161718192021222324252627282930313233343536import tensorflow as tf# op称为图的节点# 创建一个常量op，产生一个1x2矩阵，这个op被作为一个节点# 加到默认图中# 构造器的返回值代表该常量op的返回值matrix1 = tf.constant([[3., 3.]])# 创建另一个常量op，产生一个 2x1矩阵matrix2 = tf.constant([[2.], [2.]])# 创建一个矩阵乘法 matmul op , 把 'matrix1' 和 'matrix2' 作为输入.# 返回值 'product' 代表矩阵乘法的结果.'''默认图现在有三个节点, 两个 constant() op, 和一个matmul() op. 为了真正进行矩阵相乘运算, 并得到矩阵乘法的 结果, 你必须在会话里启动这个图.'''product = tf.matmul(matrix1, matrix2)# 启动默认图.sess = tf.Session()# 调用 sess 的 'run()' 方法来执行矩阵乘法 op, 传入 'product' 作为该方法的参数.# 上面提到, 'product' 代表了矩阵乘法 op 的输出, 传入它是向方法表明, 我们希望取回# 矩阵乘法 op 的输出.## 整个执行过程是自动化的, 会话负责传递 op 所需的全部输入. op 通常是并发执行的.## 函数调用 'run(product)' 触发了图中三个 op (两个常量 op 和一个矩阵乘法 op) 的执行.## 返回值 'result' 是一个 numpy `ndarray` 对象.result = sess.run(product)print(result)# ==&gt; [[ 12.]]# 任务完成, 关闭会话.sess.close() 运行结果1[[12.]]]]></content>
      <categories>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>机器学习</tag>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Numpy中的数组维度]]></title>
    <url>%2F2018%2F08%2F22%2FNumpy%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E7%BB%B4%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[在对 np.arange(24)(0, 1, 2, 3, …, 23) 进行重新的排列时，在多维数组的多个轴的方向上，先分配最后一个轴（对于二维数组，即先分配行的方向，对于三维数组即先分配平面的方向） 代码123456789101112131415import numpy as np# 一维数组a = np.arange(24)print("a的维度:\n",a.ndim)# 现在调整其大小,2行3列4个平面b = np.reshape(np.arange(24), (2, 3, 4))# b 现在拥有三个维度print("b(也是三维数组):\n",b)# 分别看看每一个平面的构成print("b的每一个平面的构成：\n")print(b[:, :, 0])print(b[:, :, 1])print(b[:, :, 2])print(b[:, :, 3]) 运行结果1234567891011121314151617181920a的维度: 1b(也是三维数组): [[[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] [[12 13 14 15] [16 17 18 19] [20 21 22 23]]]b的每一个平面的构成：[[ 0 4 8] [12 16 20]][[ 1 5 9] [13 17 21]][[ 2 6 10] [14 18 22]][[ 3 7 11] [15 19 23]]]]></content>
      <categories>
        <category>Numpy</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型和arange方法、astype方法的使用]]></title>
    <url>%2F2018%2F08%2F22%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8Carange%E6%96%B9%E6%B3%95_astype%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Numpy支持比Python更多的数字类型 数据类型 描述 bool_ 布尔（True或False），存储为一个字节 int_ 默认整数类型（与Clong相同；通常是int64或int32） INTC 与Cint（通常为int32或int64）相同 INTP 用于索引的整数（与Cssize_t相同；通常是int32或int64） INT8 字节（-128至127） INT16 整数（-32768至32767） INT32 整数（-2147483648至2147483647） Int64的 整数（-9223372036854775808至9223372036854775807） UINT8 无符号整数（0到255） UINT16 无符号整数（0到65535） UINT32 无符号整数（0到4294967295） UINT64 无符号整数（0到18446744073709551615） float_ float64的简写。 float16 半精度浮点：符号位，5位指数，10位尾数 FLOAT32 单精度浮点数：符号位，8位指数，23位尾数 float64 双精度浮点：符号位，11位指数，52位尾数 complex_ complex128的简写。 complex64 复数，由两个32位浮点数（实部和虚部） complex128 复数，由两个64位浮点数（实部和虚部） 除了intc之外，还定义了平台相关的C整数类型short，long，longlong。 arange函数用于创建等差数组，使用频率非常高，arange非常类似range函数 ,两者的区别仅仅是arange返回的是一个数据，而range返回的是list 。要转换数组的类型，请使用.astype()方法（首选）或类型本身作为函数 代码12345678910111213141516171819import numpy as npz = np.arange(5)print(z)print(z.dtype)print(50*'*')# 转化数据类型为float64floar_arr = z.astype(np.float64)print(floar_arr)print(floar_arr.dtype)print(50*'*')# 如果将浮点数转换为整数，则小数部分会被截断z2 = np.array([5.1,9.2,8.3,7.4,3.3214])print(z2)print(z2.astype(np.int32))print(50*'*')# arange的用法print(np.arange(1, 5))print(np.arange(0, 10, 2)) 运行结果1234567891011[0 1 2 3 4]int32**************************************************[0. 1. 2. 3. 4.]float64**************************************************[5.1 9.2 8.3 7.4 3.3214][5 9 8 7 3]**************************************************[1 2 3 4][0 2 4 6 8]]]></content>
      <categories>
        <category>Numpy</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ndarray对象]]></title>
    <url>%2F2018%2F08%2F22%2FNdarray%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[NumPy 中定义的最重要的对象是称为 ndarray 的 N 维数组类型。 它描述相同类型的元素集合。 可以使用基于零的索引访问集合中的项目。ndarray 中的每个元素在内存中使用相同大小的块。基本的 ndarray 是使用 NumPy 中的数组函数创建的，如：numpy.array 它从任何暴露数组接口的对象，或从返回数组的任何方法创建一个ndarray。 numpy.array(object,dtype=None,copy=True,order=None,subok=False,ndmin=0 上面的构造器接受以下参数： 序号 参数及描述 1. object 任何暴露数组接口方法的对象都会返回一个数组或任何（嵌套）序列。 2. dtype 数组的所需数据类型，可选。 3. copy 可选，默认为true，对象是否被复制。 4. order C（按行）、F（按列）或A（任意，默认）。 5. subok 默认情况下，返回的数组被强制为基类数组。 如果为true，则返回子类。 6. ndimin 指定返回数组的最小维数。 代码1234567891011121314151617import numpy as npa = np.array([1,2,3])print(a,"\n")# 当维度比一维高时b = np.array([[1,2],[3,4]])print(b,"\n")# zeros(shape)将创建一个用指定形状用0填充的数组print(np.zeros((2,3)),"\n")# ones(shape)将创建一个用1填充的数组print(np.ones((3,3)),"\n")# 最小维度c = np.array([1,2,3,4,5],ndmin=2)print(c,"\n")# dtype参数a = np.array([1,2,3],dtype=complex)print(a,"\n") 运行结果123456789101112131415[1 2 3] [[1 2] [3 4]] [[0. 0. 0.] [0. 0. 0.]] [[1. 1. 1.] [1. 1. 1.] [1. 1. 1.]] [[1 2 3 4 5]] [1.+0.j 2.+0.j 3.+0.j]]]></content>
      <categories>
        <category>Numpy</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Numpy中花式索引和shape用法]]></title>
    <url>%2F2018%2F08%2F20%2FNumpy%E4%B8%AD%E8%8A%B1%E5%BC%8F%E7%B4%A2%E5%BC%95%E5%92%8Cshape%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[总结一下最近学习中容易出现问题的地方❗️ ❗️ ❗️ 代码1234567891011from numpy import *randMat = random.randint(0, 10, (4, 3))print("原矩阵:\n", randMat)# 索引从0开始计数print("输出第一行的所有数据:\n", randMat[0, :])print("输出第二列的所有数据:\n", randMat[:, 1])print("输出矩阵第1和第3行的所有数据:\n", randMat[[0, 2], :])print("行数:\n",randMat.shape[0])print("列数:\n",randMat.shape[1])print("维数:\n",randMat.shape) 运行结果123456789101112131415161718原矩阵: [[3 5 1] [1 3 0] [0 2 1] [0 2 9]]输出第一行的所有数据: [3 5 1]输出第二列的所有数据: [5 3 2 2]输出矩阵第1和第3行的所有数据: [[3 5 1] [0 2 1]]行数: 4列数: 3维数: (4, 3) 2018年8月22日 21:40:54更新，新增：使用shape和reshape调整数组大小 代码123456import numpy as npa = np.array([[1,2,3],[4,5,6]]) a.shape = (3,2)b = a.reshape(2,3)print(a)print(b) 运行结果12345[[1 2] [3 4] [5 6]][[1 2 3] [4 5 6]]]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kNN识别手写图像]]></title>
    <url>%2F2018%2F08%2F16%2FkNN%E8%AF%86%E5%88%AB%E6%89%8B%E5%86%99%E5%9B%BE%E5%83%8F%2F</url>
    <content type="text"><![CDATA[示例 ：使用k-近邻算法的手写识别系统(1) 收集数据：提供文本文件。(2) 准备数据：编写函数classify0(), 将图像格式转换为分类器使用的list格式。(3) 分析数据：检查数据，确保它符合要求。(4) 训练算法：此步驟不适用于k-近邻算法。(5) 测试算法：编写函数使用提供的部分数据集作为测试样本，测试样本与非测试样本的区别在于测试样本是已经完成分类的数据，如果预测分类与实际类别不同，则标记为一个错误。(6) 使用算法：本例没有完成此步骤，若你感兴趣可以构建完整的应用程序，从图像中提取数字，并完成数字识别，美国的邮件分拣系统就是一个实际运行的类似系统。 注：由于原本数据集已经在0和1之间，所以不需要转化数字特征值。[数据集](http://pd10tty87.bkt.clouddn.com/knn%E8%AF%86%E5%88%AB%E6%89%8B%E5%86%99%E5%9B%BE%E5%83%8F.zip) 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586from numpy import *from os import listdirimport operatordef classify0(inX, dataSet, labels, k): dataSetSize = dataSet.shape[0] # 距离计算 ''' tile(A，rep) 功能：重复A的各个维度 参数类型： A: Array类的都可以 rep：A沿着各个维度重复的次数 ''' diffMat = tile(inX, (dataSetSize, 1)) - dataSet sqDiffMat = diffMat ** 2 # numpy中的 axis=0表示列,向下，axis=1表示行，向右 # 在平时使用的sun默认的是axis=0就是普通的相加，当加入axis=1以后就是将一个矩阵的每一行向量相加 sqDistances = sqDiffMat.sum(axis=1) distances = sqDistances ** 0.5 # argsort函数返回的是数组值从小到大的索引值 sortedDistIndicies = distances.argsort() classCount = &#123;&#125; # 选择距离最小的k个点 for i in range(k): votellabel = labels[sortedDistIndicies[i]] classCount[votellabel] = classCount.get(votellabel, 0) + 1 # 排序 sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse=True) return sortedClassCount[0][0]def img2vector(filename): # 将图像矩阵转化为1x1024的向量 returnVect = zeros((1, 1024)) fr = open(filename) # 循环读出文件的前32行 for i in range(32): lineStr = fr.readline() # 将每行的头32个字符值存储在Numpy数组中 for j in range(32): returnVect[0, 32 * i + j] = int(lineStr[j]) # 返回数组 return returnVectdef handwritingClassTest(): hwLabels = [] # 获取训练数据集下目录的所有文件名的列表 trainingFileList = listdir('trainingDigits') # 得到文件数量 m = len(trainingFileList) # 创建m行1024列的训练矩阵 trainingMat = zeros((m, 1024)) for i in range(m): # 从文件名解析分类数字 # 解析出0_10.txt fileNameStr = trainingFileList[i] # 获得0_10 fileStr = fileNameStr.split('.')[0] # 获得0 classNumStr = int(fileStr.split('_')[0]) hwLabels.append(classNumStr) trainingMat[i, :] = img2vector('trainingDigits/%s' % fileNameStr) # 获得测试数据集下目录的所有文件名的列表 testFileList = listdir('testDigits') errorCount = 0.0 mTest = len(testFileList) for i in range(mTest): fileNameStr = testFileList[i] fileStr = fileNameStr.split('.')[0] classNumStr = int(fileStr.split('_')[0]) vectorUnderTest = img2vector('testDigits/%s' % fileNameStr) classifierResult = classify0(vectorUnderTest, trainingMat, hwLabels, 3) print("the classifier came back with:%d,the real answer is:%d" % (classifierResult, classNumStr)) if (classifierResult != classNumStr): errorCount += 1.0 print("\nthe total number of errors is:%d" % errorCount) print("\nthe total error rate is :%f" % (errorCount / float(mTest)))testVector = img2vector('testDigits/0_13.txt')# X[:, m:n]，即取二维数组中的第m到n-1列的所有数据print("测试输出:\n", testVector[0, 0:31])handwritingClassTest() 运行结果12345678910111213141516171819the classifier came back with:1,the real answer is:1the classifier came back with:1,the real answer is:1.....the classifier came back with:5,the real answer is:5the classifier came back with:5,the real answer is:5the classifier came back with:6,the real answer is:6the classifier came back with:6,the real answer is:6....the classifier came back with:9,the real answer is:9the classifier came back with:9,the real answer is:9the classifier came back with:9,the real answer is:9the total number of errors is:11# 错误率为1.2%the total error rate is :0.011628]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Numpy</tag>
        <tag>机器学习</tag>
        <tag>k-近邻算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用k-近邻算法改进约会网站的配对效果]]></title>
    <url>%2F2018%2F08%2F11%2F%E4%BD%BF%E7%94%A8k-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%E6%94%B9%E8%BF%9B%E7%BA%A6%E4%BC%9A%E7%BD%91%E7%AB%99%E7%9A%84%E9%85%8D%E5%AF%B9%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[***实例：在约会网站上使用k-近邻算法*** (1) 收集数据：提供文本文件。(2) 准备数据 : 使用python解析文本文件。(3) 分析数据 使用 Matplotlib画二维扩散图 。(4) 训练算法：此步驟不适用于k-近邻算法。(5) 测试算法：使用海伦提供的部分数据作为测试样本。测试样本和非测试样本的区别在于：测试样本是已经完成分类的数据，如果预测分类与实际类别不同，则标记为一个错误。(6) 使用算法：产生简单的命令行程序，然后可以输入一些特征数据以判断对方是否为自己喜欢的类型。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172from numpy import *import operatorimport matplotlibimport matplotlib.pyplot as pltdef createDateSet(): group = array([[1.0, 1.1], [1.0, 1.0], [0, 0], [0, 0.1]]) labels = ['A', 'A', 'B', 'B'] return group, labels''' 用于分类的输人向量是inX， 输入的训练样本集为dataSet, 标签向量为labels 最后的参数k表示用于选择最近邻居的数目， 其中标签向量的元素数目和矩阵dataSet的行数相同'''def classify0(inX, dataSet, labels, k): dataSetSize = dataSet.shape[0] # 距离计算 diffMat = tile(inX, (dataSetSize, 1)) - dataSet sqDiffMat = diffMat ** 2 sqDistances = sqDiffMat.sum(axis=1) distances = sqDistances ** 0.5 sortedDistIndicies = distances.argsort() classCount = &#123;&#125; # 选择距离最小的k个点 for i in range(k): votellabel = labels[sortedDistIndicies[i]] classCount[votellabel] = classCount.get(votellabel, 0) + 1 # 排序 sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse=True) return sortedClassCount[0][0]# 将文本记录转换到Numpy的解析程序def file2matrix(filename): fr = open(filename) arrayOLines = fr.readlines() # 得到文件行数 numberOfLines = len(arrayOLines) # 创建返回的Numpy矩阵，将该矩阵的另一维度设置为3 returnMat = zeros((numberOfLines, 3)) classLabelVector = [] index = 0 # 解析文件数据到列表，循环处理每行数据 for line in arrayOLines: # 截取掉所有的回车字符 line = line.strip() # 使用tab字符\t将上一步得到的整行数据分割成一个元素列表 listFromLine = line.split('\t') # 选取前3个元素，将他们存储到特征矩阵中 returnMat[index, :] = listFromLine[0:3] # -1表示列表中的最后一列元素，将最后一列元素存储到向量classLabelVector中 classLabelVector.append(int(listFromLine[-1])) index += 1 return returnMat, classLabelVectordatingDataMat, datingLabels = file2matrix('datingTestSet2.txt')print("array:\n", datingDataMat)print("datingLabels[0:20]\n", datingLabels[0:20])# 绘制散点图# 定义figurefig = plt.figure()#add_subplot()返回一个axes对象，里面的参数abc表示在一个figure窗口中，有a行b列个小窗口，然后本次plot在第c个窗口中。ax = fig.add_subplot(111)# 设置颜色和散点图数据ax.scatter(datingDataMat[:, 1], datingDataMat[:, 2], 15.0 * array(datingLabels), 15.0 * array(datingLabels))plt.show() [数据集](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/datingTestSet.txt) 运行结果12345678910array: [[ 4.09200000e+04 8.32697600e+00 9.53952000e-01] [ 1.44880000e+04 7.15346900e+00 1.67390400e+00] [ 2.60520000e+04 1.44187100e+00 8.05124000e-01] ..., [ 2.65750000e+04 1.06501020e+01 8.66627000e-01] [ 4.81110000e+04 9.13452800e+00 7.28045000e-01] [ 4.37570000e+04 7.88260100e+00 1.33244600e+00]]datingLabels[0:20] [3, 2, 1, 1, 1, 1, 3, 3, 1, 3, 1, 1, 2, 1, 1, 1, 1, 1, 2, 3] 散点图结果： 2018年8月11日 16:49:36 新增：归一化特征值，测试代码，预测代码 因为在欧氏距离中数值差值最大的属性对计算结果的影响最大，但其实多个特征都是同等重要的属性，这样如果其中一个占的权重过大，会严重影响到计算的结果 所以在处理不同取值范围的特征值的时候，我们通常采用的方法是将数值归一化，如将取值范围处理为0到1或者-1到1之间。 公式：newValue = （oldValue - min）/（max - min） 其中min和max分别是数据集中的最小特征值和最大特征值。虽然改变数值取值范围增加了分类器的复杂度，但为了得到准确的结果，这样做是必然的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# 将数字特征值转化为0到1的区间def autoNorm(dataSet): # 将每列的最小值放在变量minVals中，dataSet.min(0)中的参数0使得函数可以从列中选取最小值 minVals = dataSet.min(0) # 将每列的最大值放在变量maxVals中 maxVals = dataSet.max(0) ranges = maxVals - minVals normDataSet = zeros(shape(dataSet)) m = dataSet.shape[0] # 为了归一化特征值，必须使用当前值减去最小值，然后除以取值范围 # tile()函数将变量内容复制成输入矩阵同样大小的矩阵 normDataSet = dataSet - tile(minVals, (m, 1)) # 特征值相除 normDataSet = normDataSet / tile(ranges, (m, 1)) return normDataSet, ranges, minVals# 分类器针对约会网站的测试代码def datingClassTest(): hoRatio = 0.10 # 首先使用file2matrix和autoNorm()函数从文件中读取数据并将其转换为归一化特征值 datingDataMat, datingLabels = file2matrix('datingTestSet2.txt') normMat, ranges, minVals = autoNorm(datingDataMat) # 计算测试向量的数量，决定normMat向量中哪些数据用于测试，哪些数据用于分类器的训练样本 m = normMat.shape[0] numTestVecs = int(m * hoRatio) errorCount = 0.0 # 将两部分数据输入到原始分类器函数classify0 for i in range(numTestVecs): classifierResult = classify0(normMat[i, :], normMat[numTestVecs:m, :], \ datingLabels[numTestVecs:m], 3) print("the classifier came back with:&#123;&#125;,the real answer is:&#123;&#125;".format(classifierResult, datingLabels[i])) if (classifierResult != datingLabels[i]): errorCount += 1.0 # 计算错误率并输出结果 print("the total error rate is:&#123;&#125;".format(errorCount / float(numTestVecs)))# 约会网站预测函数def classifyPerson(): resultList = ['not at all', 'in small doses', 'in large doses'] percentTats = float(input( \ "percentage of time spent playing video games?")) ffMiles = float(input("frequent flier miles earned per year?")) iceCream = float(input("liters of ice cream consumed per year?")) datingDataMat, datingLabels = file2matrix('datingTestSet2.txt') normMat, ranges, minVals = autoNorm(datingDataMat) inArr = array([ffMiles, percentTats, iceCream]) classifierResult = classify0((inArr - \ minVals) / ranges, normMat, datingLabels, 3) print("You will probably like this person:", \ resultList[classifierResult - 1]) 测试归一化特征值、分类器、选择喜欢的人： 123456789# 测试归一化特征值normMat, ranges, minVals = autoNorm(datingDataMat)print("array:\n", normMat)print("array:", ranges)print("array:", minVals)# 测试分类器datingClassTest()# 选择喜欢的人classifyPerson() 运行结果123456789101112131415161718192021222324252627# normMatarray: [[ 0.44832535 0.39805139 0.56233353] [ 0.15873259 0.34195467 0.98724416] [ 0.28542943 0.06892523 0.47449629] ..., [ 0.29115949 0.50910294 0.51079493] [ 0.52711097 0.43665451 0.4290048 ] [ 0.47940793 0.3768091 0.78571804]]# rangesarray: [ 9.12730000e+04 2.09193490e+01 1.69436100e+00]# minValsarray: [ 0. 0. 0.001156]# 测试分类器(数据太多了这里截取部分)the classifier came back with:3,the real answer is:3the classifier came back with:2,the real answer is:2......the classifier came back with:2,the real answer is:2the classifier came back with:1,the real answer is:1the classifier came back with:3,the real answer is:1# 分类器处理约会数据集的错误率为5%（书上为2.4%....不知道怎么回事）the total error rate is:0.05# 输入各个属性，得到最佳约会伙伴percentage of time spent playing video games?10frequent flier miles earned per year?10000liters of ice cream consumed per year?0.5You will probably like this person: in small doses]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>机器学习</tag>
        <tag>k-近邻算法</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kNN（k-近邻算法）]]></title>
    <url>%2F2018%2F08%2F09%2FkNN%EF%BC%88k-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[k-近邻算法（kNN），它的工作原理是：存在一个样本数据集合，也称作训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每一数据与所属分类的对应关系。输人没有标签的新数据后，将新数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本集中特征最相似数据（最近邻）的分类标签。一般来说，我们只选择样本数据集中前 k个最相似的数据，这就是 k- 近邻算法中k的出处 , 通常k是不大于 20 的整数。最后，选择k个最相似数据中出现次数最多的分类，作为新数据的分类。 ***k-近邻算法的一般流程*** 收集数据：可以使用任何方法。 准备数据：距离计算所需要的数值，最好是结构化的数据格式。 分析数据：可以使用任何方法。 训练算法：此步驟不适用于k-近邻算法。 测试算法：计算错误率。 使用算法：首先需要输入样本数据和结构化的输出结果，然后运行k-近邻算法判定输入数据分别属于哪个分类，最后应用对计算出的分类执行后续的处理。 使用欧氏距离公式，计算两个向量点xA和xB之间的距离： 例如，点 (0 ,0) 与 (1, 2) 之间的距离计算为： 如果数据集存在 4 个特征值，则点 (1 ,0, 0 ,1) 与 (7, 6, 9 ,4) 之间的距离计算为: 计算完所有点之间的距离后，可以对数据按照从小到大的次序排序。然后，确定前 k 个距离最小元素所在的主要分类 , 输人k总是正整数；最后，将classCount字典分解为元组列表，然后使用程序第二行导入运算符模块的itemgetter方法 ,按照第二个元素的次序对元组进行排序。此处的排序为逆序，即按照从最大到最小次序排序，最后返回发生频率最高的元素标签。 代码123456789101112131415161718192021222324252627282930313233343536373839from numpy import *import operatordef createDateSet(): group = array([[1.0, 1.1], [1.0, 1.0], [0, 0], [0, 0.1]]) labels = ['A', 'A', 'B', 'B'] return group, labels''' 用于分类的输人向量是inX， 输入的训练样本集为dataSet, 标签向量为labels 最后的参数k表示用于选择最近邻居的数目， 其中标签向量的元素数目和矩阵dataSet的行数相同'''def classify0(inX, dataSet, labels, k): dataSetSize = dataSet.shape[0] # 距离计算 diffMat = tile(inX, (dataSetSize, 1)) - dataSet sqDiffMat = diffMat ** 2 sqDistances = sqDiffMat.sum(axis=1) distances = sqDistances ** 0.5 sortedDistIndicies = distances.argsort() classCount = &#123;&#125; # 选择距离最小的k个点 for i in range(k): votellabel = labels[sortedDistIndicies[i]] classCount[votellabel] = classCount.get(votellabel, 0) + 1 # 排序 sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse=True) return sortedClassCount[0][0]group, labels = createDateSet()print(classify0([1.0, 1.1], group, labels, 3)) 运行结果1A]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>机器学习</tag>
        <tag>k-近邻算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Numpy库的首次使用]]></title>
    <url>%2F2018%2F08%2F09%2FNumpy%E5%BA%93%E7%9A%84%E9%A6%96%E6%AC%A1%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在pycharm中的setting安装numpy，或者在cmd里面通过pip install方法安装均可 代码12345678910111213141516from numpy import *# 构造一个4x4的随机数组print("数组:\n",random.rand(4, 4))# 调用mat()函数将数组转化为矩阵randMat = mat(random.rand(4, 4))# .I操作符实现了矩阵求逆的运算print("矩阵求逆:\n",randMat.I)# 矩阵乘以逆矩阵invRandMat = randMat.Iprint("矩阵乘以逆矩阵:\n",randMat*invRandMat)# 函数eye(4)创建一个4x4的单位矩阵，下面是算误差myEye = randMat*invRandMatprint("计算误差:\n",myEye-eye(4)) 运行结果1234567891011121314151617181920数组: [[ 0.46089523 0.94167701 0.76910005 0.96892095] [ 0.38894192 0.88828275 0.28144475 0.91774255] [ 0.13997437 0.7435124 0.89709322 0.68924161] [ 0.41461243 0.19911356 0.64856312 0.49160523]]矩阵求逆: [[-0.45014095 1.92871242 0.28217777 -0.76959459] [ 1.09829851 -0.9829715 -1.78955478 2.70643663] [ 0.95057662 -1.40675696 0.67345673 -0.70029109] [-1.11436955 -0.35496085 1.88297962 -0.76459429]]矩阵乘以逆矩阵: [[ 1.00000000e+00 7.20736257e-17 -3.04329603e-17 -1.66886258e-17] [ -2.27212878e-16 1.00000000e+00 2.93001892e-17 -1.63043911e-16] [ 8.73583235e-18 -3.06881469e-17 1.00000000e+00 -3.50839733e-17] [ -4.04804848e-17 1.45085950e-16 -1.23671214e-16 1.00000000e+00]]计算误差: [[ -1.11022302e-16 7.20736257e-17 -3.04329603e-17 -1.66886258e-17] [ -2.27212878e-16 2.22044605e-16 2.93001892e-17 -1.63043911e-16] [ 8.73583235e-18 -3.06881469e-17 -2.22044605e-16 -3.50839733e-17] [ -4.04804848e-17 1.45085950e-16 -1.23671214e-16 2.22044605e-16]]]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
        <tag>Numpy</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例设计模式]]></title>
    <url>%2F2018%2F08%2F08%2F%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[需要全局的对象唯一的时候，使用单例设计模式，几乎是最简单的设计模式……​ ​ ，以下是代码部分 代码12345678910111213141516171819202122232425262728293031323334# object写不写都可以，在python3.X中已经默认继承了，以前区别旧式类和新式类# 单例设计模式class MusicPlayer(object): # 记录第一个被创建对象的引用 instance = None # 记录是否执行过初始化方法 init_flag = False def __new__(cls, *args, **kwargs): # 1. 判断类属性是否是空对象 if cls.instance is None: # 2. 调用父类的方法，为第一个对象分配空间 cls.instance = super().__new__(cls) # 3. 返回类属性保存的对象引用 return cls.instance # 让初始化方法只执行一次 def __init__(self): # 1. 判断是否执行过初始化动作 if MusicPlayer.init_flag: return # 2. 如果没有执行过，执行初始化动作 print("111111111") # 3. 修改类属性的标记 MusicPlayer.init_flag = True# 创建多个对象player1 = MusicPlayer()print(player1)player2 = MusicPlayer()print(player2) 运行结果123111111111&lt;__main__.MusicPlayer object at 0x000000000342D0B8&gt;&lt;__main__.MusicPlayer object at 0x000000000342D0B8&gt; 可以看出2次对象的创建在内存上实际是一个地址]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的__new__方法的重写]]></title>
    <url>%2F2018%2F08%2F08%2Fpython%E4%B8%AD%E7%9A%84__new__%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99%2F</url>
    <content type="text"><![CDATA[new方法重写的步骤比较固定，直接上代码吧 代码123456789101112131415161718class MusicPlayer(object): # new方法的重写，是一个静态方法，必须主动传递cls参数 def __new__(cls, *args, **kwargs): # 1.创建对象时，new方法会被自动调用 print(&quot;创建对象，分配空间&quot;) # 2.为对象分配空间 instance = super().__new__(cls) # 3.返回对象的引用 return instance def __init__(self): print(&quot;111&quot;)player = MusicPlayer()print(player) 运行结果123创建对象，分配空间111&lt;__main__.MusicPlayer object at 0x0000000003A0D128&gt;]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的静态方法、实例方法、类方法的区别]]></title>
    <url>%2F2018%2F08%2F08%2Fpython%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E3%80%81%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E3%80%81%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[实例方法 ​ 定义：第一个参数必须是实例对象，该参数名一般约定为“self”，通过它来传递实例的属性和方法（也可以传类的属性和方法）； ​ 调用：只能由实例对象调用。 类方法 ​ 定义：使用装饰器@classmethod。第一个参数必须是当前类对象，该参数名一般约定为“cls”，通过它来传递类的属性和方法（不能传实例的属性和方法）； ​ 调用：实例对象和类对象都可以调用。 静态方法 ​ 定义：使用装饰器@staticmethod。参数随意，没有“self”和“cls”参数，但是方法体中不能使用类或实例的任何属性和方法； ​ 调用：实例对象和类对象都可以调用。 代码12345678910111213141516171819202122232425262728293031323334353637import timeclass Tool(object): count = 0 def __init__(self, name): self.name = name Tool.count += 1 # 定义一个实例方法，有self参数 def action(self): print("挥动&#123;&#125;".format(self.name)) # 定义一个类方法，有cls参数 @classmethod def shou_tool_count(cls): print("工具对象的数量&#123;&#125;".format(cls.count)) # 定义一个静态方法，初始没有任何参数 @staticmethod def showTime(): print(time.strftime("%H:%M:%S", time.localtime()))# 创建工具对象tool = Tool("斧头")too2 = Tool("榔头")# 调用类方法,逻辑上类方法一般由类自身调用，其实实例对象和类对象都可以调用Tool.shou_tool_count()# 调用实例方法,只能由实例对象调用tool.action()# 调用静态方法,实例对象和类对象均可调用too2.showTime()Tool.showTime() 运行结果1234工具对象的数量2挥动斧头20:30:4620:30:46]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的多态]]></title>
    <url>%2F2018%2F08%2F08%2Fpython%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[当子类和父类都存在相同的 game()方法时，子类的 game() 覆盖了父类的 game()，在代码运行时，会调用子类的 game()。 这样，我们就获得了继承的另一个好处：多态。 多态的好处就是，当我们需要传入更多的子类，例如新增 XX Dog、YY Dog 等时，我们只需要继承 Dog 类型就可以了，而game()方法既可以直不重写（即使用Dog的），也可以重写一个特有的。这就是多态的意思。调用方只管调用，不管细节，而当我们新增一种Dog的子类时，只要确保新方法编写正确，而不用管原来的代码。这就是著名的“开闭”原则： 对扩展开放（Open for extension）：允许子类重写方法函数 对修改封闭（Closed for modification）：不重写，直接继承父类方法函数 代码1234567891011121314151617181920212223242526272829303132333435class Dog(object): def __init__(self, name): self.name = name def game(self): print("&#123;&#125;跳".format(self.name))class XiaoTianDog(Dog): # 方法重写 def game(self): print("&#123;&#125;飞".format(self.name))class Person(object): def __init__(self, name): self.name = name def game_with_dog(self, dog): print("&#123;&#125;和&#123;&#125;玩耍".format(self.name, dog.name))# 创建Dog对象Peter = Dog("皮特")# 创建XiaoTianDog对象wangcai = XiaoTianDog("旺财")# 调用Dog里面的game方法Peter.game()# 调用XiaoTianDog里面的game方法wangcai.game()xiaoming = Person("小明")xiaoming.game_with_dog(wangcai) 运行结果123皮特跳旺财飞小明和旺财玩耍]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[turtle绘图库]]></title>
    <url>%2F2018%2F08%2F08%2Fturtle%E7%BB%98%E5%9B%BE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[大概学习了下turtle库的一个绘图实例= =，估计以后也用不上这个库…. 代码实例1： 绘制一条小蛇 123456789101112131415161718192021222324252627import turtle # 绘图库# 绘制一条小蛇# 设置窗体大小及位置，但并不是必须的，依次长,宽，如果后两项不设置，则默认正中心turtle.setup(650, 350, 200, 200)# 抬起画笔turtle.penup()# turtle.fd表示向海龟的右边走，turtle.bk表示向海龟的左边走turtle.fd(-250)# 下笔turtle.pendown()# 设置画笔宽度turtle.pensize(25)# 设置画笔颜色turtle.pencolor("purple")# 改变当前行径的方向，原地转向的意思，参数为绝对角度# turtle.left和turtle.right表示向左边或右边改变角度turtle.seth(-40)for i in range(4): # circle表示以某一个点为圆心，向左侧运行 turtle.circle(40, 80) turtle.circle(-40, 80)turtle.circle(40, 80 / 2)turtle.fd(40)turtle.circle(16, 100)turtle.fd(40 * 2 / 3)turtle.done() 运行结果 实例2：绘制一个Z 代码123456789import turtleturtle.left(45) # 转角度turtle.fd(150) # 前进turtle.right(135)turtle.fd(300)turtle.left(135)turtle.fd(150)turtle.done() 运行结果]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式中的compile函数(二)]]></title>
    <url>%2F2018%2F08%2F07%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84compile%E5%87%BD%E6%95%B0(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[接着上一篇文章的compile函数实例 代码12345678910111213import repattern = re.compile(r'([a-z]+) ([a-z]+)', re.I) # re.I 表示忽略大小写m = pattern.match('Hello World Wide Web')print(m) # 匹配成功，返回一个Match 对象print(m.group(0)) # 返回匹配成功的整个子串print(m.span(0)) # 返回匹配成功整个子串的索引print(m.group(1)) # 返回第一个分组匹配成功的子串print(m.span(1)) # 返回第一个分组匹配成功的子串的索引print(m.group(2)) # 返回第二个分组匹配成功的子串print(m.span(2)) # 返回第二个分组匹配成功的子串的索引print(m.groups()) # 等价于(m.group(1),m.group(2), ...)print(m.group(3)) # 不存在第三个分组 运行结果123456789101112Traceback (most recent call last):&lt;_sre.SRE_Match object; span=(0, 11), match='Hello World'&gt; File "E:/PythonProject/more/test.py", line 13, in &lt;module&gt;Hello World print(m.group(3)) # 不存在第三个分组(0, 11)IndexError: no such groupHello(0, 5)World(6, 11)('Hello', 'World')]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式中的compile函数]]></title>
    <url>%2F2018%2F08%2F07%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84compile%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。 语法格式为： re.compile(pattern[, flags]) 参数： pattern : 一个字符串形式的正则表达式 flags 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为： re.I 忽略大小写 re.L 表示特殊字符集 \w, \W, \b, \B, \s, \S 依赖于当前环境 re.M 多行模式 re.S 即为’ . ‘并且包括换行符在内的任意字符（’ . ‘不包括换行符） re.U 表示特殊字符集 \w, \W, \b, \B, \d, \D, \s, \S 依赖于 Unicode 字符属性数据库 re.X 为了增加可读性，忽略空格和’ # ‘后面的注释 代码12345678910111213141516171819202122import re# 列子1pattern = re.compile(r'\d+') # 用于匹配至少一个数字m = pattern.match('one12twothree34four') # 查找头部，没有匹配print(m)m = pattern.match('one12twothree34four', 2, 10) # 从'e'的位置开始匹配，没有匹配print(m)m = pattern.match('one12twothree34four', 3, 10) # 从'1'的位置开始匹配，正好匹配print(m) # 返回一个Match对象print(m.group(0)) # 可省略0print(m.start(0)) # 可省略0print(m.end(0)) # 可省略0print(m.span(0)) # 可省略0'''在上面，当匹配成功时返回一个 Match 对象，其中：group([group1, …]) 方法用于获得一个或多个分组匹配的字符串，当要获得整个匹配的子串时，可直接使用 group() 或 group(0)；start([group]) 方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引），参数默认值为 0；end([group]) 方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1），参数默认值为 0；span([group]) 方法返回 (start(group), end(group))。''' 运行结果1234567NoneNone&lt;_sre.SRE_Match object; span=(3, 5), match=&apos;12&apos;&gt;1235(3, 5)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式检索与替换]]></title>
    <url>%2F2018%2F08%2F07%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A3%80%E7%B4%A2%E4%B8%8E%E6%9B%BF%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[re.sub用于替换字符串中的匹配项 re.sub(pattern, repl, string, count=0) 代码123456789101112131415161718192021import rephone = "2004-959-559 # 这是一个电话号码"# 删除注释num = re.sub(r'#.*$', "", phone)print("电话号码:", num)# 移除非数字的内容num = re.sub(r'\D', "", phone)print("电话号码:", num)# 将匹配的数字乘以2def double(matched): value = int(matched.group('value')) return str(value * 2)s = 'A23G4HFD567'print(re.sub('(?P&lt;value&gt;\d+)', double, s)) 运行结果123电话号码: 2004-959-559 电话号码: 2004959559A46G8HFD1134]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中的正则表达式match和search]]></title>
    <url>%2F2018%2F08%2F07%2FPython%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fmatch%E5%92%8Csearch%2F</url>
    <content type="text"><![CDATA[re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配 代码123456789101112131415161718import re'''re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。'''line = "Cats are smarter than dogs";matchObj = re.match(r'dogs', line, re.M | re.I)if matchObj: print("match --&gt; matchObj.group() : ", matchObj.group())else: print("No match!!")matchObj = re.search(r'dogs', line, re.M | re.I)if matchObj: print("search --&gt; matchObj.group() : ", matchObj.group())else: print("No match!!") 运行结果12No match!!search --&gt; matchObj.group() : dogs]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中的正则表达式]]></title>
    <url>%2F2018%2F08%2F07%2FPython%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[主要是一些正则表达式的基本语法和部分实例 re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none re.match(pattern, string, flag=0) 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等 re.search 扫描整个字符串并返回第一个成功的匹配 re.search(pattern, string, flag=0) 代码12345678910111213141516171819202122232425262728293031323334353637import re'''group() 返回被 RE 匹配的字符串start() 返回匹配开始的位置end() 返回匹配结束的位置span() 返回一个元组包含匹配 (开始,结束) 的位置group() 返回re整体匹配的字符串，可以一次输入多个组号，对应组号匹配的字符串'''print(re.match('www', 'www.runoob.com').span()) # 在起始位置匹配print(re.match('com', 'www.runoob.com')) # 不在起始位置匹配# group(num=0) 匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。line = "Cats are smarter than dogs"# match部分matchObj = re.match(r'(.*) are (.*?) .*', line, re.M | re.I)if matchObj: print("matchObj.group():", matchObj.group()) print("matchObj.group(1):", matchObj.group(1)) print("matchObj.group(2):", matchObj.group(2))else: print("No match!!")# search部分searchObj = re.search(r'(.*) are (.*?) .*', line, re.M | re.I)if searchObj: print("searchObj.group() : ", searchObj.group()) print("searchObj.group(1) : ", searchObj.group(1)) print("searchObj.group(2) : ", searchObj.group(2))else: print("Nothing found!!")# re.search 扫描整个字符串并返回第一个成功的匹配。print(re.search('www', 'www.runoob.com').span()) # 在起始位置匹配print(re.search('com', 'www.runoob.com').span()) # 不在起始位置匹配 运行结果12345678910(0, 3)NonematchObj.group(): Cats are smarter than dogsmatchObj.group(1): CatsmatchObj.group(2): smartersearchObj.group() : Cats are smarter than dogssearchObj.group(1) : CatssearchObj.group(2) : smarter(0, 3)(11, 14)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中面向对象比较简单的内部函数]]></title>
    <url>%2F2018%2F08%2F06%2FPython%E4%B8%AD%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%AF%94%E8%BE%83%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E9%83%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[比较简单的内部函数代码部分1234567891011121314151617181920212223class Cat: def __init__(self, new_name): self.name = new_name # 定义一个私有属性 self.__age = 18 print("&#123;&#125;来了".format(self.name)) def __del__(self): print("%s 我去了" % self.name) def __str__(self): # 必须返回一个字符串 # str方法定制变量输出信息，一般用来自定义内容 return "我是小猫&#123;&#125;".format(self.name) # 如果定义为__secret则为私有方法 def secret(self): print("&#123;&#125;的年龄是&#123;&#125;".format(self.name,self.__age))tom = Cat("Tom")tom.secret()print(tom) 运行结果1234Tom来了Tom的年龄是18我是小猫TomTom 我去了]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中对列表和元组的切片操作]]></title>
    <url>%2F2018%2F07%2F28%2Fpython%E4%B8%AD%E5%AF%B9%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84%E7%9A%84%E5%88%87%E7%89%87%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[python中对列表和元组的切片操作代码123456789# 切片方法用于列表、元组,切片方法不能用于字典list_tmp = [0, 1, 2, 3, 4]tuple_tmp = (4, 3, 2, 1, 0)# 列表输出print([0, 1, 2, 3, 4][1:3])print(list_tmp[1:3])# 元组输出print((4, 3, 2, 1, 0)[1:3])print(tuple_tmp[1:3]) 运行结果1234[1, 2][1, 2](3, 2)(3, 2)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中字符串的一些方法回顾(切片回顾)]]></title>
    <url>%2F2018%2F07%2F26%2Fpython%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%E5%9B%9E%E9%A1%BE(%E5%88%87%E7%89%87%E5%9B%9E%E9%A1%BE)%2F</url>
    <content type="text"><![CDATA[python中字符串的一些方法回顾(切片回顾)代码123456789101112131415161718192021222324# 字符串的切片 字符串[开始索引:结束索引:步长]# 如果使用倒序索引的方法，那么最后一位元素是以-1开始，倒数第二位是-2# 切片方法适用于字符串、列表、元组num_str = "0123456789"# 截取2-5的字符串print(num_str[2:6])# 截取2-末尾的字符串print(num_str[2:])# 从起始位置截取到5位置的字符串 num_str[0:6]等价print(num_str[:6])# 生成切片的副本print(num_str[:])# 从开始位置开始，每隔一个字符截取字符串print(num_str[::2])# 从索引1开始，每隔一个取一个print(num_str[1::2])# 截取从2到(末尾-1)的字符串print(num_str[2:-1])# 截取字符串末尾两个字符print(num_str[-2:])# 字符串的逆序 num_str[::-1]等价print(num_str[-1::-1]) 运行结果123456789&gt;&gt;&gt;2345&gt;&gt;&gt;23456789&gt;&gt;&gt;012345&gt;&gt;&gt;0123456789&gt;&gt;&gt;02468&gt;&gt;&gt;13579&gt;&gt;&gt;2345678&gt;&gt;&gt;89&gt;&gt;&gt;9876543210]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中字符串的一些方法回顾(拆分与合并)]]></title>
    <url>%2F2018%2F07%2F26%2Fpython%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%E5%9B%9E%E9%A1%BE(%E6%8B%86%E5%88%86%E4%B8%8E%E5%90%88%E5%B9%B6)%2F</url>
    <content type="text"><![CDATA[python中字符串的一些方法回顾(拆分与合并)字符串中split函数和join函数的使用 代码123456789101112131415# 假设：以下内容是从网络上抓取的# 要求：# 1、将字符串中的空白字符全部去掉# 2、再使用" "作为分隔符，拼接成一个整齐的字符串poem_str = "登鹤鹊楼\t 王之涣 \t 白日依山尽 \t\n 黄河入海流 \t\t 欲穷千里目\t\t更上一层楼"print(poem_str)# 1、拆分字符串 split方法会返回列表poem_list = poem_str.split()print(poem_list)# 2、合并字符串result = " ".join(poem_list)print(result) 运行结果1234567原始字符串： 登鹤鹊楼 王之涣 白日依山尽 黄河入海流 欲穷千里目 更上一层楼拆分字符串后： ['登鹤鹊楼', '王之涣', '白日依山尽', '黄河入海流', '欲穷千里目', '更上一层楼']合并字符串后: 登鹤鹊楼 王之涣 白日依山尽 黄河入海流 欲穷千里目 更上一层楼]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中字符串的一些方法回顾(文本对齐、去除空白)]]></title>
    <url>%2F2018%2F07%2F26%2Fpython%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%E5%9B%9E%E9%A1%BE(%E6%96%87%E6%9C%AC%E5%AF%B9%E9%BD%90%E3%80%81%E5%8E%BB%E9%99%A4%E7%A9%BA%E7%99%BD)%2F</url>
    <content type="text"><![CDATA[python中字符串的一些方法回顾(文本对齐、去除空白)文本对齐的方法，以及用strip函数去除字符串的中空白字符 代码1234567891011121314151617181920# 假设：以下内容是从网络上抓取下来的# 要求：顺序并且居中对齐输出一下内容poem = ["\t\n登鹤鹊楼", "王之涣", "白日依山尽\t\n", "黄河入海流", "欲穷千里目", "更上一层楼"]for poem_str in poem: # 先使用strip方法去除字符串中的空白字符 # 居中对齐 ''' Python center() 返回一个原字符串居中,并使用空格填充至长度 width 的新字符串。默认填充字符为空格。 ''' print("|%s|" % poem_str.strip().center(10, " ")) # 向左对齐 # print("|%s|" % poem_str.ljust(10, " ")) # 向右对齐 # print("|%s|" % poem_str.rjust(10, " ")) 运行结果123456| 登鹤鹊楼 || 王之涣 || 白日依山尽 || 黄河入海流 || 欲穷千里目 || 更上一层楼 |]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中完整for循环的实际运用]]></title>
    <url>%2F2018%2F07%2F26%2Fpython%E4%B8%AD%E5%AE%8C%E6%95%B4for%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[python中完整for循环的实际运用代码1234567891011121314151617181920# 完整的for循环的实际应用 for...else结构students = [ &#123;"name": "xx"&#125;, &#123;"name": "yy"&#125;]# 在学院列表中搜索指定的姓名find_name = "SS"for i in students: print(i) if i["name"] == find_name: print("找到了 &#123;&#125;".format(find_name)) # 如果已经找到，应该直接退出循环，而不再遍历后续的元素 # 如果把这个else写在if语句之后的话，每次没有找到就要输出一次，这是不对的！ breakelse: print("没有找到&#123;&#125;".format(find_name))print("循环结束") 运行结果1234&#123;&apos;name&apos;: &apos;xx&apos;&#125;&#123;&apos;name&apos;: &apos;yy&apos;&#125;没有找到SS循环结束]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中字符串的一些方法回顾]]></title>
    <url>%2F2018%2F07%2F25%2Fpython%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%E5%9B%9E%E9%A1%BE%2F</url>
    <content type="text"><![CDATA[python中字符串的一些方法回顾代码12345678910111213141516171819202122232425hello_str = "hello world"# 1、统计字符串长度print(len(hello_str))# 2、统计某一个小字符串出现的次数print(hello_str.count("llo"))# 3、某一个子字符串出现的位置print(hello_str.index("llo"))# 4、输出数学的平方num_str = "\u00b2"print(num_str)# 5、判断是否以指定字符串开始print(hello_str.startswith("hello"))# 6、判断是否以指定字符串结束print(hello_str.endswith("world"))# 7、查找指定字符串# 在index方法中，如果指定的字符串不存在，会直接报错# 在find方法中，如果指定的字符串不存在，会返回-1print(hello_str.find("llo"))print(hello_str.find("CCC"))# 8、替换字符串# replace方法执行完成之后会返回一个新的字符串，但是不会修改原有字符串的内容hh = hello_str.replace("world", "python")print(hh)print(hello_str) 运行结果123456789101112²TrueTrue2-1hello pythonhello world]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[list(列表)、tuple（元组）、dict（字典）的回顾]]></title>
    <url>%2F2018%2F07%2F25%2Flist(%E5%88%97%E8%A1%A8)%E3%80%81tuple%EF%BC%88%E5%85%83%E7%BB%84%EF%BC%89%E3%80%81dict%EF%BC%88%E5%AD%97%E5%85%B8%EF%BC%89%E7%9A%84%E5%9B%9E%E9%A1%BE%2F</url>
    <content type="text"><![CDATA[list(列表)、tuple（元组）、dict（字典）的回顾代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263list1 = [5, 6, 87, 671, 3, 54, 67, 0, 1, -6, -7]# 升序排序list1.sort()print(list1)# 降序排序list1.sort(reverse=True)print(list1)# 列表和元组之间相互转换print(type(list1))# 1、列表转换成元组num_tuple = tuple(list1)print(type(num_tuple))# 2 、元组转换成列表num2_list = list(num_tuple)print(type(num2_list))# 字典的使用# 1、取值dict_test = &#123;"name": "xxx"&#125;print(dict_test["name"])# 2、增加/修改dict_test["age"] = 18 # 增加dict_test["name"] = "yyy" # 修改print(dict_test)# 3、删除dict_test.pop("name")print(dict_test)# 4、统计键值对的数量print(len(dict_test))# 5、合并字典# 如果被合并的字典中包含已经存在的键值对，会覆盖原有的键值对temp_dict = &#123;"height": 123, "age": 20&#125;dict_test.update(temp_dict)print(dict_test)# 6、清空字典dict_test.clear()print(dict_test)# 7、迭代遍历字典# 变量k是每次循环中，获取到的键值对的值new_dict = &#123;"name": "xxx", "age": 20, "height": 200&#125;for k in new_dict: print("&#123;&#125; - &#123;&#125;".format(k, new_dict[k]))# 8、列表中保存多个字典,并用for循环迭代输出list2 = [ &#123;"name": "qqq", "email": "163", "phone": 119&#125;, &#123;"name": "sss", "email": "cc", "phone": 110&#125;]for i in list2: print(i) 运行结果12345678910111213141516[-7, -6, 0, 1, 3, 5, 6, 54, 67, 87, 671][671, 87, 67, 54, 6, 5, 3, 1, 0, -6, -7]&lt;class &apos;list&apos;&gt;&lt;class &apos;tuple&apos;&gt;&lt;class &apos;list&apos;&gt;xxx&#123;&apos;age&apos;: 18, &apos;name&apos;: &apos;yyy&apos;&#125;&#123;&apos;age&apos;: 18&#125;1&#123;&apos;age&apos;: 20, &apos;height&apos;: 123&#125;&#123;&#125;age - 20name - xxxheight - 200&#123;&apos;phone&apos;: 119, &apos;name&apos;: &apos;qqq&apos;, &apos;email&apos;: &apos;163&apos;&#125;&#123;&apos;phone&apos;: 110, &apos;name&apos;: &apos;sss&apos;, &apos;email&apos;: &apos;cc&apos;&#125; 总结总结： list使用的是方括号，类似与数组结构，tuple元组使用的是圆括号，跟list类似但是数据不能进行修改，所以应用的场景基本上用在需要数据存储，或者是需要保证数据安全无法修改的情况，字典用的是大括号，是key-value结构的, 操作数据的时候，是操作key，而不是索引。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打印九九乘法表]]></title>
    <url>%2F2018%2F07%2F24%2F%E6%89%93%E5%8D%B0%E4%B9%9D%E4%B9%9D%E4%B9%98%E6%B3%95%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[打印九九乘法表主要是练习python下的不同输出方式 代码1234567891011121314151617181920212223242526# 用for循环打印九九乘法表for i in range(1, 10): for j in range(1, 10): # 这里例举四种不同方式的打印方法 # 1、 # print("&#123;0&#125;*&#123;1&#125;=&#123;2&#125;".format(i, j, i * j), end='\t') # 2 、 # print("%d*%d=%2d" % (i, j, i * j), end='\t') # 3、 # print(i, "x", j, "=", i * j, "\t", end="") # 4、 print("&#123;&#125;*&#123;&#125;=&#123;&#125;".format(i, j, i * j), end='\t') if i == j: print("") break# 用while循环打印九九乘法表row = 1while row &lt;= 9: col = 1 while col &lt;= row: print("%d*%d=%2d" % (row, col, row * col), end='\t') col += 1 print("") row += 1 运行结果1234567891011121314151617181*1=1 2*1=2 2*2=4 3*1=3 3*2=6 3*3=9 4*1=4 4*2=8 4*3=12 4*4=16 5*1=5 5*2=10 5*3=15 5*4=20 5*5=25 6*1=6 6*2=12 6*3=18 6*4=24 6*5=30 6*6=36 7*1=7 7*2=14 7*3=21 7*4=28 7*5=35 7*6=42 7*7=49 8*1=8 8*2=16 8*3=24 8*4=32 8*5=40 8*6=48 8*7=56 8*8=64 9*1=9 9*2=18 9*3=27 9*4=36 9*5=45 9*6=54 9*7=63 9*8=72 9*9=81 1*1= 1 2*1= 2 2*2= 4 3*1= 3 3*2= 6 3*3= 9 4*1= 4 4*2= 8 4*3=12 4*4=16 5*1= 5 5*2=10 5*3=15 5*4=20 5*5=25 6*1= 6 6*2=12 6*3=18 6*4=24 6*5=30 6*6=36 7*1= 7 7*2=14 7*3=21 7*4=28 7*5=35 7*6=42 7*7=49 8*1= 8 8*2=16 8*3=24 8*4=32 8*5=40 8*6=48 8*7=56 8*8=64 9*1= 9 9*2=18 9*3=27 9*4=36 9*5=45 9*6=54 9*7=63 9*8=72 9*9=81]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打印直角三角形]]></title>
    <url>%2F2018%2F07%2F24%2F%E6%89%93%E5%8D%B0%E7%9B%B4%E8%A7%92%E4%B8%89%E8%A7%92%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[打印直角三角形做个对比 代码123456789101112# 嵌套循环版本打印直角三角形row = 1while row &lt;= 5: col = 1 while col &lt;= row: print("*", end=' ') col += 1 print() row += 1# python版本打印直角三角形for i in range(1, 6): print('* ' * i) 运行结果两者均为 12345* * * * * * * * * * * * * * *]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰器]]></title>
    <url>%2F2018%2F07%2F24%2F%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[装饰器装饰器（Decorators）是应用包装函数的快捷方式。这有助于将某一功能与一些代码一遍又一遍地“包装”。举个例子，我为自己创建了一个 retry 装饰器，这样我可以将其运用到任何函数之中，如果在一次运行中抛出了任何错误，它就会尝试重新运行，直到最大次数 5 次，并且每次运行期间都会有一定的延迟。这对于你在对一台远程计算机进行网络调用的情况十分有用： 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445# 从time模块引入sleep函数from time import sleepfrom functools import wrapsimport logginglogging.basicConfig()log = logging.getLogger("retry")def retry(f): @wraps(f) def wrapped_f(*args, **kwargs): MAX_ATTEMPTS = 5 for attempt in range(1, MAX_ATTEMPTS + 1): try: return f(*args, **kwargs) except: log.exception("Attempt %s %s failed : %s", attempt, MAX_ATTEMPTS, (args, kwargs)) sleep(10 * attempt) log.critical("All %s attempts failed : %s", MAX_ATTEMPTS, (args, kwargs)) return wrapped_fcounter = 0@retrydef save_to_database(arg): print("Write to a database or make a network call or etc.") print("This will be automatically retried if exception is thrown.") global counter counter += 1 # 这将在第一次调用时抛出异常 # 在第二次运行时正常工作（也就是重试） if counter &lt; 2: raise ValueError(arg)# 让你写的脚本模块既可以导入到别的模块中用，另外该模块自己也可执行。if __name__ == '__main__': save_to_database("Some bad value") 运行结果1234567891011ERROR:retry:Attempt 1 5 failed : (('Some bad value',), &#123;&#125;)Traceback (most recent call last): File "E:/PythonProject/more/more_decorators.py", line 16, in wrapped_f return f(*args, **kwargs) File "E:/PythonProject/more/more_decorators.py", line 40, in save_to_database raise ValueError(arg)ValueError: Some bad valueWrite to a database or make a network call or etc.This will be automatically retried if exception is thrown.Write to a database or make a network call or etc.This will be automatically retried if exception is thrown.]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[assert语句的运用]]></title>
    <url>%2F2018%2F07%2F24%2Fassert%E8%AF%AD%E5%8F%A5%E7%9A%84%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[assert语句的运用代码123456# assert语句# pop() 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值。mylist = ['item']assert len(mylist) &gt;= 1print(mylist.pop())assert len(mylist) &gt;= 1 运行结果12345itemTraceback (most recent call last): File "E:/PythonProject/more/more_assert.py", line 6, in &lt;module&gt; assert len(mylist) &gt;= 1AssertionError]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在函数中接受元组与字典]]></title>
    <url>%2F2018%2F07%2F24%2F%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E6%8E%A5%E5%8F%97%E5%85%83%E7%BB%84%E4%B8%8E%E5%AD%97%E5%85%B8%2F</url>
    <content type="text"><![CDATA[在函数中接受元组与字典 有一种特殊方法，即分别使用 或 * 作为元组或字典的前缀，来使它们作为一个参数为函数所接收。当函数需要一个可变数量的实参时，这将非常有用。 代码12345678910111213141516# 当args变量前面添加了一个*时，函数的所有其他的参数都将传递到args中，并作为一个元组储存# 如果采用的是 ** 前缀，则额外的参数将被视为字典的键值—值配对。def powersum(power, *args): '''Return the sum of each argument raised to the specified power.''' total = 0 # 在for循环中，i每次获取的是args的值，也就是说初值由args而定 for i in args: total += pow(i, power) return total# 这里可以debug一下看下i的变化，在这里一开始的时候power=2，*args=（3，4）# i在初始时为3print(powersum(2, 3, 4))# 这里i初始时为10print(powersum(2, 10)) 运行结果 25100]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[列表推导]]></title>
    <url>%2F2018%2F07%2F24%2F%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[列表推导列表推导（List Comprehension）用于从一份现有的列表中得到一份新列表。想象一下，现在你已经有了一份数字列表，你想得到一个相应的列表，其中的数字在大于 2 的情况下将乘以2。列表推导就是这类情况的理想选择。 代码1234567891011121314151617# 列表推导'''程序理解：当满足了某些条件时（ if i &gt; 2 ），我们进行指定的操作（ 2*i ），以此来获得一份新的列表。要注意到原始列表依旧保持不变。'''listone = [2, 3, 4]listtwo = [2 * i for i in listone if i &gt; 2]print(listtwo)'''列表推导的优点在于，当我们使用循环来处理列表中的每个元素并将其存储到新的列表中时它能够减少代码量''' 运行结果 [6, 8]]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的lambda函数]]></title>
    <url>%2F2018%2F07%2F24%2Fpython%E4%B8%AD%E7%9A%84lambda%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[python中的lambda函数lambda函数相当于定义了一个匿名的函数，减少了代码量 代码1234567891011121314151617181920212223242526272829303132333435# Lambda表格 也是lambda函数points = [&#123;'x': 2, 'y': 3&#125;, &#123;'x': 4, 'y': 1&#125;]points.sort(key=lambda i: i['y'])print(points)'''要注意到一个 list 的 sort 方法可以获得一个 key 参数，用以决定列表的排序方式（通常我们只知道升序与降序）。在我们的案例中，我们希望进行一次自定义排序，为此我们需要编写一个函数，但是又不是为函数编写一个独立的 def 块，只在这一个地方使用，因此我们使用 Lambda 表达式来创建一个新函数。'''# lambda函数的其他使用方法add = lambda x, y: x + yprint(add(1, 2)) # 结果为3# 需求：将列表中的元素按照绝对值大小进行升序排列list1 = [3, 5, -4, -1, 0, -2, -6]print(sorted(list1, key=lambda x: abs(x)))'''等价于def get_abs(x): return abs(x)list1.sort(key=get_abs)print(list1)或者def get_abs(x): return abs(x) print(sorted(list1, key=get_abs))''' 运行结果123[&#123;&apos;y&apos;: 1, &apos;x&apos;: 4&#125;, &#123;&apos;y&apos;: 3, &apos;x&apos;: 2&#125;]3[0, -1, -2, 3, -4, 5, -6]]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的__name__ = '__main__' 的作用]]></title>
    <url>%2F2018%2F07%2F24%2Fpython%E7%9A%84__name__-%3D-__main__%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[python的name = ‘main‘ 的作用12345678__name__ = '__main__' 的作用先写一个模块：#module.pydef main(): print "we are in %s"%__name__if __name__ == '__main__': main() 我们经常看到想上面代码底下的代码，其主要的意义在于： 让你写的脚本即可以导入别的模块中用，另外该模块自己也可以执行这个函数定义了一个main函数，我们执行一下该py文件发现结果是打印出”we are in main“,说明我们的if语句中的内容被执行了，调用了main()： 但是如果我们从另我一个模块导入该模块，并调用一次main()函数会是怎样的结果呢？ 其执行的结果是：we are in module 但是没有显示 1”we are in __main__“ ,也就是说模块 1__name__ = &apos;__main__&apos; 下面的函数没有执行。 这样既可以让“模块”文件运行，也可以被其他模块引入，而且不会执行函数2次。这才是关键。 总结12345678如果我们是直接执行某个.py文件的时候，该文件中那么”__name__ == '__main__'“是True,但是我们如果从另外一个.py文件通过import导入该文件的时候，这时__name__的值就是我们这个py文件的名字而不是__main__。这个功能还有一个用处：调试代码的时候，在”if __name__ == '__main__'“中加入一些我们的调试代码，我们可以让外部模块调用的时候不执行我们的调试代码，但是如果我们想排查问题的时候，直接执行该模块文件，调试代码能够正常运行！]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多种方法快速交换两个变量的值]]></title>
    <url>%2F2018%2F07%2F24%2F%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%B3%95%E5%BF%AB%E9%80%9F%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC%2F</url>
    <content type="text"><![CDATA[使用多种方法快速交换两个变量的值 1、利用元组的快速交换变量值 2、引入新的变量来交换 3、使用加减法交换变量值 4、利用元组从一个函数中返回两个不同的值 代码12345678910111213141516171819202122232425# 1. 利用元组的快速交换变量值a = 5b = 8a, b = b, aprint(a, b)# 2. 引入新的变量来交换c = bb = aa = cprint(a, b)# 3. 使用加减法交换变量值a = a + bb = a - ba = a - bprint(a, b)# 4. 利用元组从一个函数中返回两个不同的值def get_error_details(): return (2, 'details')errnum, errstr = get_error_details()print(errnum)print(errstr) 运行结果123458 55 88 52details]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python日志模块]]></title>
    <url>%2F2018%2F07%2F23%2Fpython%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[日志模块的应用代码123456789101112131415161718192021222324252627# 日志模块import osimport platformimport logging# os.getenv()获取一个环境变量，如果没有返回none# os.path.join()： 将多个路径组合后返回if platform.platform().startswith('Windows'): logging_file = os.path.join(os.getenv('HOMEDRIVE'), os.getenv('HOMEPATH'), 'test.log')else: logging_file = os.path.join(os.getenv('HOME'), 'test.log')print("Logging to", logging_file)logging.basicConfig( level=logging.DEBUG, format='%(asctime)s: %(levelname)s :%(message)s', filename=logging_file, filemode='w',)# 日志文件将存储在电脑上logging.debug("Start of the program")logging.info("Doing something")logging.warning("Dying now") 运行结果12345Logging to C:\Users\dylink\test.log电脑查看该目录文件为2018-07-23 20:03:55,441: DEBUG :Start of the program2018-07-23 20:03:55,441: INFO :Doing something2018-07-23 20:03:55,441: WARNING :Dying now]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户自己引发的异常处理]]></title>
    <url>%2F2018%2F07%2F23%2F%E7%94%A8%E6%88%B7%E8%87%AA%E5%B7%B1%E5%BC%95%E5%8F%91%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[由用户自行定义的异常类处理代码12345678910111213141516171819202122232425# encoding = UTF-8# 用户自己引发异常class ShortInputException(Exception): '''一个由用户定义的异常类''' def __init__(self, length, atleast): Exception.__init__(self) self.length = length self.atleast = atleasttry: text = input('Enter someting --&gt;') if len(text) &lt; 3: raise ShortInputException(len(text), 3) # 其他工作能够在此处正常运行except EOFError: print('Why did you do an EOF on me?')except ShortInputException as ex: print(('ShortInputException: The input was ' + '&#123;0&#125; long,expected at least &#123;1&#125;') .format(ex.length, ex.atleast))else: print('No exception was raised.') 运行结果 1.如果输入超过了3位数，截获错误 12Enter someting --&gt;88888No exception was raised. 2.如果输入没有超过3位数 12Enter someting --&gt;12ShortInputException: The input was 2 long,expected at least 3]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[with open异常处理]]></title>
    <url>%2F2018%2F07%2F23%2Fwith-open%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[with open异常处理代码123456with open("poem.txt") as f: for line in f: print(line, end='')''' with open能够将之前的try..finally最后执行的关闭文件的操作，交给with open自动完成''' 运行结果 poem.txt里面的内容为：12165456478 1&gt;&gt;&gt;12165456478]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单的异常处理]]></title>
    <url>%2F2018%2F07%2F23%2F%E7%AE%80%E5%8D%95%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[简单的异常处理代码12345678try: text = input('Enter someting --&gt;')except EOFError: # 按ctrl+D print('Why did you do an EOF on me?')except KeyboardInterrupt: # 按ctrl+C print('You cancelled the operation.')else: print('You enterd &#123;&#125;'.format(text)) 运行结果12Enter someting --&gt;^DWhy did you do an EOF on me?]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[finally异常处理]]></title>
    <url>%2F2018%2F07%2F23%2Ffinally%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[finally异常处理代码123456789101112131415161718192021222324import sysimport timef = Nonetry: f = open("poem.txt") # 我们常用的文件阅读风格 while True: line = f.readline() if len(line) == 0: break print(line, end='') sys.stdout.flush() print("Press ctrl+c now") # 为了确保它能运行一段时间 time.sleep(2) # time.sleep 函数任意在每打印一行后插入两秒休眠except IOError: print("Could not find file poem.txt")except KeyboardInterrupt: print("!! You cancelled the reading from the file.")finally: # 始终执行 if f: f.close() print("(Cleaning up: Closed the file)") 运行结果1212165456478Press ctrl+c now(Cleaning up: Closed the file)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在打开文件的同时规定编码]]></title>
    <url>%2F2018%2F07%2F23%2F%E5%9C%A8%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E7%9A%84%E5%90%8C%E6%97%B6%E8%A7%84%E5%AE%9A%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[规定编码代码123456789101112131415161718# 在打开文件的同时规定编码'''如果你正在使用 Python 2，我们又希望能够读写其它非英语语言，我们需要使用unicode 类型，它全都以字母 u 开头，例如 u"hello world" 。&gt;&gt;&gt; u"hello world"'hello world''''# encoding = utf-8import iof = io.open("abc.txt", "wt", encoding="utf-8")f.write(u"Imagine non-English language here")f.close()text = io.open("abc.txt", encoding="utf-8").read()print(text) 运行结果 Imagine non-English language here]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的pickle模块]]></title>
    <url>%2F2018%2F07%2F23%2Fpython%E7%9A%84pickle%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[python的pickle模块Python 提供了一个叫作 Pickle 的标准模块，通过它你可以将任何纯 Python 对象存储到一个文件中，并在稍后将其取回。这叫作持久地（Persistently）存储对象。 代码123456789101112131415161718192021222324252627282930313233'''在Pickle模块中有2个常用的函数方法，一个叫做dump()，另一个叫做load()。pickle.dump(对象, 文件，[使用协议])load()方法的作用正好与上面的dump()方法相反，上面是序列化数据，这个方法作用是反序列化。pickle.load(文件)目的主要是为了将一些数据，如字符串、列表、字典等长期的以文件形式保存下来'''import pickle# The name of the file where we will store the objectshoplistfile = 'shoplist.data'# The list of things to buyshoplist = ['apple', 'mango', 'carrot']# Write to the filef = open(shoplistfile, 'wb')# Dump the object to a filepickle.dump(shoplist, f)f.close()# Destroy the shoplist variabledel shoplist# Read back from the storagef = open(shoplistfile, 'rb')# Load the object from the filestoredlist = pickle.load(f)print(storedlist) 运行结果1['apple', 'mango', 'carrot']]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件操作]]></title>
    <url>%2F2018%2F07%2F23%2F%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[文件操作代码12345678910111213141516171819202122232425262728poem = '''Programming is funWhen the work is doneif you wanna make your work also fun: use Python!'''# 打开文件以编辑（'w'riting）f = open('poem.txt', 'w')# 向文件中编写文本f.write(poem)# 关闭文件f.close()# 如果没有特别指定# 将假定启用默认的阅读（'r'ead）模式f = open('poem.txt')while True: line = f.readline() # 零长度指示 EOF , 用来判断文档结尾 if len(line) == 0: break # 每行（'line'）的末尾 # 都已经有了换行符 # 因为它是从一个文件中进行读取的 print(line, end=' ')# 关闭文件f.close() 运行结果1234Programming is funWhen the work is doneif you wanna make your work also fun: use Python!]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[输入输出——回文字串的判断（加强版）]]></title>
    <url>%2F2018%2F07%2F23%2F%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E2%80%94%E2%80%94%E5%9B%9E%E6%96%87%E5%AD%97%E4%B8%B2%E7%9A%84%E5%88%A4%E6%96%AD%EF%BC%88%E5%8A%A0%E5%BC%BA%E7%89%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[输入输出——回文字串的判断（加强版）123456789101112131415161718192021222324252627forbindden_word = (' ', ',', ';', '.', '!', '//', '?')# 样例字符串Rise to vote,sir. 共17长度def ignore_word(text): # 去除忽略的特殊字符 strdemo = list(text.lower()) count = 0 print('长度为:', len(strdemo)) for i in list(range(len(strdemo))): # 遍历从0-16，共17长度 ，debug一下就懂了 if strdemo[i - count] in forbindden_word: del strdemo[i - count] # 删除特殊字符 count += 1 return strdemodef reverse(text): return text[::-1]def is_reverse(text): # 判断是否为回文 return text == reverse(text)something = input('随便输入点什么:')if is_reverse(ignore_word(something)): print('恭喜！他是回文文本')else: print('这好像不是回文文本哦') 运行结果123随便输入点什么:Rise to vote,sir.长度为: 17恭喜！他是回文文本]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[输入输出——简单的回文判断]]></title>
    <url>%2F2018%2F07%2F23%2F%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E7%9A%84%E5%9B%9E%E6%96%87%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[输入输出——简单的回文判断代码123456789101112131415161718192021'''可以通过使用 seq[a:b] 来从位置 a 开始到位置 b 结束来对序列进行切片 。我们同样可以提供第三个参数来确定切片的步长（Step）。默认的步长为 1 ，它会返回一份连续的文本。如果给定一个负数步长，如 -1 ，将返回翻转过的文本。'''def reverse(text): return text[::-1] # 使用切片功能返回倒序def is_palindrome(text): return text == reverse(text) # 如果正序和倒序相等的话，就是回文something = input("Enter text: ")if is_palindrome(something): print("Yes,it is a palidrome") # 是回文else: print("No, it is not a palindrome") # 不是回文 运行结果 如果是回文字串 Enter text: 1221Yes,it is a palidrome 如果不是回文字串 Enter text: 11111555No, it is not a palindrome]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承的运用]]></title>
    <url>%2F2018%2F07%2F23%2F%E7%BB%A7%E6%89%BF%E7%9A%84%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[继承的运用代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 继承的运用# coding = UTF-8class SchoolMember: '''代表学校里的成员。''' def __init__(self, name, age): self.name = name self.age = age print('(Initialized SchoolMember: &#123;&#125;)'.format((self.name))) def tell(self): '''告诉我有关我的细节。''' print('Name:"&#123;&#125;" Age:"&#123;&#125;"'.format(self.name, self.age), end=" ")class Teacher(SchoolMember): '''代表一位老师。''' def __init__(self, name, age, salary): SchoolMember.__init__(self, name, age) self.salary = salary print('(Initialized Teacher: &#123;&#125;)'.format(self.name)) def tell(self): SchoolMember.tell(self) print('Salary: "&#123;:d&#125;"'.format(self.salary))class Student(SchoolMember): '''代表一位学生。''' def __init__(self, name, age, marks): SchoolMember.__init__(self, name, age) self.marks = marks print('(Initialized Student: &#123;&#125;)'.format(self.name)) def tell(self): SchoolMember.tell(self) print('Marks: "&#123;:d&#125;"'.format(self.marks))t = Teacher('Mrs. Shrividya', 40, 30000)s = Student('Swaroop', 25, 75)print()members = [t, s]for member in members: # 对全体师生工作 member.tell() 运行结果 1234567(Initialized SchoolMember: Mrs. Shrividya)(Initialized Teacher: Mrs. Shrividya)(Initialized SchoolMember: Swaroop)(Initialized Student: Swaroop)Name:"Mrs. Shrividya" Age:"40" Salary: "30000"Name:"Swaroop" Age:"25" Marks: "75"]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类变量与对象变量]]></title>
    <url>%2F2018%2F07%2F23%2F%E7%B1%BB%E5%8F%98%E9%87%8F%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[类变量与对象变量代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# coding=UTF-8,类变量与对象变量class Robot: """表示有一个带有名字的机器人。""" # 一个类变量，用来计数机器人的数量 population = 0 # 这是一个类变量，属于Robot类 def __init__(self, name): # name变量属于一个对象（通过self分配），因此它是一个对象变量 """初始化数据""" self.name = name print("(Initializing &#123;&#125;)".format(self.name)) # 当有人被创建时，机器人会增加人口数量 ''' 除了 Robot.popluation ，我们还可以使用 self.__class__.population ，因为每个对象都通过 self.__class__ 属性来引用它的类。 ''' Robot.population += 1 def die(self): """我挂了。""" print("&#123;&#125; is being destroyed!".format(self.name)) Robot.population -= 1 if Robot.population == 0: print("&#123;&#125; was the last one.".format(self.name)) else: print("There are still &#123;:d&#125; robots working.".format(Robot.population)) def say_hi(self): """来自机器人的诚挚问候 没问题，你做得到""" print("Greetings , my masters call me &#123;&#125;".format(self.name)) ''' classmethod 修饰符对应的函数不需要实例化，不需要 self 参数， 但第一个参数需要是表示自身类的 cls 参数，可以来调用类的属性，类的方法，实例化对象等。 ''' # how_many实际上是一个属于类而非属于对象的方法 # classmethod(类方法)或是一个staticmethod(静态方法) @classmethod # 装饰器，等价于how_many = classmethod(how_many) def how_many(cls): """打印出当前的人口数量""" print("We have &#123;:d&#125; robots.".format(cls.population))droid1 = Robot("R2-D2")droid1.say_hi()Robot.how_many()droid2 = Robot("C-3PO")droid2.say_hi()Robot.how_many()print("\nRobots can do some work here.\n")print("Robots have finished their work. So let's destroy them.")droid1.die()droid2.die()Robot.how_many() 运行结果 123456789101112131415(Initializing R2-D2)Greetings , my masters call me R2-D2We have 1 robots.(Initializing C-3PO)Greetings , my masters call me C-3POWe have 2 robots.Robots can do some work here.Robots have finished their work. So let's destroy them.R2-D2 is being destroyed!There are still 1 robots working.C-3PO is being destroyed!C-3PO was the last one.We have 0 robots.]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python对象的实例化]]></title>
    <url>%2F2018%2F07%2F23%2Fpython%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[python对象的实例化代码1234567891011121314'''__init__ 方法会在类的对象被实例化（Instantiated）时立即运行。这一方法可以对任何你想进行操作的目标对象进行初始化（Initialization）操作。'''class Person: def __init__(self, name): self.name = name def say_hi(self): print('Hello,my name is', self.name)p = Person('Swaroop')p.say_hi() 运行结果 Hello,my name is Swaroop]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用python进行文件的自动备份(第三版和第四版)]]></title>
    <url>%2F2018%2F07%2F23%2F%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD(%E7%AC%AC%E4%B8%89%E7%89%88%E5%92%8C%E7%AC%AC%E5%9B%9B%E7%89%88)%2F</url>
    <content type="text"><![CDATA[利用python进行文件的自动备份(第三版和第四版)代码12345678910111213141516171819202122232425262728293031323334353637383940414243import osimport time'''第三版和第四版差别不大整合在一起，用户注释的内容可以添加到文件名中来实现'''source = [r'E:\aaa.txt']target_dir = 'E:\\Backup\\'if not os.path.exists(target_dir): os.mkdir(target_dir)# 子目录名称today = target_dir + os.sep + time.strftime('%Y%m%d')# 将当前时间作为zio文件的文件名now = time.strftime('%H%M%S')# 添加一条来自用户的注释以创建# zip文件的文件名comment = input('Enter a comment --&gt;')# 检查是否有评论键入if len(comment) == 0: target = today + os.sep + now + '.zip'# replace函数中前面的将被替换为后面的else: target = today + os.sep + now + '_' + \ comment.replace(' ', '_') + '.zip'# 如果子目录尚不存在则创建一个if not os.path.exists(today): os.mkdir(today) print('Successfully created directory', today)zip_command = "7z a &#123;0&#125; &#123;1&#125;".format(target, ' '.join(source))# 运行备份print('Zip command is:')print(zip_command)print('Running:')if os.system(zip_command) == 0: print('Successful backup to', target)else: print('Backup FAILED') 运行结果 12345678910111213141516171819Enter a comment --&gt;This is my backupZip command is:7z a E:\Backup\\20180723\185735_This_is_my_backup.zip E:\aaa.txtRunning:7-Zip 18.05 (x64) : Copyright (c) 1999-2018 Igor Pavlov : 2018-04-30Scanning the drive:1 file, 10 bytes (1 KiB)Creating archive: E:\Backup\\20180723\185735_This_is_my_backup.zipAdd new data to archive: 1 file, 10 bytes (1 KiB)Files read from disk: 1Archive size: 158 bytes (1 KiB)Everything is OkSuccessful backup to E:\Backup\\20180723\185735_This_is_my_backup.zip]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用python进行文件的自动备份（第二版）]]></title>
    <url>%2F2018%2F07%2F23%2F%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[利用python进行文件的自动备份（第二版）代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import osimport time'''第二版是第一版的改进，启用一种更好的文件命名机制——使用时间作为文件名，存储在以当前时间为名字的文件夹中，这一文件夹则照常存储在主备份目录下。'''# 例如在 Windows 下：source = [r'E:\aaa.txt']# 在这里要注意到我们必须在字符串中使用双引号# 用以括起其中包含空格的名称。# 2. 备份文件必须存储在一个# 主备份目录中# 例如在 Windows 下：target_dir = 'E:\\Backup\\'# 要记得将这里的目录地址修改至你将使用的路径# 如果目标目录还不存在，则进行创建if not os.path.exists(target_dir): os.mkdir(target_dir) # 创建目录# 3.备份文件将打包压缩成zip文件# 4.zip压缩文件的文件名由当前日期与时间构成# 其中os.sep 表示更改操作系统中的路径分隔符today = target_dir + os.sep + time.strftime('%Y%m%d')# 将当前时间作为zip文件的文件名now = time.strftime('%H%M%S')# zip文件名称格式target = today + os.sep + now + 'zip'# 如果子目录尚不存在则创建一个if not os.path.exists(today): os.mkdir(today) print('Successfully created diectory', today)# 5.原本这里是使用zip命令，但是在windows环境下面这个是不是系统命令，所以解决方案如下：'''1.1.下载7-Zip并安装2.将安装文件中的7z.exe移至‘C:\Windows’目录下3.将程序中的 zip_command = "zip -qr '%s' %s"%(target,''.join(source))改为：zip_command = "7z a %s %s"%(target, ' '.join(source))或者是"7z a &#123;0&#125; &#123;1&#125;".format(target, ' '.join(source))'''zip_command = "7z a &#123;0&#125; &#123;1&#125;".format(target, ' '.join(source))# 运行备份print('Zip command is:')print(zip_command)print('Running:')if os.system(zip_command) == 0: print('Successful backup to', target)else: print('Backup FAILED') 运行结果123456789101112131415161718Zip command is:7z a E:\Backup\\20180723\185035zip E:\aaa.txtRunning:7-Zip 18.05 (x64) : Copyright (c) 1999-2018 Igor Pavlov : 2018-04-30Scanning the drive:1 file, 10 bytes (1 KiB)Creating archive: E:\Backup\\20180723\185035zip.7zAdd new data to archive: 1 file, 10 bytes (1 KiB)Files read from disk: 1Archive size: 136 bytes (1 KiB)Everything is OkSuccessful backup to E:\Backup\\20180723\185035zip]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用python进行文件的自动备份]]></title>
    <url>%2F2018%2F07%2F22%2F%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD%2F</url>
    <content type="text"><![CDATA[利用Python进行文件的自动备份（第一版）os.system 函数的命令，这一函数可以使命令像是从系统中运行的。也就是说，从 shell 中运行的——如果运行成功，它将返回 0 ，如果运行失败，将返回一个错误代码。 针对 Windows 用户的提示除了使用双反斜杠转义序列，你还可以使用原始字符串。例如使用 ‘C:\\Documents’ 或r’C:\Documents’ 。然而，不要使用 ‘C:\Documents’ ，因为它将被识别为你使用了一个未知的转义序列 \D 来结束路径的输入。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243import osimport time# 1. 需要备份的文件与目录将被# 指定在一个列表中。# 例如在 Windows 下：source = [r'E:\aaa.txt']# 在这里要注意到我们必须在字符串中使用双引号# 用以括起其中包含空格的名称。# 2. 备份文件必须存储在一个# 主备份目录中# 例如在 Windows 下：target_dir = 'E:\\Backup\\'# 要记得将这里的目录地址修改至你将使用的路径# 3.备份文件将打包压缩成zip文件# 4.zip压缩文件的文件名由当前日期与时间构成# 其中os.sep 表示更改操作系统中的路径分隔符target = target_dir + os.sep + \ time.strftime('%Y%m%d%H%M%S') + '.zip'# 如果目标目录还不存在，则进行创建if not os.path.exists(target_dir): os.mkdir(target_dir) # 创建目录# 5.原本这里是使用zip命令，但是在windows环境下面这个是不是系统命令，所以解决方案如下：'''1.1.下载7-Zip并安装2.将安装文件中的7z.exe移至‘C:\Windows’目录下3.将程序中的 zip_command = "zip -qr '%s' %s"%(target,''.join(source))改为：zip_command = "7z a %s %s"%(target, ' '.join(source))'''zip_command = "7z a %s %s" % (target, ' '.join(source))# 运行备份print('Zip command is:')print(zip_command)print('Running:')if os.system(zip_command) == 0: print('Successful backup to', target)else: print('Backup FAILED') 输出结果 1 file, 10 bytes (1 KiB) Creating archive: E:\Backup\\20180722160831.zip Add new data to archive: 1 file, 10 bytes (1 KiB) Files read from disk: 1 Archive size: 158 bytes (1 KiB) Everything is Ok Successful backup to E:\Backup\\20180722160831.zip]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的集合]]></title>
    <url>%2F2018%2F07%2F07%2Fpython%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[集合集合（Set）是简单对象的无序集合（Collection）。当集合中的项目存在与否比起次序或其出现次数更加重要时，我们就会使用集合。通过使用集合，你可以测试某些对象的资格或情况，检查它们是否是其它集合的子集，找到两个集合的交集，等等。 代码12345678910111213# 集合 判断子集bri = set(['brazil', 'russia', 'india'])if 'india' in bri: print('True')if 'usa' in bri: print('False')bric = bri.copy()bric.add('china')print(bric.issuperset(bri))bri.remove('russia')print(bri &amp; bric) 输出结果TrueTrue{‘india’, ‘brazil’}]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中字典（key-value）]]></title>
    <url>%2F2018%2F07%2F07%2Fpython%E4%B8%AD%E5%AD%97%E5%85%B8%EF%BC%88key-value%EF%BC%89%2F</url>
    <content type="text"><![CDATA[字典（key-value）字典就像一本地址簿，如果你知道了他或她的姓名，你就可以在这里找到其地址或是能够联系上对方的更多详细信息，换言之，我们将键值（Keys）（即姓名）与值（Values）（即地址等详细信息）联立到一起。在这里要注意到键值必须是唯一的，正如在现实中面对两个完全同名的人你没办法找出有关他们的正确信息。 代码123456789101112131415161718192021222324252627# 字典# "ab"是地址（Address）薄(Book)的缩写ab = &#123; 'Swaroop': 'swaroop@swaroopch.com', 'Larry': 'larry@wall.org', 'Matsumoto': 'matz@ruby-lang.org', 'Spammer': 'spammer@hptmail.com'&#125;print("Swaroop's address is", ab['Swaroop'])# 删除一对键值-值配对del ab['Spammer']print('\nThere are &#123;&#125; contacts in the address-book\n'.format(len(ab)))#我们通过使用字典的 item 方法来访问字典中的每一对键值—值配对信息，这一操作将返回一份包含元组的列表for name, address in ab.items(): print('Contact &#123;&#125; at &#123;&#125;'.format(name, address))# 添加一对键值-值配对ab['Guido'] = 'guido@python.org'if 'Guido' in ab: print("\nGuido's address is", ab['Guido'])]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的列表]]></title>
    <url>%2F2018%2F07%2F07%2Fpython%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[列表列表 是一种用于保存一系列有序项目的集合，也就是说，你可以利用列表保存一串项目的序列。想象起来也不难，你可以想象你有一张购物清单，上面列出了需要购买的商品，除开在购物清单上你可能为每件物品都单独列一行，在 Python 中你需要在它们之间多加上一个逗号。 代码123456789101112131415161718192021222324252627# 列表# This is my shopping list'''在这里要注意在调用 print 函数时我们使用 end 参数，这样就能通过一个空格来结束输出工作，而不是通常的换行。'''shoplist = ['apple', 'mango', 'carrot', 'banana']print('I have', len(shoplist), 'items to purchase')print('These item are:', end=' ')for item in shoplist: print(item, end=' ')print('\nI also have to buy rice.')shoplist.append('rice')print('My shopping list is now', shoplist)print('I will sort my list now')shoplist.sort()print('Sorted shopping list is', shoplist)print('The first item I will buy is', shoplist[0])olditem = shoplist[0]del shoplist[0]print('I bought the', olditem)print('My shopping list is now', shoplist)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的元组]]></title>
    <url>%2F2018%2F07%2F07%2Fpython%E4%B8%AD%E7%9A%84%E5%85%83%E7%BB%84%2F</url>
    <content type="text"><![CDATA[元组元组（Tuple）用于将多个对象保存到一起。你可以将它们近似地看作列表，但是元组不能提供列表类能够提供给你的广泛的功能。元组的一大特征类似于字符串，它们是不可变的，也就是说，你不能编辑或更改元组。元组是通过特别指定项目来定义的，在指定项目时，你可以给它们加上括号，并在括号内部用逗号进行分隔。元组通常用于保证某一语句或某一用户定义的函数可以安全地采用一组数值，意即元组内的数值不会改变。 代码123456789101112131415# 元组'''推荐使用括号来指明元组的开始和结束尽管括号是一个可选选项明了胜过晦涩，显式优于隐式'''zoo = ('python', 'elephant', 'penguin')print('Number of animals in the zoo is', len(zoo))new_zoo = 'monkey', 'camel', zooprint('Number of animals in the zoo is', len(new_zoo))print('All animals in new zoo are', new_zoo)print('Animals brought from old zoo are', new_zoo[2])print('Last animal brought from old zoo is', new_zoo[2][2])print('Number of animals in the new zoo is', len(new_zoo) - 1 + len(new_zoo[2]))]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的序列以及切片的解释]]></title>
    <url>%2F2018%2F07%2F07%2Fpython%E4%B8%AD%E7%9A%84%E5%BA%8F%E5%88%97%E4%BB%A5%E5%8F%8A%E5%88%87%E7%89%87%E7%9A%84%E8%A7%A3%E9%87%8A%2F</url>
    <content type="text"><![CDATA[python中的序列以及切片的解释切片：有一种切片（Slicing）运算符，它能够允许我们序列中的某段切片——也就是序列之中的一部分。 序列1234567891011121314151617181920212223242526272829303132333435# 序列 跑一下看看shoplist = ['apple', 'mango', 'carrot', 'banana']name = 'swaroop'# Indexing or 'Subscription' operation ## 索引或“下标（Subcription）”操作符 #print('Item 0 is', shoplist[0])print('Item 1 is', shoplist[1])print('Item 2 is', shoplist[2])print('Item 3 is', shoplist[3])print('Item -1 is', shoplist[-1])print('Item -2 is', shoplist[-2])print('Character 0 is', name[0])# Slicing on a list #print('Item 1 to 3 is', shoplist[1:3])print('Item 2 to end is', shoplist[2:])print('Item 1 to -1 is', shoplist[1:-1])print('Item start to end is', shoplist[:])# 从某一字符串中切片 #print('characters 1 to 3 is', name[1:3])print('characters 2 to end is', name[2:])print('characters 1 to -1 is', name[1:-1])print('characters start to end is', name[:])'''你会注意到当步长为 2 时，我们得到的是第 0、2、4…… 位项目。当步长为 3 时，我们得到的是第 0、3……位项目。'''print(shoplist[::1])print(shoplist[::2])print(shoplist[::3])print(shoplist[::-1])]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中字符串的一些基本操作]]></title>
    <url>%2F2018%2F07%2F07%2Fpython%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[python字符串的一些基本操作在这里，我们会看见一此操作中包含了好多字符串方法。 startwith 方法用于查找字符串是否以给定的字符串内容开头。 in 运算符用以检查给定的字符串是否是查询的字符串中的一部分。find 方法用于定位字符串中给定的子字符串的位置。如果找不到相应的子字符串， find会返回 -1。 str 类同样还拥有一个简洁的方法用以 联结（Join） 序列中的项目，其中字符串将会作为每一项目之间的分隔符，并以此生成并返回一串更大的字符串。 123456789101112131415# 这是一个字符串对象name = 'Swaroop'if name.startswith('Swa'): print('Yes, the string starts with "Swa"')if 'a' in name: print('Yes, it contains the string "a"')if name.find('war') != -1: print('Yes,it contains the string "war"')delimiter = '_*_'mylist = ['Brazil', 'Russia', 'India', 'China']print(delimiter.join(mylist))]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的引用和切片]]></title>
    <url>%2F2018%2F07%2F07%2Fpython%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8%E5%92%8C%E5%88%87%E7%89%87%2F</url>
    <content type="text"><![CDATA[引用和切片造成的不同影响当你创建了一个对象并将其分配给某个变量时，变量只会查阅（Refer）某个对象，并且它也不会代表对象本身。也就是说，变量名只是指向你计算机内存中存储了相应对象的那一部分。这叫作将名称绑定（Binding）给那一个对象。一般来说，你不需要去关心这个，不过由于这一引用操作困难会产生某些微妙的效果，这是需要你注意的： 123456789101112131415161718192021222324252627'''如果直接引用对象的话，对mylist操作也会影响到原本的shoplist如果想要不影响原本的，必须引用的是对象的切片，切片即为副本'''print('Simple Assignment')shoplist = ['apple', 'mango', 'carrot', 'banana']# mylist 只是指向同一对象的另一种名称mylist = shoplist# 我购买了第一项项目，所以我将其从列表中删除del shoplist[0]print('shoplist is', shoplist)print('mylist is', mylist)# 注意到 shoplist 和 mylist 二者都# 打印出了其中都没有 apple 的同样的列表，以此我们确认# 它们指向的是同一个对象print('Copy by making a full slice')# 通过生成一份完整的切片制作一份列表的副本mylist = shoplist[:]# 删除第一个项目del mylist[0]print('shoplist is', shoplist)print('mylist is', mylist)# 注意到现在两份列表已出现不同]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的Docstring]]></title>
    <url>%2F2018%2F06%2F27%2Fpython%E4%B8%AD%E7%9A%84Docstring%2F</url>
    <content type="text"><![CDATA[基本教程1234567891011121314151617181920212223242526'''文档字符串的应用该文档字符串所约定的是一串多行字符串，其中第一行以某一大写字母开始，以句号结束。第二行为空行，后跟的第三行开始是任何详细的解释说明。 在此强烈建议你在有关你所有非凡功能的文档字符串中都遵循这一约定。'''def print_max(x, y): '''Prints the maximum of two numbers.打印两个数值中的最大数。 The two values must be integers.这两个数都应该是整数 ''' # 如果可能，将其转换至整数类型 x = int(x) y = int(y) if x &gt; y: print(x, 'is maximum') else: print(y, 'is maximum')print_max(3, 5)print(print_max.__doc__)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基本教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大公约数和最小公倍数]]></title>
    <url>%2F2018%2F04%2F10%2F%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[使用的辗转相除法辗转相除法：辗转相除法是求两个自然数的最大公约数的一种方法，也叫欧几里德算法。 例如，求（319，377）： ∵ 319÷377=0（余319） ∴（319，377）=（377，319）； ∵ 377÷319=1（余58） ∴（377，319）=（319，58）； ∵ 319÷58=5（余29） ∴ （319，58）=（58，29）； ∵ 58÷29=2（余0） ∴ （58，29）= 29； ∴ （319，377）=29。 可以写成右边的格式。 用辗转相除法求几个数的最大公约数，可以先求出其中任意两个数的最大公约数，再求这个最大公约数与第三个数的最大公约数，依次求下去，直到最后一个数为止。最后所得的那个最大公约数，就是所有这些数的最大公约数。 代码 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;int main() &#123; int maxgongyue(int x,int y); int mingongbei(int num,int finax); int x,y,num; printf("请输入俩个数:\n"); scanf("%d %d",&amp;x,&amp;y); num=x*y; printf("最大公约数是:%d\n",maxgongyue(x,y)); printf("最小公倍数是:%d\n",mingongbei(num,maxgongyue(x,y))); return 0;&#125;int maxgongyue(int x,int y)&#123; int temp,yushu; if(x&lt;y) &#123; //交换成大的在前，小的在后 temp=x; x=y; y=temp; &#125; while(y!=0) &#123; //辗转相除法，如果余数不为0，则循环 yushu=x%y; //求余数 x=y; //将小的赋值给大的 y=yushu; //将余数赋值给小的 &#125;//一直除到余数为0时，这时候的x就是最大公约数 return(x);&#125;int mingongbei(int num,int finax)&#123; return(num/finax);&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折半查找]]></title>
    <url>%2F2018%2F04%2F10%2F%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[折半查找定义二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列 查找过程首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。 比较次数当顺序表有n个关键字时： 查找失败时，至少比较a次关键字；查找成功时，最多比较关键字次数是b。 注意：a,b,n均为正整数。 算法复杂度折半查找法也称为二分查找法，它充分利用了元素间的次序关系，采用分治策略，可在最坏的情况下用O(log n)完成搜索任务。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;stdio.h&gt;#define N 5//折半查找算法int main() &#123; int a[N],i,j,low=0,high=N-1,mid,flag,num; printf("请输入5个数:\n"); scanf("%d",&amp;a[0]); i=1; //升序输入 while(i&lt;N) &#123; scanf("%d",&amp;a[i]); if(a[i]&gt;=a[i-1]) &#123; i++; &#125; else &#123; printf("重新输入数据:\n"); &#125; &#125; printf("\n"); for(i=0; i&lt;N; i++) &#123; printf("%5d",a[i]); &#125; printf("\n请输入你要查询的数字:\n"); scanf("%d",&amp;num); if((num&lt;a[0])||(num&gt;a[N-1])) &#123; printf("该数不在区间范围内\n"); &#125; while(low&lt;=high) &#123; mid = (low + high)/2; if(num==a[mid])&#123; flag=mid; //记录这个数的位置 printf("找到了%d,这个数在第%d号位置",num,flag+1); break; &#125; else if (num &gt; a[mid]) &#123; low = mid+1; &#125; else if (num &lt; a[mid]) &#123; high = mid - 1; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[任意行数的杨辉三角形（动态分配）]]></title>
    <url>%2F2018%2F04%2F10%2F%E4%BB%BB%E6%84%8F%E8%A1%8C%E6%95%B0%E7%9A%84%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%88%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%EF%BC%89%2F</url>
    <content type="text"><![CDATA[杨辉三角形金字塔型和直角三角形代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main() &#123; int i,j,num; int **a; printf("请输入你想打印的杨辉三角形行数:\n"); scanf("%d",&amp;num); a=(int **)malloc(num*sizeof(int *)); for (i = 0; i &lt; num; ++i) &#123; //为每列分配num个大小空间 a[i] = (int*)malloc(sizeof(int)*num); &#125; //书上分开打印// for(i=0; i&lt;num; i++) &#123;// a[i][i]=1;// a[i][0]=1;// &#125;// for(i=2; i&lt;num; i++) &#123;// for(j=1; j&lt;=i-1; j++) &#123;// a[i][j]=a[i-1][j-1]+a[i-1][j];// &#125;// &#125;// for(i=0;i&lt;num;i++)&#123;// for(j=0;j&lt;=i;j++)&#123;// printf("%4d",a[i][j]);// &#125;// printf("\n");// &#125;// printf("\n"); //优化 for(i=0; i&lt;num; i++) &#123; for(j=0; j&lt;=i; j++) &#123;// if(i==0||j==0||j==i) &#123;// a[i][j]=1;// &#125; else &#123;// a[i][j]=a[i-1][j-1]+a[i-1][j];// &#125; printf("%4d",(a[i][j])=(i==0||j==0||j==i)?1:a[i-1][j-1]+a[i-1][j]); &#125; printf("\n"); &#125;// for(i=0; i&lt;num; i++) &#123;// for(j=0; j&lt;=i; j++) &#123;// printf("%4d",a[i][j]);// &#125;// printf("\n");// &#125; for (i = 0; i &lt; num; i++) &#123; free(a[i]); &#125; free(a); printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F2018%2F04%2F10%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序概念冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。 它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名“冒泡排序”。 算法原理冒泡排序算法的运作如下：（从后往前） 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 时间复杂度冒泡排序总的平均时间复杂度为O(n2) 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243 #include&lt;stdio.h&gt; int main()&#123; void sort(int *x,int n); int i,*p,a[10]; p=a; printf("请输入10个整数:\n"); for(i=0;i&lt;10;i++)&#123; scanf("%d",p++); &#125; p=a; sort(p,10); for(p=a,i=0;i&lt;10;i++)&#123; printf("%d ",*p++); &#125; printf("\n"); return 0; &#125; //数组形式 void sort(int x[],int n)&#123; int i,j,temp; for(i=0;i&lt;n-1;i++) for(j=0;j&lt;n-1-i;j++)&#123; if(x[j]&lt;x[j+1])&#123; temp=x[j]; x[j]=x[j+1]; x[j+1]=temp; &#125; &#125; &#125; //指针形式 void sort(int *x,int n)&#123; int i,j,temp; for(i=0;i&lt;n-1;i++) for(j=0;j&lt;n-1-i;j++)&#123; if(*(x+j)&lt;*(x+j+1))&#123; //*(x+j)就是x[j] temp=*(x+j); *(x+j)=*(x+j+1); *(x+j+1)=temp; &#125; &#125; &#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[整合建立输出增删改查的链表]]></title>
    <url>%2F2018%2F04%2F08%2F%E6%95%B4%E5%90%88%E5%BB%BA%E7%AB%8B%E8%BE%93%E5%87%BA%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E7%9A%84%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[简单贴一下链表的建立等常用操作 链表定义链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define LEN sizeof(struct Student)//输入格式 1 89// 2 99// 0 0struct Student &#123; long num; float score; struct Student *next;&#125;;int n;struct Student *creat();struct Student *del(struct Student *head,long num);struct Student *insert(struct Student *head,struct Student *stu);void print(struct Student *head);int main() &#123; struct Student *head,*stu; long del_num; printf("请输入数据:\n"); head=creat(); print(head); printf("请输入要删除的数字:\n"); scanf("%ld",&amp;del_num); while(del_num!=0) &#123; //当输入的学号为0时结束循环 head=del(head,del_num); //删除结点后返回链表的头地址 print(head); //输出全部结点 printf("请输入要删除的数字:\n"); scanf("%ld",&amp;del_num); &#125; printf("请输入要添加的数据:\n"); stu=(struct Student *)malloc(LEN); //开辟一个新结点 scanf("%ld %f",&amp;stu-&gt;num,&amp;stu-&gt;score); while(stu-&gt;num!=0) &#123; //当输入的学号为0时结束循环 head=insert(head,stu); //返回链表的头地址，赋值给head print(head); //输出全部结点 printf("请输入要添加的数据:\n"); stu=(struct Student *)malloc(LEN); //开辟一个新结点 scanf("%ld %f",&amp;stu-&gt;num,&amp;stu-&gt;score); &#125; return 0;&#125;struct Student *creat(void) &#123; //返回一个指向链表头的指针 struct Student *head; struct Student *p1,*p2; n=0; p1=p2=(struct Student *)malloc(LEN);//开辟一个新的结点使p1，p2指向它 scanf("%ld %f",&amp;p1-&gt;num,&amp;p1-&gt;score);//输入第1个学生的学号和成绩 head=NULL; while(p1-&gt;num!=0) &#123; n=n+1; if(n==1) &#123; //如果这个结点是头结点，那么就把head指向p1 head=p1; &#125; else &#123; p2-&gt;next=p1; //如果不是，则使这个结点的next指向新开辟结点 &#125; p2=p1; //使p2指向刚才建立的结点 p1=(struct Student *)malloc(LEN);//生成新的结点 ，使p1指向它 scanf("%ld %f",&amp;p1-&gt;num,&amp;p1-&gt;score); &#125; p2-&gt;next=NULL; //当p2是表尾时，把NULL赋值给next，结束链表建立 return(head);&#125;void print(struct Student *head) &#123; struct Student *p; printf("\nNow,These %d records are:\n",n); p=head; if(head!=NULL) &#123; do &#123; printf("%ld %5.1f\n",p-&gt;num,p-&gt;score); p=p-&gt;next; &#125; while(p!=NULL); &#125;&#125;struct Student *insert(struct Student *head,struct Student *stu) &#123; struct Student *p0,*p1,*p2; p1=head; //使p1指向头结点 p0=stu; //指向要插入的结点 if(head==NULL) &#123; //原来的链表是空表 head=p0; p0-&gt;next=NULL; &#125; else &#123; while((p0-&gt;num&gt;p1-&gt;num)&amp;&amp;(p1-&gt;next!=NULL)) &#123; p2=p1; //使p2指向刚才p1指向的结点 p1=p1-&gt;next;//p1后移一个结点 &#125; if(p0-&gt;num&lt;p1-&gt;num) &#123; if(head==p1) &#123; head=p0; //插到原来第1个结点之前 &#125; else &#123; p2-&gt;next=p0;//插到p2指向的结点之后 p0-&gt;next=p1; &#125; &#125; else &#123; p1-&gt;next=p0; p0-&gt;next=NULL; //插到最后的结点之后 &#125; &#125; n=n+1; return(head); //结点数+1&#125;struct Student *del(struct Student *head,long num) &#123; struct Student *p1,*p2; if(head==NULL) &#123; printf("这是一张空表\n"); return(head); &#125; p1=head; //使p1指向第1个结点 while(num!=p1-&gt;num&amp;&amp;p1-&gt;next!=NULL) &#123; //p1指向的不是所要找的结点且后面还有结点 p2=p1; p1=p1-&gt;next; //p1向后移一个结点 &#125; if(num==p1-&gt;num) &#123; //找到了 if(p1==head) &#123; //若p1指向的是首结点，把第2个结点地址赋予head head=p1-&gt;next; &#125; else &#123; //否则将下一个结点地址赋给前一结点地址 p2-&gt;next=p1-&gt;next; &#125; printf("删除:%ld\n",num); n=n-1; &#125; else &#123; printf("%ld没有找到\n",num);//找不到该结点 &#125; return(head);&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择排序]]></title>
    <url>%2F2018%2F04%2F08%2F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[简单的写一下选择排序的源代码定义选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法（比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，导致第一个5挪动到第二个5后面）。 时间复杂度选择排序的交换操作介于 0 和 (n - 1） 次之间。选择排序的比较操作为 n (n - 1） / 2 次之间。选择排序的赋值操作介于 0 和 3 (n - 1） 次之间。 比较次数O(n^2），比较次数与关键字的初始状态无关，总的比较次数N=(n-1）+(n-2）+…+1=n*(n-1）/2。交换次数O(n），最好情况是，已经有序，交换0次；最坏情况交换n-1次，逆序交换n/2次。交换次数比冒泡排序少多了，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快 参考代码 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;//选择排序 int main() &#123; void selectsort(int array[],int n); int a[10],i; printf("输入10个数:\n"); for(i=0; i&lt;10; i++) &#123; scanf("%d",&amp;a[i]); &#125; selectsort(a,10); printf("选择排序之后:\n"); for(i=0; i&lt;10; i++) &#123; printf("%d ",a[i]); &#125; printf("\n"); return 0;&#125;void selectsort(int array[],int n) &#123; int i,j,min,temp; for(i=0; i&lt;n-1; i++) &#123; min=i; for(j=i+1; j&lt;n; j++)&#123; if(array[j]&lt;array[min]) min=j; &#125; temp=array[min]; array[min]=array[i]; array[i]=temp; &#125;&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博客测试]]></title>
    <url>%2F2018%2F04%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[这是我的第一篇博客= =，成功搭建了本网站地址 第一级标题生成一个hexo博客1$ hexo new "My New Post" 更多的信息: Writing 在本地跑起来1$ hexo server 更多的信息: Server 生成静态文件（保存） 1$ hexo generate 更多的信息: Generating 上传到github1$ hexo deploy 更多的信息: Deployment]]></content>
      <categories>
        <category>博客测试文件</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欢迎来到我的博客]]></title>
    <url>%2F2018%2F03%2F01%2F%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[欢迎来到我的博客，希望这里面的内容对你有帮助！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Face</tag>
      </tags>
  </entry>
</search>
